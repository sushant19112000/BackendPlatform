
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model UserLeave
 * 
 */
export type UserLeave = $Result.DefaultSelection<Prisma.$UserLeavePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model UserTask
 * 
 */
export type UserTask = $Result.DefaultSelection<Prisma.$UserTaskPayload>
/**
 * Model UserBreak
 * 
 */
export type UserBreak = $Result.DefaultSelection<Prisma.$UserBreakPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Break
 * 
 */
export type Break = $Result.DefaultSelection<Prisma.$BreakPayload>
/**
 * Model message
 * 
 */
export type message = $Result.DefaultSelection<Prisma.$messagePayload>
/**
 * Model groupMessage
 * 
 */
export type groupMessage = $Result.DefaultSelection<Prisma.$groupMessagePayload>
/**
 * Model group
 * 
 */
export type group = $Result.DefaultSelection<Prisma.$groupPayload>
/**
 * Model userGroups
 * 
 */
export type userGroups = $Result.DefaultSelection<Prisma.$userGroupsPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model notificationPriority
 * 
 */
export type notificationPriority = $Result.DefaultSelection<Prisma.$notificationPriorityPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model roleNotification
 * 
 */
export type roleNotification = $Result.DefaultSelection<Prisma.$roleNotificationPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>
/**
 * Model client
 * 
 */
export type client = $Result.DefaultSelection<Prisma.$clientPayload>
/**
 * Model campaign
 * 
 */
export type campaign = $Result.DefaultSelection<Prisma.$campaignPayload>
/**
 * Model campaignDeliveries
 * 
 */
export type campaignDeliveries = $Result.DefaultSelection<Prisma.$campaignDeliveriesPayload>
/**
 * Model campaignType
 * 
 */
export type campaignType = $Result.DefaultSelection<Prisma.$campaignTypePayload>
/**
 * Model volume
 * 
 */
export type volume = $Result.DefaultSelection<Prisma.$volumePayload>
/**
 * Model Brief
 * 
 */
export type Brief = $Result.DefaultSelection<Prisma.$BriefPayload>
/**
 * Model BriefUpdates
 * 
 */
export type BriefUpdates = $Result.DefaultSelection<Prisma.$BriefUpdatesPayload>
/**
 * Model pacing
 * 
 */
export type pacing = $Result.DefaultSelection<Prisma.$pacingPayload>
/**
 * Model lead
 * 
 */
export type lead = $Result.DefaultSelection<Prisma.$leadPayload>
/**
 * Model leadsUpload
 * 
 */
export type leadsUpload = $Result.DefaultSelection<Prisma.$leadsUploadPayload>
/**
 * Model pacingReport
 * 
 */
export type pacingReport = $Result.DefaultSelection<Prisma.$pacingReportPayload>
/**
 * Model campaignReport
 * 
 */
export type campaignReport = $Result.DefaultSelection<Prisma.$campaignReportPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LeaveType: {
  CASUAL: 'CASUAL',
  SICK: 'SICK',
  EARNED: 'EARNED',
  UNPAID: 'UNPAID'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveDuration: {
  FULL_DAY: 'FULL_DAY',
  HALF_DAY: 'HALF_DAY',
  MULTI_DAY: 'MULTI_DAY'
};

export type LeaveDuration = (typeof LeaveDuration)[keyof typeof LeaveDuration]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const SessionType: {
  TASK: 'TASK',
  BREAK: 'BREAK'
};

export type SessionType = (typeof SessionType)[keyof typeof SessionType]


export const TaskType: {
  Campaign: 'Campaign',
  Breif: 'Breif'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const TaskLevel: {
  URGENT: 'URGENT',
  VERY_URGENT: 'VERY_URGENT'
};

export type TaskLevel = (typeof TaskLevel)[keyof typeof TaskLevel]


export const VolumeStatus: {
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  IN_PROGRESS: 'IN_PROGRESS',
  IN_REVIEW: 'IN_REVIEW',
  COMPLETED: 'COMPLETED',
  ON_HOLD: 'ON_HOLD',
  CANCELLED: 'CANCELLED'
};

export type VolumeStatus = (typeof VolumeStatus)[keyof typeof VolumeStatus]


export const BriefType: {
  LEADGEN: 'LEADGEN',
  HTML: 'HTML'
};

export type BriefType = (typeof BriefType)[keyof typeof BriefType]


export const BriefStatus: {
  New: 'New',
  InProgress: 'InProgress',
  Pending: 'Pending',
  Quoted: 'Quoted',
  NewUpdate: 'NewUpdate'
};

export type BriefStatus = (typeof BriefStatus)[keyof typeof BriefStatus]


export const reportType: {
  TODAY: 'TODAY',
  OVERDUE: 'OVERDUE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ALL: 'ALL'
};

export type reportType = (typeof reportType)[keyof typeof reportType]


export const generatedType: {
  AUTO: 'AUTO',
  ADMIN: 'ADMIN'
};

export type generatedType = (typeof generatedType)[keyof typeof generatedType]

}

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveDuration = $Enums.LeaveDuration

export const LeaveDuration: typeof $Enums.LeaveDuration

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type SessionType = $Enums.SessionType

export const SessionType: typeof $Enums.SessionType

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type TaskLevel = $Enums.TaskLevel

export const TaskLevel: typeof $Enums.TaskLevel

export type VolumeStatus = $Enums.VolumeStatus

export const VolumeStatus: typeof $Enums.VolumeStatus

export type BriefType = $Enums.BriefType

export const BriefType: typeof $Enums.BriefType

export type BriefStatus = $Enums.BriefStatus

export const BriefStatus: typeof $Enums.BriefStatus

export type reportType = $Enums.reportType

export const reportType: typeof $Enums.reportType

export type generatedType = $Enums.generatedType

export const generatedType: typeof $Enums.generatedType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLeave`: Exposes CRUD operations for the **UserLeave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLeaves
    * const userLeaves = await prisma.userLeave.findMany()
    * ```
    */
  get userLeave(): Prisma.UserLeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTask`: Exposes CRUD operations for the **UserTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTasks
    * const userTasks = await prisma.userTask.findMany()
    * ```
    */
  get userTask(): Prisma.UserTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBreak`: Exposes CRUD operations for the **UserBreak** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBreaks
    * const userBreaks = await prisma.userBreak.findMany()
    * ```
    */
  get userBreak(): Prisma.UserBreakDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.break`: Exposes CRUD operations for the **Break** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Breaks
    * const breaks = await prisma.break.findMany()
    * ```
    */
  get break(): Prisma.BreakDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMessage`: Exposes CRUD operations for the **groupMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMessages
    * const groupMessages = await prisma.groupMessage.findMany()
    * ```
    */
  get groupMessage(): Prisma.groupMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGroups`: Exposes CRUD operations for the **userGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroups.findMany()
    * ```
    */
  get userGroups(): Prisma.userGroupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPriority`: Exposes CRUD operations for the **notificationPriority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPriorities
    * const notificationPriorities = await prisma.notificationPriority.findMany()
    * ```
    */
  get notificationPriority(): Prisma.notificationPriorityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleNotification`: Exposes CRUD operations for the **roleNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleNotifications
    * const roleNotifications = await prisma.roleNotification.findMany()
    * ```
    */
  get roleNotification(): Prisma.roleNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.clientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.campaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignDeliveries`: Exposes CRUD operations for the **campaignDeliveries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignDeliveries
    * const campaignDeliveries = await prisma.campaignDeliveries.findMany()
    * ```
    */
  get campaignDeliveries(): Prisma.campaignDeliveriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignType`: Exposes CRUD operations for the **campaignType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTypes
    * const campaignTypes = await prisma.campaignType.findMany()
    * ```
    */
  get campaignType(): Prisma.campaignTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volume`: Exposes CRUD operations for the **volume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Volumes
    * const volumes = await prisma.volume.findMany()
    * ```
    */
  get volume(): Prisma.volumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brief`: Exposes CRUD operations for the **Brief** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Briefs
    * const briefs = await prisma.brief.findMany()
    * ```
    */
  get brief(): Prisma.BriefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.briefUpdates`: Exposes CRUD operations for the **BriefUpdates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BriefUpdates
    * const briefUpdates = await prisma.briefUpdates.findMany()
    * ```
    */
  get briefUpdates(): Prisma.BriefUpdatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pacing`: Exposes CRUD operations for the **pacing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pacings
    * const pacings = await prisma.pacing.findMany()
    * ```
    */
  get pacing(): Prisma.pacingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.leadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadsUpload`: Exposes CRUD operations for the **leadsUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadsUploads
    * const leadsUploads = await prisma.leadsUpload.findMany()
    * ```
    */
  get leadsUpload(): Prisma.leadsUploadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pacingReport`: Exposes CRUD operations for the **pacingReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PacingReports
    * const pacingReports = await prisma.pacingReport.findMany()
    * ```
    */
  get pacingReport(): Prisma.pacingReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignReport`: Exposes CRUD operations for the **campaignReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignReports
    * const campaignReports = await prisma.campaignReport.findMany()
    * ```
    */
  get campaignReport(): Prisma.campaignReportDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    Attendance: 'Attendance',
    UserLeave: 'UserLeave',
    Session: 'Session',
    UserTask: 'UserTask',
    UserBreak: 'UserBreak',
    Task: 'Task',
    Break: 'Break',
    message: 'message',
    groupMessage: 'groupMessage',
    group: 'group',
    userGroups: 'userGroups',
    notification: 'notification',
    notificationPriority: 'notificationPriority',
    role: 'role',
    roleNotification: 'roleNotification',
    userrole: 'userrole',
    client: 'client',
    campaign: 'campaign',
    campaignDeliveries: 'campaignDeliveries',
    campaignType: 'campaignType',
    volume: 'volume',
    Brief: 'Brief',
    BriefUpdates: 'BriefUpdates',
    pacing: 'pacing',
    lead: 'lead',
    leadsUpload: 'leadsUpload',
    pacingReport: 'pacingReport',
    campaignReport: 'campaignReport'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "attendance" | "userLeave" | "session" | "userTask" | "userBreak" | "task" | "break" | "message" | "groupMessage" | "group" | "userGroups" | "notification" | "notificationPriority" | "role" | "roleNotification" | "userrole" | "client" | "campaign" | "campaignDeliveries" | "campaignType" | "volume" | "brief" | "briefUpdates" | "pacing" | "lead" | "leadsUpload" | "pacingReport" | "campaignReport"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      UserLeave: {
        payload: Prisma.$UserLeavePayload<ExtArgs>
        fields: Prisma.UserLeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>
          }
          findFirst: {
            args: Prisma.UserLeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>
          }
          findMany: {
            args: Prisma.UserLeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>[]
          }
          create: {
            args: Prisma.UserLeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>
          }
          createMany: {
            args: Prisma.UserLeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>[]
          }
          delete: {
            args: Prisma.UserLeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>
          }
          update: {
            args: Prisma.UserLeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>
          }
          deleteMany: {
            args: Prisma.UserLeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>[]
          }
          upsert: {
            args: Prisma.UserLeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLeavePayload>
          }
          aggregate: {
            args: Prisma.UserLeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLeave>
          }
          groupBy: {
            args: Prisma.UserLeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLeaveCountArgs<ExtArgs>
            result: $Utils.Optional<UserLeaveCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      UserTask: {
        payload: Prisma.$UserTaskPayload<ExtArgs>
        fields: Prisma.UserTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>
          }
          findFirst: {
            args: Prisma.UserTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>
          }
          findMany: {
            args: Prisma.UserTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>[]
          }
          create: {
            args: Prisma.UserTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>
          }
          createMany: {
            args: Prisma.UserTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>[]
          }
          delete: {
            args: Prisma.UserTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>
          }
          update: {
            args: Prisma.UserTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>
          }
          deleteMany: {
            args: Prisma.UserTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>[]
          }
          upsert: {
            args: Prisma.UserTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskPayload>
          }
          aggregate: {
            args: Prisma.UserTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTask>
          }
          groupBy: {
            args: Prisma.UserTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTaskCountArgs<ExtArgs>
            result: $Utils.Optional<UserTaskCountAggregateOutputType> | number
          }
        }
      }
      UserBreak: {
        payload: Prisma.$UserBreakPayload<ExtArgs>
        fields: Prisma.UserBreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>
          }
          findFirst: {
            args: Prisma.UserBreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>
          }
          findMany: {
            args: Prisma.UserBreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>[]
          }
          create: {
            args: Prisma.UserBreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>
          }
          createMany: {
            args: Prisma.UserBreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>[]
          }
          delete: {
            args: Prisma.UserBreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>
          }
          update: {
            args: Prisma.UserBreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>
          }
          deleteMany: {
            args: Prisma.UserBreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBreakUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>[]
          }
          upsert: {
            args: Prisma.UserBreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBreakPayload>
          }
          aggregate: {
            args: Prisma.UserBreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBreak>
          }
          groupBy: {
            args: Prisma.UserBreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBreakCountArgs<ExtArgs>
            result: $Utils.Optional<UserBreakCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Break: {
        payload: Prisma.$BreakPayload<ExtArgs>
        fields: Prisma.BreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>
          }
          findFirst: {
            args: Prisma.BreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>
          }
          findMany: {
            args: Prisma.BreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>[]
          }
          create: {
            args: Prisma.BreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>
          }
          createMany: {
            args: Prisma.BreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>[]
          }
          delete: {
            args: Prisma.BreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>
          }
          update: {
            args: Prisma.BreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>
          }
          deleteMany: {
            args: Prisma.BreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BreakUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>[]
          }
          upsert: {
            args: Prisma.BreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPayload>
          }
          aggregate: {
            args: Prisma.BreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreak>
          }
          groupBy: {
            args: Prisma.BreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreakCountArgs<ExtArgs>
            result: $Utils.Optional<BreakCountAggregateOutputType> | number
          }
        }
      }
      message: {
        payload: Prisma.$messagePayload<ExtArgs>
        fields: Prisma.messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      groupMessage: {
        payload: Prisma.$groupMessagePayload<ExtArgs>
        fields: Prisma.groupMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>
          }
          findFirst: {
            args: Prisma.groupMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>
          }
          findMany: {
            args: Prisma.groupMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>[]
          }
          create: {
            args: Prisma.groupMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>
          }
          createMany: {
            args: Prisma.groupMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.groupMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>[]
          }
          delete: {
            args: Prisma.groupMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>
          }
          update: {
            args: Prisma.groupMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>
          }
          deleteMany: {
            args: Prisma.groupMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.groupMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>[]
          }
          upsert: {
            args: Prisma.groupMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupMessagePayload>
          }
          aggregate: {
            args: Prisma.GroupMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMessage>
          }
          groupBy: {
            args: Prisma.groupMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupMessageCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMessageCountAggregateOutputType> | number
          }
        }
      }
      group: {
        payload: Prisma.$groupPayload<ExtArgs>
        fields: Prisma.groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          findFirst: {
            args: Prisma.groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          findMany: {
            args: Prisma.groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          create: {
            args: Prisma.groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          createMany: {
            args: Prisma.groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.groupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          delete: {
            args: Prisma.groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          update: {
            args: Prisma.groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          deleteMany: {
            args: Prisma.groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.groupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          upsert: {
            args: Prisma.groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      userGroups: {
        payload: Prisma.$userGroupsPayload<ExtArgs>
        fields: Prisma.userGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userGroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userGroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>
          }
          findFirst: {
            args: Prisma.userGroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userGroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>
          }
          findMany: {
            args: Prisma.userGroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>[]
          }
          create: {
            args: Prisma.userGroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>
          }
          createMany: {
            args: Prisma.userGroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userGroupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>[]
          }
          delete: {
            args: Prisma.userGroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>
          }
          update: {
            args: Prisma.userGroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>
          }
          deleteMany: {
            args: Prisma.userGroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userGroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userGroupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>[]
          }
          upsert: {
            args: Prisma.userGroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userGroupsPayload>
          }
          aggregate: {
            args: Prisma.UserGroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGroups>
          }
          groupBy: {
            args: Prisma.userGroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.userGroupsCountArgs<ExtArgs>
            result: $Utils.Optional<UserGroupsCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      notificationPriority: {
        payload: Prisma.$notificationPriorityPayload<ExtArgs>
        fields: Prisma.notificationPriorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationPriorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationPriorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>
          }
          findFirst: {
            args: Prisma.notificationPriorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationPriorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>
          }
          findMany: {
            args: Prisma.notificationPriorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>[]
          }
          create: {
            args: Prisma.notificationPriorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>
          }
          createMany: {
            args: Prisma.notificationPriorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationPriorityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>[]
          }
          delete: {
            args: Prisma.notificationPriorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>
          }
          update: {
            args: Prisma.notificationPriorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>
          }
          deleteMany: {
            args: Prisma.notificationPriorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationPriorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationPriorityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>[]
          }
          upsert: {
            args: Prisma.notificationPriorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPriorityPayload>
          }
          aggregate: {
            args: Prisma.NotificationPriorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPriority>
          }
          groupBy: {
            args: Prisma.notificationPriorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPriorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationPriorityCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPriorityCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      roleNotification: {
        payload: Prisma.$roleNotificationPayload<ExtArgs>
        fields: Prisma.roleNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>
          }
          findFirst: {
            args: Prisma.roleNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>
          }
          findMany: {
            args: Prisma.roleNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>[]
          }
          create: {
            args: Prisma.roleNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>
          }
          createMany: {
            args: Prisma.roleNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>[]
          }
          delete: {
            args: Prisma.roleNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>
          }
          update: {
            args: Prisma.roleNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>
          }
          deleteMany: {
            args: Prisma.roleNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.roleNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>[]
          }
          upsert: {
            args: Prisma.roleNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roleNotificationPayload>
          }
          aggregate: {
            args: Prisma.RoleNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleNotification>
          }
          groupBy: {
            args: Prisma.roleNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<RoleNotificationCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userroleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userroleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
      client: {
        payload: Prisma.$clientPayload<ExtArgs>
        fields: Prisma.clientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          findFirst: {
            args: Prisma.clientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          findMany: {
            args: Prisma.clientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          create: {
            args: Prisma.clientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          createMany: {
            args: Prisma.clientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          delete: {
            args: Prisma.clientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          update: {
            args: Prisma.clientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          deleteMany: {
            args: Prisma.clientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>[]
          }
          upsert: {
            args: Prisma.clientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.clientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      campaign: {
        payload: Prisma.$campaignPayload<ExtArgs>
        fields: Prisma.campaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>
          }
          findFirst: {
            args: Prisma.campaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>
          }
          findMany: {
            args: Prisma.campaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>[]
          }
          create: {
            args: Prisma.campaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>
          }
          createMany: {
            args: Prisma.campaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>[]
          }
          delete: {
            args: Prisma.campaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>
          }
          update: {
            args: Prisma.campaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>
          }
          deleteMany: {
            args: Prisma.campaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>[]
          }
          upsert: {
            args: Prisma.campaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.campaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      campaignDeliveries: {
        payload: Prisma.$campaignDeliveriesPayload<ExtArgs>
        fields: Prisma.campaignDeliveriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaignDeliveriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaignDeliveriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>
          }
          findFirst: {
            args: Prisma.campaignDeliveriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaignDeliveriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>
          }
          findMany: {
            args: Prisma.campaignDeliveriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>[]
          }
          create: {
            args: Prisma.campaignDeliveriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>
          }
          createMany: {
            args: Prisma.campaignDeliveriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaignDeliveriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>[]
          }
          delete: {
            args: Prisma.campaignDeliveriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>
          }
          update: {
            args: Prisma.campaignDeliveriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>
          }
          deleteMany: {
            args: Prisma.campaignDeliveriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaignDeliveriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campaignDeliveriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>[]
          }
          upsert: {
            args: Prisma.campaignDeliveriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignDeliveriesPayload>
          }
          aggregate: {
            args: Prisma.CampaignDeliveriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignDeliveries>
          }
          groupBy: {
            args: Prisma.campaignDeliveriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignDeliveriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaignDeliveriesCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignDeliveriesCountAggregateOutputType> | number
          }
        }
      }
      campaignType: {
        payload: Prisma.$campaignTypePayload<ExtArgs>
        fields: Prisma.campaignTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaignTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaignTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>
          }
          findFirst: {
            args: Prisma.campaignTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaignTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>
          }
          findMany: {
            args: Prisma.campaignTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>[]
          }
          create: {
            args: Prisma.campaignTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>
          }
          createMany: {
            args: Prisma.campaignTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaignTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>[]
          }
          delete: {
            args: Prisma.campaignTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>
          }
          update: {
            args: Prisma.campaignTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>
          }
          deleteMany: {
            args: Prisma.campaignTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaignTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campaignTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>[]
          }
          upsert: {
            args: Prisma.campaignTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignTypePayload>
          }
          aggregate: {
            args: Prisma.CampaignTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignType>
          }
          groupBy: {
            args: Prisma.campaignTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaignTypeCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignTypeCountAggregateOutputType> | number
          }
        }
      }
      volume: {
        payload: Prisma.$volumePayload<ExtArgs>
        fields: Prisma.volumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.volumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.volumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>
          }
          findFirst: {
            args: Prisma.volumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.volumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>
          }
          findMany: {
            args: Prisma.volumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>[]
          }
          create: {
            args: Prisma.volumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>
          }
          createMany: {
            args: Prisma.volumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.volumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>[]
          }
          delete: {
            args: Prisma.volumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>
          }
          update: {
            args: Prisma.volumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>
          }
          deleteMany: {
            args: Prisma.volumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.volumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.volumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>[]
          }
          upsert: {
            args: Prisma.volumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volumePayload>
          }
          aggregate: {
            args: Prisma.VolumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolume>
          }
          groupBy: {
            args: Prisma.volumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.volumeCountArgs<ExtArgs>
            result: $Utils.Optional<VolumeCountAggregateOutputType> | number
          }
        }
      }
      Brief: {
        payload: Prisma.$BriefPayload<ExtArgs>
        fields: Prisma.BriefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BriefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BriefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>
          }
          findFirst: {
            args: Prisma.BriefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BriefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>
          }
          findMany: {
            args: Prisma.BriefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>[]
          }
          create: {
            args: Prisma.BriefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>
          }
          createMany: {
            args: Prisma.BriefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BriefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>[]
          }
          delete: {
            args: Prisma.BriefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>
          }
          update: {
            args: Prisma.BriefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>
          }
          deleteMany: {
            args: Prisma.BriefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BriefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BriefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>[]
          }
          upsert: {
            args: Prisma.BriefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefPayload>
          }
          aggregate: {
            args: Prisma.BriefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrief>
          }
          groupBy: {
            args: Prisma.BriefGroupByArgs<ExtArgs>
            result: $Utils.Optional<BriefGroupByOutputType>[]
          }
          count: {
            args: Prisma.BriefCountArgs<ExtArgs>
            result: $Utils.Optional<BriefCountAggregateOutputType> | number
          }
        }
      }
      BriefUpdates: {
        payload: Prisma.$BriefUpdatesPayload<ExtArgs>
        fields: Prisma.BriefUpdatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BriefUpdatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BriefUpdatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>
          }
          findFirst: {
            args: Prisma.BriefUpdatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BriefUpdatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>
          }
          findMany: {
            args: Prisma.BriefUpdatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>[]
          }
          create: {
            args: Prisma.BriefUpdatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>
          }
          createMany: {
            args: Prisma.BriefUpdatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BriefUpdatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>[]
          }
          delete: {
            args: Prisma.BriefUpdatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>
          }
          update: {
            args: Prisma.BriefUpdatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>
          }
          deleteMany: {
            args: Prisma.BriefUpdatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BriefUpdatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BriefUpdatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>[]
          }
          upsert: {
            args: Prisma.BriefUpdatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BriefUpdatesPayload>
          }
          aggregate: {
            args: Prisma.BriefUpdatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBriefUpdates>
          }
          groupBy: {
            args: Prisma.BriefUpdatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BriefUpdatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BriefUpdatesCountArgs<ExtArgs>
            result: $Utils.Optional<BriefUpdatesCountAggregateOutputType> | number
          }
        }
      }
      pacing: {
        payload: Prisma.$pacingPayload<ExtArgs>
        fields: Prisma.pacingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pacingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pacingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>
          }
          findFirst: {
            args: Prisma.pacingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pacingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>
          }
          findMany: {
            args: Prisma.pacingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>[]
          }
          create: {
            args: Prisma.pacingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>
          }
          createMany: {
            args: Prisma.pacingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pacingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>[]
          }
          delete: {
            args: Prisma.pacingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>
          }
          update: {
            args: Prisma.pacingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>
          }
          deleteMany: {
            args: Prisma.pacingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pacingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pacingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>[]
          }
          upsert: {
            args: Prisma.pacingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingPayload>
          }
          aggregate: {
            args: Prisma.PacingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePacing>
          }
          groupBy: {
            args: Prisma.pacingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacingGroupByOutputType>[]
          }
          count: {
            args: Prisma.pacingCountArgs<ExtArgs>
            result: $Utils.Optional<PacingCountAggregateOutputType> | number
          }
        }
      }
      lead: {
        payload: Prisma.$leadPayload<ExtArgs>
        fields: Prisma.leadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>
          }
          findFirst: {
            args: Prisma.leadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>
          }
          findMany: {
            args: Prisma.leadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>[]
          }
          create: {
            args: Prisma.leadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>
          }
          createMany: {
            args: Prisma.leadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.leadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>[]
          }
          delete: {
            args: Prisma.leadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>
          }
          update: {
            args: Prisma.leadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>
          }
          deleteMany: {
            args: Prisma.leadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.leadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.leadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>[]
          }
          upsert: {
            args: Prisma.leadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.leadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.leadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      leadsUpload: {
        payload: Prisma.$leadsUploadPayload<ExtArgs>
        fields: Prisma.leadsUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leadsUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leadsUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>
          }
          findFirst: {
            args: Prisma.leadsUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leadsUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>
          }
          findMany: {
            args: Prisma.leadsUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>[]
          }
          create: {
            args: Prisma.leadsUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>
          }
          createMany: {
            args: Prisma.leadsUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.leadsUploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>[]
          }
          delete: {
            args: Prisma.leadsUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>
          }
          update: {
            args: Prisma.leadsUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>
          }
          deleteMany: {
            args: Prisma.leadsUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.leadsUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.leadsUploadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>[]
          }
          upsert: {
            args: Prisma.leadsUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leadsUploadPayload>
          }
          aggregate: {
            args: Prisma.LeadsUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadsUpload>
          }
          groupBy: {
            args: Prisma.leadsUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadsUploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.leadsUploadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadsUploadCountAggregateOutputType> | number
          }
        }
      }
      pacingReport: {
        payload: Prisma.$pacingReportPayload<ExtArgs>
        fields: Prisma.pacingReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pacingReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pacingReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>
          }
          findFirst: {
            args: Prisma.pacingReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pacingReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>
          }
          findMany: {
            args: Prisma.pacingReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>[]
          }
          create: {
            args: Prisma.pacingReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>
          }
          createMany: {
            args: Prisma.pacingReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pacingReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>[]
          }
          delete: {
            args: Prisma.pacingReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>
          }
          update: {
            args: Prisma.pacingReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>
          }
          deleteMany: {
            args: Prisma.pacingReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pacingReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pacingReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>[]
          }
          upsert: {
            args: Prisma.pacingReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacingReportPayload>
          }
          aggregate: {
            args: Prisma.PacingReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePacingReport>
          }
          groupBy: {
            args: Prisma.pacingReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacingReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.pacingReportCountArgs<ExtArgs>
            result: $Utils.Optional<PacingReportCountAggregateOutputType> | number
          }
        }
      }
      campaignReport: {
        payload: Prisma.$campaignReportPayload<ExtArgs>
        fields: Prisma.campaignReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaignReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaignReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>
          }
          findFirst: {
            args: Prisma.campaignReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaignReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>
          }
          findMany: {
            args: Prisma.campaignReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>[]
          }
          create: {
            args: Prisma.campaignReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>
          }
          createMany: {
            args: Prisma.campaignReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaignReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>[]
          }
          delete: {
            args: Prisma.campaignReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>
          }
          update: {
            args: Prisma.campaignReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>
          }
          deleteMany: {
            args: Prisma.campaignReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaignReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.campaignReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>[]
          }
          upsert: {
            args: Prisma.campaignReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignReportPayload>
          }
          aggregate: {
            args: Prisma.CampaignReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignReport>
          }
          groupBy: {
            args: Prisma.campaignReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaignReportCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignReportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: userOmit
    attendance?: AttendanceOmit
    userLeave?: UserLeaveOmit
    session?: SessionOmit
    userTask?: UserTaskOmit
    userBreak?: UserBreakOmit
    task?: TaskOmit
    break?: BreakOmit
    message?: messageOmit
    groupMessage?: groupMessageOmit
    group?: groupOmit
    userGroups?: userGroupsOmit
    notification?: notificationOmit
    notificationPriority?: notificationPriorityOmit
    role?: roleOmit
    roleNotification?: roleNotificationOmit
    userrole?: userroleOmit
    client?: clientOmit
    campaign?: campaignOmit
    campaignDeliveries?: campaignDeliveriesOmit
    campaignType?: campaignTypeOmit
    volume?: volumeOmit
    brief?: BriefOmit
    briefUpdates?: BriefUpdatesOmit
    pacing?: pacingOmit
    lead?: leadOmit
    leadsUpload?: leadsUploadOmit
    pacingReport?: pacingReportOmit
    campaignReport?: campaignReportOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    uploads: number
    roles: number
    leaves: number
    approvedLeaves: number
    sentMessages: number
    receivedMessages: number
    groups: number
    sentMessage: number
    tasks: number
    breaks: number
    assignedTasks: number
    sessions: number
    deliveries: number
    attendance: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploads?: boolean | UserCountOutputTypeCountUploadsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    leaves?: boolean | UserCountOutputTypeCountLeavesArgs
    approvedLeaves?: boolean | UserCountOutputTypeCountApprovedLeavesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
    sentMessage?: boolean | UserCountOutputTypeCountSentMessageArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    breaks?: boolean | UserCountOutputTypeCountBreaksArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    deliveries?: boolean | UserCountOutputTypeCountDeliveriesArgs
    attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadsUploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userGroupsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBreaksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBreakWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignDeliveriesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type UserTaskCountOutputType
   */

  export type UserTaskCountOutputType = {
    sessions: number
  }

  export type UserTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserTaskCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserTaskCountOutputType without action
   */
  export type UserTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCountOutputType
     */
    select?: UserTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserTaskCountOutputType without action
   */
  export type UserTaskCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type UserBreakCountOutputType
   */

  export type UserBreakCountOutputType = {
    sessions: number
  }

  export type UserBreakCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserBreakCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserBreakCountOutputType without action
   */
  export type UserBreakCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreakCountOutputType
     */
    select?: UserBreakCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserBreakCountOutputType without action
   */
  export type UserBreakCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    users: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TaskCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskWhereInput
  }


  /**
   * Count Type BreakCountOutputType
   */

  export type BreakCountOutputType = {
    users: number
  }

  export type BreakCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BreakCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BreakCountOutputType without action
   */
  export type BreakCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakCountOutputType
     */
    select?: BreakCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BreakCountOutputType without action
   */
  export type BreakCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBreakWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    groupMessages: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    groupMessages?: boolean | GroupCountOutputTypeCountGroupMessagesArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userGroupsWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupMessageWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    roleNotifications: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleNotifications?: boolean | NotificationCountOutputTypeCountRoleNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountRoleNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleNotificationWhereInput
  }


  /**
   * Count Type NotificationPriorityCountOutputType
   */

  export type NotificationPriorityCountOutputType = {
    notifications: number
  }

  export type NotificationPriorityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | NotificationPriorityCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationPriorityCountOutputType without action
   */
  export type NotificationPriorityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPriorityCountOutputType
     */
    select?: NotificationPriorityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationPriorityCountOutputType without action
   */
  export type NotificationPriorityCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    roleNotifications: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    roleNotifications?: boolean | RoleCountOutputTypeCountRoleNotificationsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRoleNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleNotificationWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    campaigns: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | ClientCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    volumes: number
    leads: number
    campaignDeliveries: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volumes?: boolean | CampaignCountOutputTypeCountVolumesArgs
    leads?: boolean | CampaignCountOutputTypeCountLeadsArgs
    campaignDeliveries?: boolean | CampaignCountOutputTypeCountCampaignDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountVolumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: volumeWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignDeliveriesWhereInput
  }


  /**
   * Count Type CampaignDeliveriesCountOutputType
   */

  export type CampaignDeliveriesCountOutputType = {
    leads: number
  }

  export type CampaignDeliveriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | CampaignDeliveriesCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * CampaignDeliveriesCountOutputType without action
   */
  export type CampaignDeliveriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDeliveriesCountOutputType
     */
    select?: CampaignDeliveriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignDeliveriesCountOutputType without action
   */
  export type CampaignDeliveriesCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
  }


  /**
   * Count Type VolumeCountOutputType
   */

  export type VolumeCountOutputType = {
    pacings: number
    leads: number
  }

  export type VolumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacings?: boolean | VolumeCountOutputTypeCountPacingsArgs
    leads?: boolean | VolumeCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * VolumeCountOutputType without action
   */
  export type VolumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeCountOutputType
     */
    select?: VolumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VolumeCountOutputType without action
   */
  export type VolumeCountOutputTypeCountPacingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacingWhereInput
  }

  /**
   * VolumeCountOutputType without action
   */
  export type VolumeCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
  }


  /**
   * Count Type BriefCountOutputType
   */

  export type BriefCountOutputType = {
    briefUpdates: number
  }

  export type BriefCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    briefUpdates?: boolean | BriefCountOutputTypeCountBriefUpdatesArgs
  }

  // Custom InputTypes
  /**
   * BriefCountOutputType without action
   */
  export type BriefCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefCountOutputType
     */
    select?: BriefCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BriefCountOutputType without action
   */
  export type BriefCountOutputTypeCountBriefUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BriefUpdatesWhereInput
  }


  /**
   * Count Type PacingCountOutputType
   */

  export type PacingCountOutputType = {
    leads: number
    uploads: number
  }

  export type PacingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | PacingCountOutputTypeCountLeadsArgs
    uploads?: boolean | PacingCountOutputTypeCountUploadsArgs
  }

  // Custom InputTypes
  /**
   * PacingCountOutputType without action
   */
  export type PacingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PacingCountOutputType
     */
    select?: PacingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PacingCountOutputType without action
   */
  export type PacingCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
  }

  /**
   * PacingCountOutputType without action
   */
  export type PacingCountOutputTypeCountUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadsUploadWhereInput
  }


  /**
   * Count Type LeadsUploadCountOutputType
   */

  export type LeadsUploadCountOutputType = {
    leads: number
  }

  export type LeadsUploadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | LeadsUploadCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * LeadsUploadCountOutputType without action
   */
  export type LeadsUploadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadsUploadCountOutputType
     */
    select?: LeadsUploadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadsUploadCountOutputType without action
   */
  export type LeadsUploadCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    password: string
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
    uploads?: boolean | user$uploadsArgs<ExtArgs>
    roles?: boolean | user$rolesArgs<ExtArgs>
    leaves?: boolean | user$leavesArgs<ExtArgs>
    approvedLeaves?: boolean | user$approvedLeavesArgs<ExtArgs>
    sentMessages?: boolean | user$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | user$receivedMessagesArgs<ExtArgs>
    groups?: boolean | user$groupsArgs<ExtArgs>
    sentMessage?: boolean | user$sentMessageArgs<ExtArgs>
    tasks?: boolean | user$tasksArgs<ExtArgs>
    breaks?: boolean | user$breaksArgs<ExtArgs>
    assignedTasks?: boolean | user$assignedTasksArgs<ExtArgs>
    sessions?: boolean | user$sessionsArgs<ExtArgs>
    deliveries?: boolean | user$deliveriesArgs<ExtArgs>
    attendance?: boolean | user$attendanceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploads?: boolean | user$uploadsArgs<ExtArgs>
    roles?: boolean | user$rolesArgs<ExtArgs>
    leaves?: boolean | user$leavesArgs<ExtArgs>
    approvedLeaves?: boolean | user$approvedLeavesArgs<ExtArgs>
    sentMessages?: boolean | user$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | user$receivedMessagesArgs<ExtArgs>
    groups?: boolean | user$groupsArgs<ExtArgs>
    sentMessage?: boolean | user$sentMessageArgs<ExtArgs>
    tasks?: boolean | user$tasksArgs<ExtArgs>
    breaks?: boolean | user$breaksArgs<ExtArgs>
    assignedTasks?: boolean | user$assignedTasksArgs<ExtArgs>
    sessions?: boolean | user$sessionsArgs<ExtArgs>
    deliveries?: boolean | user$deliveriesArgs<ExtArgs>
    attendance?: boolean | user$attendanceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      uploads: Prisma.$leadsUploadPayload<ExtArgs>[]
      roles: Prisma.$userrolePayload<ExtArgs>[]
      leaves: Prisma.$UserLeavePayload<ExtArgs>[]
      approvedLeaves: Prisma.$UserLeavePayload<ExtArgs>[]
      sentMessages: Prisma.$messagePayload<ExtArgs>[]
      receivedMessages: Prisma.$messagePayload<ExtArgs>[]
      groups: Prisma.$userGroupsPayload<ExtArgs>[]
      sentMessage: Prisma.$groupMessagePayload<ExtArgs>[]
      tasks: Prisma.$UserTaskPayload<ExtArgs>[]
      breaks: Prisma.$UserBreakPayload<ExtArgs>[]
      assignedTasks: Prisma.$UserTaskPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      deliveries: Prisma.$campaignDeliveriesPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      password: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploads<T extends user$uploadsArgs<ExtArgs> = {}>(args?: Subset<T, user$uploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends user$rolesArgs<ExtArgs> = {}>(args?: Subset<T, user$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends user$leavesArgs<ExtArgs> = {}>(args?: Subset<T, user$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedLeaves<T extends user$approvedLeavesArgs<ExtArgs> = {}>(args?: Subset<T, user$approvedLeavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends user$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, user$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends user$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, user$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends user$groupsArgs<ExtArgs> = {}>(args?: Subset<T, user$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessage<T extends user$sentMessageArgs<ExtArgs> = {}>(args?: Subset<T, user$sentMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends user$tasksArgs<ExtArgs> = {}>(args?: Subset<T, user$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    breaks<T extends user$breaksArgs<ExtArgs> = {}>(args?: Subset<T, user$breaksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends user$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, user$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends user$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, user$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends user$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, user$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends user$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, user$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.uploads
   */
  export type user$uploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    where?: leadsUploadWhereInput
    orderBy?: leadsUploadOrderByWithRelationInput | leadsUploadOrderByWithRelationInput[]
    cursor?: leadsUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadsUploadScalarFieldEnum | LeadsUploadScalarFieldEnum[]
  }

  /**
   * user.roles
   */
  export type user$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * user.leaves
   */
  export type user$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    where?: UserLeaveWhereInput
    orderBy?: UserLeaveOrderByWithRelationInput | UserLeaveOrderByWithRelationInput[]
    cursor?: UserLeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLeaveScalarFieldEnum | UserLeaveScalarFieldEnum[]
  }

  /**
   * user.approvedLeaves
   */
  export type user$approvedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    where?: UserLeaveWhereInput
    orderBy?: UserLeaveOrderByWithRelationInput | UserLeaveOrderByWithRelationInput[]
    cursor?: UserLeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLeaveScalarFieldEnum | UserLeaveScalarFieldEnum[]
  }

  /**
   * user.sentMessages
   */
  export type user$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * user.receivedMessages
   */
  export type user$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * user.groups
   */
  export type user$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    where?: userGroupsWhereInput
    orderBy?: userGroupsOrderByWithRelationInput | userGroupsOrderByWithRelationInput[]
    cursor?: userGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }

  /**
   * user.sentMessage
   */
  export type user$sentMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    where?: groupMessageWhereInput
    orderBy?: groupMessageOrderByWithRelationInput | groupMessageOrderByWithRelationInput[]
    cursor?: groupMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * user.tasks
   */
  export type user$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    where?: UserTaskWhereInput
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    cursor?: UserTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTaskScalarFieldEnum | UserTaskScalarFieldEnum[]
  }

  /**
   * user.breaks
   */
  export type user$breaksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    where?: UserBreakWhereInput
    orderBy?: UserBreakOrderByWithRelationInput | UserBreakOrderByWithRelationInput[]
    cursor?: UserBreakWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBreakScalarFieldEnum | UserBreakScalarFieldEnum[]
  }

  /**
   * user.assignedTasks
   */
  export type user$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    where?: UserTaskWhereInput
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    cursor?: UserTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTaskScalarFieldEnum | UserTaskScalarFieldEnum[]
  }

  /**
   * user.sessions
   */
  export type user$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * user.deliveries
   */
  export type user$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    where?: campaignDeliveriesWhereInput
    orderBy?: campaignDeliveriesOrderByWithRelationInput | campaignDeliveriesOrderByWithRelationInput[]
    cursor?: campaignDeliveriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignDeliveriesScalarFieldEnum | CampaignDeliveriesScalarFieldEnum[]
  }

  /**
   * user.attendance
   */
  export type user$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
    createdAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
    createdAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    checkIn: number
    checkOut: number
    createdAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkIn?: true
    checkOut?: true
    createdAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkIn?: true
    checkOut?: true
    createdAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    checkIn?: true
    checkOut?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    userId: number
    date: Date
    checkIn: Date
    checkOut: Date | null
    createdAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    createdAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    createdAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    createdAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    createdAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "checkIn" | "checkOut" | "createdAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      date: Date
      checkIn: Date
      checkOut: Date | null
      createdAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'Int'>
    readonly userId: FieldRef<"Attendance", 'Int'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly checkIn: FieldRef<"Attendance", 'DateTime'>
    readonly checkOut: FieldRef<"Attendance", 'DateTime'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model UserLeave
   */

  export type AggregateUserLeave = {
    _count: UserLeaveCountAggregateOutputType | null
    _avg: UserLeaveAvgAggregateOutputType | null
    _sum: UserLeaveSumAggregateOutputType | null
    _min: UserLeaveMinAggregateOutputType | null
    _max: UserLeaveMaxAggregateOutputType | null
  }

  export type UserLeaveAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    approvedById: number | null
  }

  export type UserLeaveSumAggregateOutputType = {
    id: number | null
    userId: number | null
    approvedById: number | null
  }

  export type UserLeaveMinAggregateOutputType = {
    id: number | null
    userId: number | null
    leaveType: $Enums.LeaveType | null
    fromDate: Date | null
    toDate: Date | null
    duration: $Enums.LeaveDuration | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    approvedById: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserLeaveMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    leaveType: $Enums.LeaveType | null
    fromDate: Date | null
    toDate: Date | null
    duration: $Enums.LeaveDuration | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    approvedById: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserLeaveCountAggregateOutputType = {
    id: number
    userId: number
    leaveType: number
    fromDate: number
    toDate: number
    duration: number
    reason: number
    status: number
    approvedById: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserLeaveAvgAggregateInputType = {
    id?: true
    userId?: true
    approvedById?: true
  }

  export type UserLeaveSumAggregateInputType = {
    id?: true
    userId?: true
    approvedById?: true
  }

  export type UserLeaveMinAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    fromDate?: true
    toDate?: true
    duration?: true
    reason?: true
    status?: true
    approvedById?: true
    created_at?: true
    updated_at?: true
  }

  export type UserLeaveMaxAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    fromDate?: true
    toDate?: true
    duration?: true
    reason?: true
    status?: true
    approvedById?: true
    created_at?: true
    updated_at?: true
  }

  export type UserLeaveCountAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    fromDate?: true
    toDate?: true
    duration?: true
    reason?: true
    status?: true
    approvedById?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserLeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLeave to aggregate.
     */
    where?: UserLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLeaves to fetch.
     */
    orderBy?: UserLeaveOrderByWithRelationInput | UserLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLeaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLeaves
    **/
    _count?: true | UserLeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLeaveMaxAggregateInputType
  }

  export type GetUserLeaveAggregateType<T extends UserLeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLeave[P]>
      : GetScalarType<T[P], AggregateUserLeave[P]>
  }




  export type UserLeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLeaveWhereInput
    orderBy?: UserLeaveOrderByWithAggregationInput | UserLeaveOrderByWithAggregationInput[]
    by: UserLeaveScalarFieldEnum[] | UserLeaveScalarFieldEnum
    having?: UserLeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLeaveCountAggregateInputType | true
    _avg?: UserLeaveAvgAggregateInputType
    _sum?: UserLeaveSumAggregateInputType
    _min?: UserLeaveMinAggregateInputType
    _max?: UserLeaveMaxAggregateInputType
  }

  export type UserLeaveGroupByOutputType = {
    id: number
    userId: number
    leaveType: $Enums.LeaveType
    fromDate: Date
    toDate: Date
    duration: $Enums.LeaveDuration
    reason: string
    status: $Enums.LeaveStatus
    approvedById: number | null
    created_at: Date
    updated_at: Date
    _count: UserLeaveCountAggregateOutputType | null
    _avg: UserLeaveAvgAggregateOutputType | null
    _sum: UserLeaveSumAggregateOutputType | null
    _min: UserLeaveMinAggregateOutputType | null
    _max: UserLeaveMaxAggregateOutputType | null
  }

  type GetUserLeaveGroupByPayload<T extends UserLeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLeaveGroupByOutputType[P]>
            : GetScalarType<T[P], UserLeaveGroupByOutputType[P]>
        }
      >
    >


  export type UserLeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    fromDate?: boolean
    toDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserLeave$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["userLeave"]>

  export type UserLeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    fromDate?: boolean
    toDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserLeave$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["userLeave"]>

  export type UserLeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    fromDate?: boolean
    toDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserLeave$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["userLeave"]>

  export type UserLeaveSelectScalar = {
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    fromDate?: boolean
    toDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserLeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "leaveType" | "fromDate" | "toDate" | "duration" | "reason" | "status" | "approvedById" | "created_at" | "updated_at", ExtArgs["result"]["userLeave"]>
  export type UserLeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserLeave$approvedByArgs<ExtArgs>
  }
  export type UserLeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserLeave$approvedByArgs<ExtArgs>
  }
  export type UserLeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserLeave$approvedByArgs<ExtArgs>
  }

  export type $UserLeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLeave"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      approvedBy: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      leaveType: $Enums.LeaveType
      fromDate: Date
      toDate: Date
      duration: $Enums.LeaveDuration
      reason: string
      status: $Enums.LeaveStatus
      approvedById: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["userLeave"]>
    composites: {}
  }

  type UserLeaveGetPayload<S extends boolean | null | undefined | UserLeaveDefaultArgs> = $Result.GetResult<Prisma.$UserLeavePayload, S>

  type UserLeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLeaveCountAggregateInputType | true
    }

  export interface UserLeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLeave'], meta: { name: 'UserLeave' } }
    /**
     * Find zero or one UserLeave that matches the filter.
     * @param {UserLeaveFindUniqueArgs} args - Arguments to find a UserLeave
     * @example
     * // Get one UserLeave
     * const userLeave = await prisma.userLeave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLeaveFindUniqueArgs>(args: SelectSubset<T, UserLeaveFindUniqueArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLeave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLeaveFindUniqueOrThrowArgs} args - Arguments to find a UserLeave
     * @example
     * // Get one UserLeave
     * const userLeave = await prisma.userLeave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLeave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveFindFirstArgs} args - Arguments to find a UserLeave
     * @example
     * // Get one UserLeave
     * const userLeave = await prisma.userLeave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLeaveFindFirstArgs>(args?: SelectSubset<T, UserLeaveFindFirstArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLeave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveFindFirstOrThrowArgs} args - Arguments to find a UserLeave
     * @example
     * // Get one UserLeave
     * const userLeave = await prisma.userLeave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLeaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLeaves
     * const userLeaves = await prisma.userLeave.findMany()
     * 
     * // Get first 10 UserLeaves
     * const userLeaves = await prisma.userLeave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLeaveWithIdOnly = await prisma.userLeave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLeaveFindManyArgs>(args?: SelectSubset<T, UserLeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLeave.
     * @param {UserLeaveCreateArgs} args - Arguments to create a UserLeave.
     * @example
     * // Create one UserLeave
     * const UserLeave = await prisma.userLeave.create({
     *   data: {
     *     // ... data to create a UserLeave
     *   }
     * })
     * 
     */
    create<T extends UserLeaveCreateArgs>(args: SelectSubset<T, UserLeaveCreateArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLeaves.
     * @param {UserLeaveCreateManyArgs} args - Arguments to create many UserLeaves.
     * @example
     * // Create many UserLeaves
     * const userLeave = await prisma.userLeave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLeaveCreateManyArgs>(args?: SelectSubset<T, UserLeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLeaves and returns the data saved in the database.
     * @param {UserLeaveCreateManyAndReturnArgs} args - Arguments to create many UserLeaves.
     * @example
     * // Create many UserLeaves
     * const userLeave = await prisma.userLeave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLeaves and only return the `id`
     * const userLeaveWithIdOnly = await prisma.userLeave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLeave.
     * @param {UserLeaveDeleteArgs} args - Arguments to delete one UserLeave.
     * @example
     * // Delete one UserLeave
     * const UserLeave = await prisma.userLeave.delete({
     *   where: {
     *     // ... filter to delete one UserLeave
     *   }
     * })
     * 
     */
    delete<T extends UserLeaveDeleteArgs>(args: SelectSubset<T, UserLeaveDeleteArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLeave.
     * @param {UserLeaveUpdateArgs} args - Arguments to update one UserLeave.
     * @example
     * // Update one UserLeave
     * const userLeave = await prisma.userLeave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLeaveUpdateArgs>(args: SelectSubset<T, UserLeaveUpdateArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLeaves.
     * @param {UserLeaveDeleteManyArgs} args - Arguments to filter UserLeaves to delete.
     * @example
     * // Delete a few UserLeaves
     * const { count } = await prisma.userLeave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLeaveDeleteManyArgs>(args?: SelectSubset<T, UserLeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLeaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLeaves
     * const userLeave = await prisma.userLeave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLeaveUpdateManyArgs>(args: SelectSubset<T, UserLeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLeaves and returns the data updated in the database.
     * @param {UserLeaveUpdateManyAndReturnArgs} args - Arguments to update many UserLeaves.
     * @example
     * // Update many UserLeaves
     * const userLeave = await prisma.userLeave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLeaves and only return the `id`
     * const userLeaveWithIdOnly = await prisma.userLeave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLeave.
     * @param {UserLeaveUpsertArgs} args - Arguments to update or create a UserLeave.
     * @example
     * // Update or create a UserLeave
     * const userLeave = await prisma.userLeave.upsert({
     *   create: {
     *     // ... data to create a UserLeave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLeave we want to update
     *   }
     * })
     */
    upsert<T extends UserLeaveUpsertArgs>(args: SelectSubset<T, UserLeaveUpsertArgs<ExtArgs>>): Prisma__UserLeaveClient<$Result.GetResult<Prisma.$UserLeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLeaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveCountArgs} args - Arguments to filter UserLeaves to count.
     * @example
     * // Count the number of UserLeaves
     * const count = await prisma.userLeave.count({
     *   where: {
     *     // ... the filter for the UserLeaves we want to count
     *   }
     * })
    **/
    count<T extends UserLeaveCountArgs>(
      args?: Subset<T, UserLeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLeave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLeaveAggregateArgs>(args: Subset<T, UserLeaveAggregateArgs>): Prisma.PrismaPromise<GetUserLeaveAggregateType<T>>

    /**
     * Group by UserLeave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLeaveGroupByArgs['orderBy'] }
        : { orderBy?: UserLeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLeave model
   */
  readonly fields: UserLeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLeave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends UserLeave$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, UserLeave$approvedByArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLeave model
   */
  interface UserLeaveFieldRefs {
    readonly id: FieldRef<"UserLeave", 'Int'>
    readonly userId: FieldRef<"UserLeave", 'Int'>
    readonly leaveType: FieldRef<"UserLeave", 'LeaveType'>
    readonly fromDate: FieldRef<"UserLeave", 'DateTime'>
    readonly toDate: FieldRef<"UserLeave", 'DateTime'>
    readonly duration: FieldRef<"UserLeave", 'LeaveDuration'>
    readonly reason: FieldRef<"UserLeave", 'String'>
    readonly status: FieldRef<"UserLeave", 'LeaveStatus'>
    readonly approvedById: FieldRef<"UserLeave", 'Int'>
    readonly created_at: FieldRef<"UserLeave", 'DateTime'>
    readonly updated_at: FieldRef<"UserLeave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLeave findUnique
   */
  export type UserLeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * Filter, which UserLeave to fetch.
     */
    where: UserLeaveWhereUniqueInput
  }

  /**
   * UserLeave findUniqueOrThrow
   */
  export type UserLeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * Filter, which UserLeave to fetch.
     */
    where: UserLeaveWhereUniqueInput
  }

  /**
   * UserLeave findFirst
   */
  export type UserLeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * Filter, which UserLeave to fetch.
     */
    where?: UserLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLeaves to fetch.
     */
    orderBy?: UserLeaveOrderByWithRelationInput | UserLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLeaves.
     */
    cursor?: UserLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLeaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLeaves.
     */
    distinct?: UserLeaveScalarFieldEnum | UserLeaveScalarFieldEnum[]
  }

  /**
   * UserLeave findFirstOrThrow
   */
  export type UserLeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * Filter, which UserLeave to fetch.
     */
    where?: UserLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLeaves to fetch.
     */
    orderBy?: UserLeaveOrderByWithRelationInput | UserLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLeaves.
     */
    cursor?: UserLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLeaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLeaves.
     */
    distinct?: UserLeaveScalarFieldEnum | UserLeaveScalarFieldEnum[]
  }

  /**
   * UserLeave findMany
   */
  export type UserLeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * Filter, which UserLeaves to fetch.
     */
    where?: UserLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLeaves to fetch.
     */
    orderBy?: UserLeaveOrderByWithRelationInput | UserLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLeaves.
     */
    cursor?: UserLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLeaves.
     */
    skip?: number
    distinct?: UserLeaveScalarFieldEnum | UserLeaveScalarFieldEnum[]
  }

  /**
   * UserLeave create
   */
  export type UserLeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLeave.
     */
    data: XOR<UserLeaveCreateInput, UserLeaveUncheckedCreateInput>
  }

  /**
   * UserLeave createMany
   */
  export type UserLeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLeaves.
     */
    data: UserLeaveCreateManyInput | UserLeaveCreateManyInput[]
  }

  /**
   * UserLeave createManyAndReturn
   */
  export type UserLeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * The data used to create many UserLeaves.
     */
    data: UserLeaveCreateManyInput | UserLeaveCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLeave update
   */
  export type UserLeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLeave.
     */
    data: XOR<UserLeaveUpdateInput, UserLeaveUncheckedUpdateInput>
    /**
     * Choose, which UserLeave to update.
     */
    where: UserLeaveWhereUniqueInput
  }

  /**
   * UserLeave updateMany
   */
  export type UserLeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLeaves.
     */
    data: XOR<UserLeaveUpdateManyMutationInput, UserLeaveUncheckedUpdateManyInput>
    /**
     * Filter which UserLeaves to update
     */
    where?: UserLeaveWhereInput
    /**
     * Limit how many UserLeaves to update.
     */
    limit?: number
  }

  /**
   * UserLeave updateManyAndReturn
   */
  export type UserLeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * The data used to update UserLeaves.
     */
    data: XOR<UserLeaveUpdateManyMutationInput, UserLeaveUncheckedUpdateManyInput>
    /**
     * Filter which UserLeaves to update
     */
    where?: UserLeaveWhereInput
    /**
     * Limit how many UserLeaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLeave upsert
   */
  export type UserLeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLeave to update in case it exists.
     */
    where: UserLeaveWhereUniqueInput
    /**
     * In case the UserLeave found by the `where` argument doesn't exist, create a new UserLeave with this data.
     */
    create: XOR<UserLeaveCreateInput, UserLeaveUncheckedCreateInput>
    /**
     * In case the UserLeave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLeaveUpdateInput, UserLeaveUncheckedUpdateInput>
  }

  /**
   * UserLeave delete
   */
  export type UserLeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
    /**
     * Filter which UserLeave to delete.
     */
    where: UserLeaveWhereUniqueInput
  }

  /**
   * UserLeave deleteMany
   */
  export type UserLeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLeaves to delete
     */
    where?: UserLeaveWhereInput
    /**
     * Limit how many UserLeaves to delete.
     */
    limit?: number
  }

  /**
   * UserLeave.approvedBy
   */
  export type UserLeave$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * UserLeave without action
   */
  export type UserLeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLeave
     */
    select?: UserLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLeave
     */
    omit?: UserLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLeaveInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    taskId: number | null
    breakId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    taskId: number | null
    breakId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    type: $Enums.SessionType | null
    startTime: Date | null
    latestLogged: Date | null
    endTime: Date | null
    userId: number | null
    taskId: number | null
    breakId: number | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.SessionType | null
    startTime: Date | null
    latestLogged: Date | null
    endTime: Date | null
    userId: number | null
    taskId: number | null
    breakId: number | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    type: number
    startTime: number
    latestLogged: number
    endTime: number
    userId: number
    taskId: number
    breakId: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    breakId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    breakId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    type?: true
    startTime?: true
    latestLogged?: true
    endTime?: true
    userId?: true
    taskId?: true
    breakId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    type?: true
    startTime?: true
    latestLogged?: true
    endTime?: true
    userId?: true
    taskId?: true
    breakId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    type?: true
    startTime?: true
    latestLogged?: true
    endTime?: true
    userId?: true
    taskId?: true
    breakId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    type: $Enums.SessionType
    startTime: Date
    latestLogged: Date
    endTime: Date | null
    userId: number
    taskId: number | null
    breakId: number | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    startTime?: boolean
    latestLogged?: boolean
    endTime?: boolean
    userId?: boolean
    taskId?: boolean
    breakId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | Session$taskArgs<ExtArgs>
    break?: boolean | Session$breakArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    startTime?: boolean
    latestLogged?: boolean
    endTime?: boolean
    userId?: boolean
    taskId?: boolean
    breakId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | Session$taskArgs<ExtArgs>
    break?: boolean | Session$breakArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    startTime?: boolean
    latestLogged?: boolean
    endTime?: boolean
    userId?: boolean
    taskId?: boolean
    breakId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | Session$taskArgs<ExtArgs>
    break?: boolean | Session$breakArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    type?: boolean
    startTime?: boolean
    latestLogged?: boolean
    endTime?: boolean
    userId?: boolean
    taskId?: boolean
    breakId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "startTime" | "latestLogged" | "endTime" | "userId" | "taskId" | "breakId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | Session$taskArgs<ExtArgs>
    break?: boolean | Session$breakArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | Session$taskArgs<ExtArgs>
    break?: boolean | Session$breakArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | Session$taskArgs<ExtArgs>
    break?: boolean | Session$breakArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      task: Prisma.$UserTaskPayload<ExtArgs> | null
      break: Prisma.$UserBreakPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.SessionType
      startTime: Date
      latestLogged: Date
      endTime: Date | null
      userId: number
      taskId: number | null
      breakId: number | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends Session$taskArgs<ExtArgs> = {}>(args?: Subset<T, Session$taskArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    break<T extends Session$breakArgs<ExtArgs> = {}>(args?: Subset<T, Session$breakArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly type: FieldRef<"Session", 'SessionType'>
    readonly startTime: FieldRef<"Session", 'DateTime'>
    readonly latestLogged: FieldRef<"Session", 'DateTime'>
    readonly endTime: FieldRef<"Session", 'DateTime'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly taskId: FieldRef<"Session", 'Int'>
    readonly breakId: FieldRef<"Session", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.task
   */
  export type Session$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    where?: UserTaskWhereInput
  }

  /**
   * Session.break
   */
  export type Session$breakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    where?: UserBreakWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model UserTask
   */

  export type AggregateUserTask = {
    _count: UserTaskCountAggregateOutputType | null
    _avg: UserTaskAvgAggregateOutputType | null
    _sum: UserTaskSumAggregateOutputType | null
    _min: UserTaskMinAggregateOutputType | null
    _max: UserTaskMaxAggregateOutputType | null
  }

  export type UserTaskAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    taskId: number | null
    totalTime: number | null
    assignedById: number | null
  }

  export type UserTaskSumAggregateOutputType = {
    id: number | null
    userId: number | null
    taskId: number | null
    totalTime: number | null
    assignedById: number | null
  }

  export type UserTaskMinAggregateOutputType = {
    id: number | null
    userId: number | null
    taskId: number | null
    totalTime: number | null
    assignedById: number | null
  }

  export type UserTaskMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    taskId: number | null
    totalTime: number | null
    assignedById: number | null
  }

  export type UserTaskCountAggregateOutputType = {
    id: number
    userId: number
    taskId: number
    totalTime: number
    assignedById: number
    _all: number
  }


  export type UserTaskAvgAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    totalTime?: true
    assignedById?: true
  }

  export type UserTaskSumAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    totalTime?: true
    assignedById?: true
  }

  export type UserTaskMinAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    totalTime?: true
    assignedById?: true
  }

  export type UserTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    totalTime?: true
    assignedById?: true
  }

  export type UserTaskCountAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    totalTime?: true
    assignedById?: true
    _all?: true
  }

  export type UserTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTask to aggregate.
     */
    where?: UserTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTasks to fetch.
     */
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTasks
    **/
    _count?: true | UserTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTaskMaxAggregateInputType
  }

  export type GetUserTaskAggregateType<T extends UserTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTask[P]>
      : GetScalarType<T[P], AggregateUserTask[P]>
  }




  export type UserTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskWhereInput
    orderBy?: UserTaskOrderByWithAggregationInput | UserTaskOrderByWithAggregationInput[]
    by: UserTaskScalarFieldEnum[] | UserTaskScalarFieldEnum
    having?: UserTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTaskCountAggregateInputType | true
    _avg?: UserTaskAvgAggregateInputType
    _sum?: UserTaskSumAggregateInputType
    _min?: UserTaskMinAggregateInputType
    _max?: UserTaskMaxAggregateInputType
  }

  export type UserTaskGroupByOutputType = {
    id: number
    userId: number
    taskId: number
    totalTime: number
    assignedById: number
    _count: UserTaskCountAggregateOutputType | null
    _avg: UserTaskAvgAggregateOutputType | null
    _sum: UserTaskSumAggregateOutputType | null
    _min: UserTaskMinAggregateOutputType | null
    _max: UserTaskMaxAggregateOutputType | null
  }

  type GetUserTaskGroupByPayload<T extends UserTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTaskGroupByOutputType[P]>
            : GetScalarType<T[P], UserTaskGroupByOutputType[P]>
        }
      >
    >


  export type UserTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    totalTime?: boolean
    assignedById?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sessions?: boolean | UserTask$sessionsArgs<ExtArgs>
    assignee?: boolean | userDefaultArgs<ExtArgs>
    _count?: boolean | UserTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTask"]>

  export type UserTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    totalTime?: boolean
    assignedById?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTask"]>

  export type UserTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    totalTime?: boolean
    assignedById?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTask"]>

  export type UserTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    taskId?: boolean
    totalTime?: boolean
    assignedById?: boolean
  }

  export type UserTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taskId" | "totalTime" | "assignedById", ExtArgs["result"]["userTask"]>
  export type UserTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sessions?: boolean | UserTask$sessionsArgs<ExtArgs>
    assignee?: boolean | userDefaultArgs<ExtArgs>
    _count?: boolean | UserTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UserTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $UserTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTask"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      assignee: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      taskId: number
      totalTime: number
      assignedById: number
    }, ExtArgs["result"]["userTask"]>
    composites: {}
  }

  type UserTaskGetPayload<S extends boolean | null | undefined | UserTaskDefaultArgs> = $Result.GetResult<Prisma.$UserTaskPayload, S>

  type UserTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTaskCountAggregateInputType | true
    }

  export interface UserTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTask'], meta: { name: 'UserTask' } }
    /**
     * Find zero or one UserTask that matches the filter.
     * @param {UserTaskFindUniqueArgs} args - Arguments to find a UserTask
     * @example
     * // Get one UserTask
     * const userTask = await prisma.userTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTaskFindUniqueArgs>(args: SelectSubset<T, UserTaskFindUniqueArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTaskFindUniqueOrThrowArgs} args - Arguments to find a UserTask
     * @example
     * // Get one UserTask
     * const userTask = await prisma.userTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskFindFirstArgs} args - Arguments to find a UserTask
     * @example
     * // Get one UserTask
     * const userTask = await prisma.userTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTaskFindFirstArgs>(args?: SelectSubset<T, UserTaskFindFirstArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskFindFirstOrThrowArgs} args - Arguments to find a UserTask
     * @example
     * // Get one UserTask
     * const userTask = await prisma.userTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTasks
     * const userTasks = await prisma.userTask.findMany()
     * 
     * // Get first 10 UserTasks
     * const userTasks = await prisma.userTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTaskWithIdOnly = await prisma.userTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTaskFindManyArgs>(args?: SelectSubset<T, UserTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTask.
     * @param {UserTaskCreateArgs} args - Arguments to create a UserTask.
     * @example
     * // Create one UserTask
     * const UserTask = await prisma.userTask.create({
     *   data: {
     *     // ... data to create a UserTask
     *   }
     * })
     * 
     */
    create<T extends UserTaskCreateArgs>(args: SelectSubset<T, UserTaskCreateArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTasks.
     * @param {UserTaskCreateManyArgs} args - Arguments to create many UserTasks.
     * @example
     * // Create many UserTasks
     * const userTask = await prisma.userTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTaskCreateManyArgs>(args?: SelectSubset<T, UserTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTasks and returns the data saved in the database.
     * @param {UserTaskCreateManyAndReturnArgs} args - Arguments to create many UserTasks.
     * @example
     * // Create many UserTasks
     * const userTask = await prisma.userTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTasks and only return the `id`
     * const userTaskWithIdOnly = await prisma.userTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTask.
     * @param {UserTaskDeleteArgs} args - Arguments to delete one UserTask.
     * @example
     * // Delete one UserTask
     * const UserTask = await prisma.userTask.delete({
     *   where: {
     *     // ... filter to delete one UserTask
     *   }
     * })
     * 
     */
    delete<T extends UserTaskDeleteArgs>(args: SelectSubset<T, UserTaskDeleteArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTask.
     * @param {UserTaskUpdateArgs} args - Arguments to update one UserTask.
     * @example
     * // Update one UserTask
     * const userTask = await prisma.userTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTaskUpdateArgs>(args: SelectSubset<T, UserTaskUpdateArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTasks.
     * @param {UserTaskDeleteManyArgs} args - Arguments to filter UserTasks to delete.
     * @example
     * // Delete a few UserTasks
     * const { count } = await prisma.userTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTaskDeleteManyArgs>(args?: SelectSubset<T, UserTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTasks
     * const userTask = await prisma.userTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTaskUpdateManyArgs>(args: SelectSubset<T, UserTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTasks and returns the data updated in the database.
     * @param {UserTaskUpdateManyAndReturnArgs} args - Arguments to update many UserTasks.
     * @example
     * // Update many UserTasks
     * const userTask = await prisma.userTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTasks and only return the `id`
     * const userTaskWithIdOnly = await prisma.userTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTask.
     * @param {UserTaskUpsertArgs} args - Arguments to update or create a UserTask.
     * @example
     * // Update or create a UserTask
     * const userTask = await prisma.userTask.upsert({
     *   create: {
     *     // ... data to create a UserTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTask we want to update
     *   }
     * })
     */
    upsert<T extends UserTaskUpsertArgs>(args: SelectSubset<T, UserTaskUpsertArgs<ExtArgs>>): Prisma__UserTaskClient<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCountArgs} args - Arguments to filter UserTasks to count.
     * @example
     * // Count the number of UserTasks
     * const count = await prisma.userTask.count({
     *   where: {
     *     // ... the filter for the UserTasks we want to count
     *   }
     * })
    **/
    count<T extends UserTaskCountArgs>(
      args?: Subset<T, UserTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTaskAggregateArgs>(args: Subset<T, UserTaskAggregateArgs>): Prisma.PrismaPromise<GetUserTaskAggregateType<T>>

    /**
     * Group by UserTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTaskGroupByArgs['orderBy'] }
        : { orderBy?: UserTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTask model
   */
  readonly fields: UserTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends UserTask$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, UserTask$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignee<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTask model
   */
  interface UserTaskFieldRefs {
    readonly id: FieldRef<"UserTask", 'Int'>
    readonly userId: FieldRef<"UserTask", 'Int'>
    readonly taskId: FieldRef<"UserTask", 'Int'>
    readonly totalTime: FieldRef<"UserTask", 'Int'>
    readonly assignedById: FieldRef<"UserTask", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserTask findUnique
   */
  export type UserTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserTask to fetch.
     */
    where: UserTaskWhereUniqueInput
  }

  /**
   * UserTask findUniqueOrThrow
   */
  export type UserTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserTask to fetch.
     */
    where: UserTaskWhereUniqueInput
  }

  /**
   * UserTask findFirst
   */
  export type UserTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserTask to fetch.
     */
    where?: UserTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTasks to fetch.
     */
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTasks.
     */
    cursor?: UserTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTasks.
     */
    distinct?: UserTaskScalarFieldEnum | UserTaskScalarFieldEnum[]
  }

  /**
   * UserTask findFirstOrThrow
   */
  export type UserTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserTask to fetch.
     */
    where?: UserTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTasks to fetch.
     */
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTasks.
     */
    cursor?: UserTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTasks.
     */
    distinct?: UserTaskScalarFieldEnum | UserTaskScalarFieldEnum[]
  }

  /**
   * UserTask findMany
   */
  export type UserTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserTasks to fetch.
     */
    where?: UserTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTasks to fetch.
     */
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTasks.
     */
    cursor?: UserTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTasks.
     */
    skip?: number
    distinct?: UserTaskScalarFieldEnum | UserTaskScalarFieldEnum[]
  }

  /**
   * UserTask create
   */
  export type UserTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTask.
     */
    data: XOR<UserTaskCreateInput, UserTaskUncheckedCreateInput>
  }

  /**
   * UserTask createMany
   */
  export type UserTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTasks.
     */
    data: UserTaskCreateManyInput | UserTaskCreateManyInput[]
  }

  /**
   * UserTask createManyAndReturn
   */
  export type UserTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * The data used to create many UserTasks.
     */
    data: UserTaskCreateManyInput | UserTaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTask update
   */
  export type UserTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTask.
     */
    data: XOR<UserTaskUpdateInput, UserTaskUncheckedUpdateInput>
    /**
     * Choose, which UserTask to update.
     */
    where: UserTaskWhereUniqueInput
  }

  /**
   * UserTask updateMany
   */
  export type UserTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTasks.
     */
    data: XOR<UserTaskUpdateManyMutationInput, UserTaskUncheckedUpdateManyInput>
    /**
     * Filter which UserTasks to update
     */
    where?: UserTaskWhereInput
    /**
     * Limit how many UserTasks to update.
     */
    limit?: number
  }

  /**
   * UserTask updateManyAndReturn
   */
  export type UserTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * The data used to update UserTasks.
     */
    data: XOR<UserTaskUpdateManyMutationInput, UserTaskUncheckedUpdateManyInput>
    /**
     * Filter which UserTasks to update
     */
    where?: UserTaskWhereInput
    /**
     * Limit how many UserTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTask upsert
   */
  export type UserTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTask to update in case it exists.
     */
    where: UserTaskWhereUniqueInput
    /**
     * In case the UserTask found by the `where` argument doesn't exist, create a new UserTask with this data.
     */
    create: XOR<UserTaskCreateInput, UserTaskUncheckedCreateInput>
    /**
     * In case the UserTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTaskUpdateInput, UserTaskUncheckedUpdateInput>
  }

  /**
   * UserTask delete
   */
  export type UserTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    /**
     * Filter which UserTask to delete.
     */
    where: UserTaskWhereUniqueInput
  }

  /**
   * UserTask deleteMany
   */
  export type UserTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTasks to delete
     */
    where?: UserTaskWhereInput
    /**
     * Limit how many UserTasks to delete.
     */
    limit?: number
  }

  /**
   * UserTask.sessions
   */
  export type UserTask$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * UserTask without action
   */
  export type UserTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
  }


  /**
   * Model UserBreak
   */

  export type AggregateUserBreak = {
    _count: UserBreakCountAggregateOutputType | null
    _avg: UserBreakAvgAggregateOutputType | null
    _sum: UserBreakSumAggregateOutputType | null
    _min: UserBreakMinAggregateOutputType | null
    _max: UserBreakMaxAggregateOutputType | null
  }

  export type UserBreakAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    breakId: number | null
    totalTime: number | null
  }

  export type UserBreakSumAggregateOutputType = {
    id: number | null
    userId: number | null
    breakId: number | null
    totalTime: number | null
  }

  export type UserBreakMinAggregateOutputType = {
    id: number | null
    userId: number | null
    breakId: number | null
    totalTime: number | null
  }

  export type UserBreakMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    breakId: number | null
    totalTime: number | null
  }

  export type UserBreakCountAggregateOutputType = {
    id: number
    userId: number
    breakId: number
    totalTime: number
    _all: number
  }


  export type UserBreakAvgAggregateInputType = {
    id?: true
    userId?: true
    breakId?: true
    totalTime?: true
  }

  export type UserBreakSumAggregateInputType = {
    id?: true
    userId?: true
    breakId?: true
    totalTime?: true
  }

  export type UserBreakMinAggregateInputType = {
    id?: true
    userId?: true
    breakId?: true
    totalTime?: true
  }

  export type UserBreakMaxAggregateInputType = {
    id?: true
    userId?: true
    breakId?: true
    totalTime?: true
  }

  export type UserBreakCountAggregateInputType = {
    id?: true
    userId?: true
    breakId?: true
    totalTime?: true
    _all?: true
  }

  export type UserBreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBreak to aggregate.
     */
    where?: UserBreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreaks to fetch.
     */
    orderBy?: UserBreakOrderByWithRelationInput | UserBreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBreaks
    **/
    _count?: true | UserBreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBreakMaxAggregateInputType
  }

  export type GetUserBreakAggregateType<T extends UserBreakAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBreak[P]>
      : GetScalarType<T[P], AggregateUserBreak[P]>
  }




  export type UserBreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBreakWhereInput
    orderBy?: UserBreakOrderByWithAggregationInput | UserBreakOrderByWithAggregationInput[]
    by: UserBreakScalarFieldEnum[] | UserBreakScalarFieldEnum
    having?: UserBreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBreakCountAggregateInputType | true
    _avg?: UserBreakAvgAggregateInputType
    _sum?: UserBreakSumAggregateInputType
    _min?: UserBreakMinAggregateInputType
    _max?: UserBreakMaxAggregateInputType
  }

  export type UserBreakGroupByOutputType = {
    id: number
    userId: number
    breakId: number
    totalTime: number
    _count: UserBreakCountAggregateOutputType | null
    _avg: UserBreakAvgAggregateOutputType | null
    _sum: UserBreakSumAggregateOutputType | null
    _min: UserBreakMinAggregateOutputType | null
    _max: UserBreakMaxAggregateOutputType | null
  }

  type GetUserBreakGroupByPayload<T extends UserBreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBreakGroupByOutputType[P]>
            : GetScalarType<T[P], UserBreakGroupByOutputType[P]>
        }
      >
    >


  export type UserBreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    breakId?: boolean
    totalTime?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    break?: boolean | BreakDefaultArgs<ExtArgs>
    sessions?: boolean | UserBreak$sessionsArgs<ExtArgs>
    _count?: boolean | UserBreakCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBreak"]>

  export type UserBreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    breakId?: boolean
    totalTime?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    break?: boolean | BreakDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBreak"]>

  export type UserBreakSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    breakId?: boolean
    totalTime?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    break?: boolean | BreakDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBreak"]>

  export type UserBreakSelectScalar = {
    id?: boolean
    userId?: boolean
    breakId?: boolean
    totalTime?: boolean
  }

  export type UserBreakOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "breakId" | "totalTime", ExtArgs["result"]["userBreak"]>
  export type UserBreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    break?: boolean | BreakDefaultArgs<ExtArgs>
    sessions?: boolean | UserBreak$sessionsArgs<ExtArgs>
    _count?: boolean | UserBreakCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserBreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    break?: boolean | BreakDefaultArgs<ExtArgs>
  }
  export type UserBreakIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    break?: boolean | BreakDefaultArgs<ExtArgs>
  }

  export type $UserBreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBreak"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      break: Prisma.$BreakPayload<ExtArgs>
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      breakId: number
      totalTime: number
    }, ExtArgs["result"]["userBreak"]>
    composites: {}
  }

  type UserBreakGetPayload<S extends boolean | null | undefined | UserBreakDefaultArgs> = $Result.GetResult<Prisma.$UserBreakPayload, S>

  type UserBreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBreakFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBreakCountAggregateInputType | true
    }

  export interface UserBreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBreak'], meta: { name: 'UserBreak' } }
    /**
     * Find zero or one UserBreak that matches the filter.
     * @param {UserBreakFindUniqueArgs} args - Arguments to find a UserBreak
     * @example
     * // Get one UserBreak
     * const userBreak = await prisma.userBreak.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBreakFindUniqueArgs>(args: SelectSubset<T, UserBreakFindUniqueArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBreak that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBreakFindUniqueOrThrowArgs} args - Arguments to find a UserBreak
     * @example
     * // Get one UserBreak
     * const userBreak = await prisma.userBreak.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBreakFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBreak that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakFindFirstArgs} args - Arguments to find a UserBreak
     * @example
     * // Get one UserBreak
     * const userBreak = await prisma.userBreak.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBreakFindFirstArgs>(args?: SelectSubset<T, UserBreakFindFirstArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBreak that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakFindFirstOrThrowArgs} args - Arguments to find a UserBreak
     * @example
     * // Get one UserBreak
     * const userBreak = await prisma.userBreak.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBreakFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBreaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBreaks
     * const userBreaks = await prisma.userBreak.findMany()
     * 
     * // Get first 10 UserBreaks
     * const userBreaks = await prisma.userBreak.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBreakWithIdOnly = await prisma.userBreak.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBreakFindManyArgs>(args?: SelectSubset<T, UserBreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBreak.
     * @param {UserBreakCreateArgs} args - Arguments to create a UserBreak.
     * @example
     * // Create one UserBreak
     * const UserBreak = await prisma.userBreak.create({
     *   data: {
     *     // ... data to create a UserBreak
     *   }
     * })
     * 
     */
    create<T extends UserBreakCreateArgs>(args: SelectSubset<T, UserBreakCreateArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBreaks.
     * @param {UserBreakCreateManyArgs} args - Arguments to create many UserBreaks.
     * @example
     * // Create many UserBreaks
     * const userBreak = await prisma.userBreak.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBreakCreateManyArgs>(args?: SelectSubset<T, UserBreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBreaks and returns the data saved in the database.
     * @param {UserBreakCreateManyAndReturnArgs} args - Arguments to create many UserBreaks.
     * @example
     * // Create many UserBreaks
     * const userBreak = await prisma.userBreak.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBreaks and only return the `id`
     * const userBreakWithIdOnly = await prisma.userBreak.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBreakCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBreak.
     * @param {UserBreakDeleteArgs} args - Arguments to delete one UserBreak.
     * @example
     * // Delete one UserBreak
     * const UserBreak = await prisma.userBreak.delete({
     *   where: {
     *     // ... filter to delete one UserBreak
     *   }
     * })
     * 
     */
    delete<T extends UserBreakDeleteArgs>(args: SelectSubset<T, UserBreakDeleteArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBreak.
     * @param {UserBreakUpdateArgs} args - Arguments to update one UserBreak.
     * @example
     * // Update one UserBreak
     * const userBreak = await prisma.userBreak.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBreakUpdateArgs>(args: SelectSubset<T, UserBreakUpdateArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBreaks.
     * @param {UserBreakDeleteManyArgs} args - Arguments to filter UserBreaks to delete.
     * @example
     * // Delete a few UserBreaks
     * const { count } = await prisma.userBreak.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBreakDeleteManyArgs>(args?: SelectSubset<T, UserBreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBreaks
     * const userBreak = await prisma.userBreak.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBreakUpdateManyArgs>(args: SelectSubset<T, UserBreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBreaks and returns the data updated in the database.
     * @param {UserBreakUpdateManyAndReturnArgs} args - Arguments to update many UserBreaks.
     * @example
     * // Update many UserBreaks
     * const userBreak = await prisma.userBreak.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBreaks and only return the `id`
     * const userBreakWithIdOnly = await prisma.userBreak.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBreakUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBreakUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBreak.
     * @param {UserBreakUpsertArgs} args - Arguments to update or create a UserBreak.
     * @example
     * // Update or create a UserBreak
     * const userBreak = await prisma.userBreak.upsert({
     *   create: {
     *     // ... data to create a UserBreak
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBreak we want to update
     *   }
     * })
     */
    upsert<T extends UserBreakUpsertArgs>(args: SelectSubset<T, UserBreakUpsertArgs<ExtArgs>>): Prisma__UserBreakClient<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakCountArgs} args - Arguments to filter UserBreaks to count.
     * @example
     * // Count the number of UserBreaks
     * const count = await prisma.userBreak.count({
     *   where: {
     *     // ... the filter for the UserBreaks we want to count
     *   }
     * })
    **/
    count<T extends UserBreakCountArgs>(
      args?: Subset<T, UserBreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBreakAggregateArgs>(args: Subset<T, UserBreakAggregateArgs>): Prisma.PrismaPromise<GetUserBreakAggregateType<T>>

    /**
     * Group by UserBreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBreakGroupByArgs['orderBy'] }
        : { orderBy?: UserBreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBreak model
   */
  readonly fields: UserBreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBreak.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    break<T extends BreakDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BreakDefaultArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends UserBreak$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, UserBreak$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBreak model
   */
  interface UserBreakFieldRefs {
    readonly id: FieldRef<"UserBreak", 'Int'>
    readonly userId: FieldRef<"UserBreak", 'Int'>
    readonly breakId: FieldRef<"UserBreak", 'Int'>
    readonly totalTime: FieldRef<"UserBreak", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserBreak findUnique
   */
  export type UserBreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * Filter, which UserBreak to fetch.
     */
    where: UserBreakWhereUniqueInput
  }

  /**
   * UserBreak findUniqueOrThrow
   */
  export type UserBreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * Filter, which UserBreak to fetch.
     */
    where: UserBreakWhereUniqueInput
  }

  /**
   * UserBreak findFirst
   */
  export type UserBreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * Filter, which UserBreak to fetch.
     */
    where?: UserBreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreaks to fetch.
     */
    orderBy?: UserBreakOrderByWithRelationInput | UserBreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBreaks.
     */
    cursor?: UserBreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBreaks.
     */
    distinct?: UserBreakScalarFieldEnum | UserBreakScalarFieldEnum[]
  }

  /**
   * UserBreak findFirstOrThrow
   */
  export type UserBreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * Filter, which UserBreak to fetch.
     */
    where?: UserBreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreaks to fetch.
     */
    orderBy?: UserBreakOrderByWithRelationInput | UserBreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBreaks.
     */
    cursor?: UserBreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBreaks.
     */
    distinct?: UserBreakScalarFieldEnum | UserBreakScalarFieldEnum[]
  }

  /**
   * UserBreak findMany
   */
  export type UserBreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * Filter, which UserBreaks to fetch.
     */
    where?: UserBreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBreaks to fetch.
     */
    orderBy?: UserBreakOrderByWithRelationInput | UserBreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBreaks.
     */
    cursor?: UserBreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBreaks.
     */
    skip?: number
    distinct?: UserBreakScalarFieldEnum | UserBreakScalarFieldEnum[]
  }

  /**
   * UserBreak create
   */
  export type UserBreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBreak.
     */
    data: XOR<UserBreakCreateInput, UserBreakUncheckedCreateInput>
  }

  /**
   * UserBreak createMany
   */
  export type UserBreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBreaks.
     */
    data: UserBreakCreateManyInput | UserBreakCreateManyInput[]
  }

  /**
   * UserBreak createManyAndReturn
   */
  export type UserBreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * The data used to create many UserBreaks.
     */
    data: UserBreakCreateManyInput | UserBreakCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBreak update
   */
  export type UserBreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBreak.
     */
    data: XOR<UserBreakUpdateInput, UserBreakUncheckedUpdateInput>
    /**
     * Choose, which UserBreak to update.
     */
    where: UserBreakWhereUniqueInput
  }

  /**
   * UserBreak updateMany
   */
  export type UserBreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBreaks.
     */
    data: XOR<UserBreakUpdateManyMutationInput, UserBreakUncheckedUpdateManyInput>
    /**
     * Filter which UserBreaks to update
     */
    where?: UserBreakWhereInput
    /**
     * Limit how many UserBreaks to update.
     */
    limit?: number
  }

  /**
   * UserBreak updateManyAndReturn
   */
  export type UserBreakUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * The data used to update UserBreaks.
     */
    data: XOR<UserBreakUpdateManyMutationInput, UserBreakUncheckedUpdateManyInput>
    /**
     * Filter which UserBreaks to update
     */
    where?: UserBreakWhereInput
    /**
     * Limit how many UserBreaks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBreak upsert
   */
  export type UserBreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBreak to update in case it exists.
     */
    where: UserBreakWhereUniqueInput
    /**
     * In case the UserBreak found by the `where` argument doesn't exist, create a new UserBreak with this data.
     */
    create: XOR<UserBreakCreateInput, UserBreakUncheckedCreateInput>
    /**
     * In case the UserBreak was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBreakUpdateInput, UserBreakUncheckedUpdateInput>
  }

  /**
   * UserBreak delete
   */
  export type UserBreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    /**
     * Filter which UserBreak to delete.
     */
    where: UserBreakWhereUniqueInput
  }

  /**
   * UserBreak deleteMany
   */
  export type UserBreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBreaks to delete
     */
    where?: UserBreakWhereInput
    /**
     * Limit how many UserBreaks to delete.
     */
    limit?: number
  }

  /**
   * UserBreak.sessions
   */
  export type UserBreak$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * UserBreak without action
   */
  export type UserBreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    typeId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    typeId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.TaskType | null
    typeId: number | null
    status: string | null
    level: $Enums.TaskLevel | null
    remark: string | null
    reassigned: boolean | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.TaskType | null
    typeId: number | null
    status: string | null
    level: $Enums.TaskLevel | null
    remark: string | null
    reassigned: boolean | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    name: number
    type: number
    typeId: number
    status: number
    level: number
    remark: number
    reassigned: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    typeId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    typeId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    typeId?: true
    status?: true
    level?: true
    remark?: true
    reassigned?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    typeId?: true
    status?: true
    level?: true
    remark?: true
    reassigned?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    typeId?: true
    status?: true
    level?: true
    remark?: true
    reassigned?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    name: string
    type: $Enums.TaskType
    typeId: number | null
    status: string
    level: $Enums.TaskLevel
    remark: string
    reassigned: boolean
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    typeId?: boolean
    status?: boolean
    level?: boolean
    remark?: boolean
    reassigned?: boolean
    users?: boolean | Task$usersArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    typeId?: boolean
    status?: boolean
    level?: boolean
    remark?: boolean
    reassigned?: boolean
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    typeId?: boolean
    status?: boolean
    level?: boolean
    remark?: boolean
    reassigned?: boolean
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    typeId?: boolean
    status?: boolean
    level?: boolean
    remark?: boolean
    reassigned?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "typeId" | "status" | "level" | "remark" | "reassigned", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Task$usersArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      users: Prisma.$UserTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: $Enums.TaskType
      typeId: number | null
      status: string
      level: $Enums.TaskLevel
      remark: string
      reassigned: boolean
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Task$usersArgs<ExtArgs> = {}>(args?: Subset<T, Task$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly name: FieldRef<"Task", 'String'>
    readonly type: FieldRef<"Task", 'TaskType'>
    readonly typeId: FieldRef<"Task", 'Int'>
    readonly status: FieldRef<"Task", 'String'>
    readonly level: FieldRef<"Task", 'TaskLevel'>
    readonly remark: FieldRef<"Task", 'String'>
    readonly reassigned: FieldRef<"Task", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.users
   */
  export type Task$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTask
     */
    select?: UserTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTask
     */
    omit?: UserTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskInclude<ExtArgs> | null
    where?: UserTaskWhereInput
    orderBy?: UserTaskOrderByWithRelationInput | UserTaskOrderByWithRelationInput[]
    cursor?: UserTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTaskScalarFieldEnum | UserTaskScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Break
   */

  export type AggregateBreak = {
    _count: BreakCountAggregateOutputType | null
    _avg: BreakAvgAggregateOutputType | null
    _sum: BreakSumAggregateOutputType | null
    _min: BreakMinAggregateOutputType | null
    _max: BreakMaxAggregateOutputType | null
  }

  export type BreakAvgAggregateOutputType = {
    id: number | null
  }

  export type BreakSumAggregateOutputType = {
    id: number | null
  }

  export type BreakMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BreakMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BreakCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BreakAvgAggregateInputType = {
    id?: true
  }

  export type BreakSumAggregateInputType = {
    id?: true
  }

  export type BreakMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BreakMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BreakCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Break to aggregate.
     */
    where?: BreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breaks to fetch.
     */
    orderBy?: BreakOrderByWithRelationInput | BreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Breaks
    **/
    _count?: true | BreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreakMaxAggregateInputType
  }

  export type GetBreakAggregateType<T extends BreakAggregateArgs> = {
        [P in keyof T & keyof AggregateBreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreak[P]>
      : GetScalarType<T[P], AggregateBreak[P]>
  }




  export type BreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakWhereInput
    orderBy?: BreakOrderByWithAggregationInput | BreakOrderByWithAggregationInput[]
    by: BreakScalarFieldEnum[] | BreakScalarFieldEnum
    having?: BreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreakCountAggregateInputType | true
    _avg?: BreakAvgAggregateInputType
    _sum?: BreakSumAggregateInputType
    _min?: BreakMinAggregateInputType
    _max?: BreakMaxAggregateInputType
  }

  export type BreakGroupByOutputType = {
    id: number
    name: string
    _count: BreakCountAggregateOutputType | null
    _avg: BreakAvgAggregateOutputType | null
    _sum: BreakSumAggregateOutputType | null
    _min: BreakMinAggregateOutputType | null
    _max: BreakMaxAggregateOutputType | null
  }

  type GetBreakGroupByPayload<T extends BreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreakGroupByOutputType[P]>
            : GetScalarType<T[P], BreakGroupByOutputType[P]>
        }
      >
    >


  export type BreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Break$usersArgs<ExtArgs>
    _count?: boolean | BreakCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["break"]>

  export type BreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["break"]>

  export type BreakSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["break"]>

  export type BreakSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type BreakOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["break"]>
  export type BreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Break$usersArgs<ExtArgs>
    _count?: boolean | BreakCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BreakIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Break"
    objects: {
      users: Prisma.$UserBreakPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["break"]>
    composites: {}
  }

  type BreakGetPayload<S extends boolean | null | undefined | BreakDefaultArgs> = $Result.GetResult<Prisma.$BreakPayload, S>

  type BreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BreakFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BreakCountAggregateInputType | true
    }

  export interface BreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Break'], meta: { name: 'Break' } }
    /**
     * Find zero or one Break that matches the filter.
     * @param {BreakFindUniqueArgs} args - Arguments to find a Break
     * @example
     * // Get one Break
     * const break = await prisma.break.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreakFindUniqueArgs>(args: SelectSubset<T, BreakFindUniqueArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Break that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BreakFindUniqueOrThrowArgs} args - Arguments to find a Break
     * @example
     * // Get one Break
     * const break = await prisma.break.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreakFindUniqueOrThrowArgs>(args: SelectSubset<T, BreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Break that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakFindFirstArgs} args - Arguments to find a Break
     * @example
     * // Get one Break
     * const break = await prisma.break.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreakFindFirstArgs>(args?: SelectSubset<T, BreakFindFirstArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Break that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakFindFirstOrThrowArgs} args - Arguments to find a Break
     * @example
     * // Get one Break
     * const break = await prisma.break.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreakFindFirstOrThrowArgs>(args?: SelectSubset<T, BreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Breaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Breaks
     * const breaks = await prisma.break.findMany()
     * 
     * // Get first 10 Breaks
     * const breaks = await prisma.break.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breakWithIdOnly = await prisma.break.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreakFindManyArgs>(args?: SelectSubset<T, BreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Break.
     * @param {BreakCreateArgs} args - Arguments to create a Break.
     * @example
     * // Create one Break
     * const Break = await prisma.break.create({
     *   data: {
     *     // ... data to create a Break
     *   }
     * })
     * 
     */
    create<T extends BreakCreateArgs>(args: SelectSubset<T, BreakCreateArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Breaks.
     * @param {BreakCreateManyArgs} args - Arguments to create many Breaks.
     * @example
     * // Create many Breaks
     * const break = await prisma.break.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreakCreateManyArgs>(args?: SelectSubset<T, BreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Breaks and returns the data saved in the database.
     * @param {BreakCreateManyAndReturnArgs} args - Arguments to create many Breaks.
     * @example
     * // Create many Breaks
     * const break = await prisma.break.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Breaks and only return the `id`
     * const breakWithIdOnly = await prisma.break.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreakCreateManyAndReturnArgs>(args?: SelectSubset<T, BreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Break.
     * @param {BreakDeleteArgs} args - Arguments to delete one Break.
     * @example
     * // Delete one Break
     * const Break = await prisma.break.delete({
     *   where: {
     *     // ... filter to delete one Break
     *   }
     * })
     * 
     */
    delete<T extends BreakDeleteArgs>(args: SelectSubset<T, BreakDeleteArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Break.
     * @param {BreakUpdateArgs} args - Arguments to update one Break.
     * @example
     * // Update one Break
     * const break = await prisma.break.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreakUpdateArgs>(args: SelectSubset<T, BreakUpdateArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Breaks.
     * @param {BreakDeleteManyArgs} args - Arguments to filter Breaks to delete.
     * @example
     * // Delete a few Breaks
     * const { count } = await prisma.break.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreakDeleteManyArgs>(args?: SelectSubset<T, BreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Breaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Breaks
     * const break = await prisma.break.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreakUpdateManyArgs>(args: SelectSubset<T, BreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Breaks and returns the data updated in the database.
     * @param {BreakUpdateManyAndReturnArgs} args - Arguments to update many Breaks.
     * @example
     * // Update many Breaks
     * const break = await prisma.break.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Breaks and only return the `id`
     * const breakWithIdOnly = await prisma.break.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BreakUpdateManyAndReturnArgs>(args: SelectSubset<T, BreakUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Break.
     * @param {BreakUpsertArgs} args - Arguments to update or create a Break.
     * @example
     * // Update or create a Break
     * const break = await prisma.break.upsert({
     *   create: {
     *     // ... data to create a Break
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Break we want to update
     *   }
     * })
     */
    upsert<T extends BreakUpsertArgs>(args: SelectSubset<T, BreakUpsertArgs<ExtArgs>>): Prisma__BreakClient<$Result.GetResult<Prisma.$BreakPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Breaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakCountArgs} args - Arguments to filter Breaks to count.
     * @example
     * // Count the number of Breaks
     * const count = await prisma.break.count({
     *   where: {
     *     // ... the filter for the Breaks we want to count
     *   }
     * })
    **/
    count<T extends BreakCountArgs>(
      args?: Subset<T, BreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Break.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreakAggregateArgs>(args: Subset<T, BreakAggregateArgs>): Prisma.PrismaPromise<GetBreakAggregateType<T>>

    /**
     * Group by Break.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreakGroupByArgs['orderBy'] }
        : { orderBy?: BreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Break model
   */
  readonly fields: BreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Break.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Break$usersArgs<ExtArgs> = {}>(args?: Subset<T, Break$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBreakPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Break model
   */
  interface BreakFieldRefs {
    readonly id: FieldRef<"Break", 'Int'>
    readonly name: FieldRef<"Break", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Break findUnique
   */
  export type BreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * Filter, which Break to fetch.
     */
    where: BreakWhereUniqueInput
  }

  /**
   * Break findUniqueOrThrow
   */
  export type BreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * Filter, which Break to fetch.
     */
    where: BreakWhereUniqueInput
  }

  /**
   * Break findFirst
   */
  export type BreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * Filter, which Break to fetch.
     */
    where?: BreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breaks to fetch.
     */
    orderBy?: BreakOrderByWithRelationInput | BreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Breaks.
     */
    cursor?: BreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Breaks.
     */
    distinct?: BreakScalarFieldEnum | BreakScalarFieldEnum[]
  }

  /**
   * Break findFirstOrThrow
   */
  export type BreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * Filter, which Break to fetch.
     */
    where?: BreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breaks to fetch.
     */
    orderBy?: BreakOrderByWithRelationInput | BreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Breaks.
     */
    cursor?: BreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Breaks.
     */
    distinct?: BreakScalarFieldEnum | BreakScalarFieldEnum[]
  }

  /**
   * Break findMany
   */
  export type BreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * Filter, which Breaks to fetch.
     */
    where?: BreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Breaks to fetch.
     */
    orderBy?: BreakOrderByWithRelationInput | BreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Breaks.
     */
    cursor?: BreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Breaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Breaks.
     */
    skip?: number
    distinct?: BreakScalarFieldEnum | BreakScalarFieldEnum[]
  }

  /**
   * Break create
   */
  export type BreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * The data needed to create a Break.
     */
    data: XOR<BreakCreateInput, BreakUncheckedCreateInput>
  }

  /**
   * Break createMany
   */
  export type BreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Breaks.
     */
    data: BreakCreateManyInput | BreakCreateManyInput[]
  }

  /**
   * Break createManyAndReturn
   */
  export type BreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * The data used to create many Breaks.
     */
    data: BreakCreateManyInput | BreakCreateManyInput[]
  }

  /**
   * Break update
   */
  export type BreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * The data needed to update a Break.
     */
    data: XOR<BreakUpdateInput, BreakUncheckedUpdateInput>
    /**
     * Choose, which Break to update.
     */
    where: BreakWhereUniqueInput
  }

  /**
   * Break updateMany
   */
  export type BreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Breaks.
     */
    data: XOR<BreakUpdateManyMutationInput, BreakUncheckedUpdateManyInput>
    /**
     * Filter which Breaks to update
     */
    where?: BreakWhereInput
    /**
     * Limit how many Breaks to update.
     */
    limit?: number
  }

  /**
   * Break updateManyAndReturn
   */
  export type BreakUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * The data used to update Breaks.
     */
    data: XOR<BreakUpdateManyMutationInput, BreakUncheckedUpdateManyInput>
    /**
     * Filter which Breaks to update
     */
    where?: BreakWhereInput
    /**
     * Limit how many Breaks to update.
     */
    limit?: number
  }

  /**
   * Break upsert
   */
  export type BreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * The filter to search for the Break to update in case it exists.
     */
    where: BreakWhereUniqueInput
    /**
     * In case the Break found by the `where` argument doesn't exist, create a new Break with this data.
     */
    create: XOR<BreakCreateInput, BreakUncheckedCreateInput>
    /**
     * In case the Break was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreakUpdateInput, BreakUncheckedUpdateInput>
  }

  /**
   * Break delete
   */
  export type BreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
    /**
     * Filter which Break to delete.
     */
    where: BreakWhereUniqueInput
  }

  /**
   * Break deleteMany
   */
  export type BreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Breaks to delete
     */
    where?: BreakWhereInput
    /**
     * Limit how many Breaks to delete.
     */
    limit?: number
  }

  /**
   * Break.users
   */
  export type Break$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBreak
     */
    select?: UserBreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBreak
     */
    omit?: UserBreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBreakInclude<ExtArgs> | null
    where?: UserBreakWhereInput
    orderBy?: UserBreakOrderByWithRelationInput | UserBreakOrderByWithRelationInput[]
    cursor?: UserBreakWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBreakScalarFieldEnum | UserBreakScalarFieldEnum[]
  }

  /**
   * Break without action
   */
  export type BreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Break
     */
    select?: BreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Break
     */
    omit?: BreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakInclude<ExtArgs> | null
  }


  /**
   * Model message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    recipientId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    recipientId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    body: string | null
    senderId: number | null
    recipientId: number | null
    created_at: Date | null
    read_at: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    body: string | null
    senderId: number | null
    recipientId: number | null
    created_at: Date | null
    read_at: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    body: number
    senderId: number
    recipientId: number
    created_at: number
    read_at: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    body?: true
    senderId?: true
    recipientId?: true
    created_at?: true
    read_at?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    body?: true
    senderId?: true
    recipientId?: true
    created_at?: true
    read_at?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    body?: true
    senderId?: true
    recipientId?: true
    created_at?: true
    read_at?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: messageOrderByWithAggregationInput | messageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    body: string
    senderId: number
    recipientId: number
    created_at: Date
    read_at: Date | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    senderId?: boolean
    recipientId?: boolean
    created_at?: boolean
    read_at?: boolean
    sender?: boolean | userDefaultArgs<ExtArgs>
    recipient?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    senderId?: boolean
    recipientId?: boolean
    created_at?: boolean
    read_at?: boolean
    sender?: boolean | userDefaultArgs<ExtArgs>
    recipient?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    senderId?: boolean
    recipientId?: boolean
    created_at?: boolean
    read_at?: boolean
    sender?: boolean | userDefaultArgs<ExtArgs>
    recipient?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectScalar = {
    id?: boolean
    body?: boolean
    senderId?: boolean
    recipientId?: boolean
    created_at?: boolean
    read_at?: boolean
  }

  export type messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "body" | "senderId" | "recipientId" | "created_at" | "read_at", ExtArgs["result"]["message"]>
  export type messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | userDefaultArgs<ExtArgs>
    recipient?: boolean | userDefaultArgs<ExtArgs>
  }
  export type messageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | userDefaultArgs<ExtArgs>
    recipient?: boolean | userDefaultArgs<ExtArgs>
  }
  export type messageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | userDefaultArgs<ExtArgs>
    recipient?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message"
    objects: {
      sender: Prisma.$userPayload<ExtArgs>
      recipient: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      body: string
      senderId: number
      recipientId: number
      created_at: Date
      read_at: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type messageGetPayload<S extends boolean | null | undefined | messageDefaultArgs> = $Result.GetResult<Prisma.$messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messageFindUniqueArgs>(args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs>(args: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messageFindFirstArgs>(args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs>(args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messageFindManyArgs>(args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends messageCreateArgs>(args: SelectSubset<T, messageCreateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messageCreateManyArgs>(args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messageCreateManyAndReturnArgs>(args?: SelectSubset<T, messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends messageDeleteArgs>(args: SelectSubset<T, messageDeleteArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messageUpdateArgs>(args: SelectSubset<T, messageUpdateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messageDeleteManyArgs>(args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messageUpdateManyArgs>(args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messageUpdateManyAndReturnArgs>(args: SelectSubset<T, messageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends messageUpsertArgs>(args: SelectSubset<T, messageUpsertArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageGroupByArgs['orderBy'] }
        : { orderBy?: messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message model
   */
  readonly fields: messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message model
   */
  interface messageFieldRefs {
    readonly id: FieldRef<"message", 'Int'>
    readonly body: FieldRef<"message", 'String'>
    readonly senderId: FieldRef<"message", 'Int'>
    readonly recipientId: FieldRef<"message", 'Int'>
    readonly created_at: FieldRef<"message", 'DateTime'>
    readonly read_at: FieldRef<"message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * message findUnique
   */
  export type messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findFirst
   */
  export type messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data: XOR<messageCreateInput, messageUncheckedCreateInput>
  }

  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
  }

  /**
   * message createManyAndReturn
   */
  export type messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * message updateManyAndReturn
   */
  export type messageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }

  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * message without action
   */
  export type messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
  }


  /**
   * Model groupMessage
   */

  export type AggregateGroupMessage = {
    _count: GroupMessageCountAggregateOutputType | null
    _avg: GroupMessageAvgAggregateOutputType | null
    _sum: GroupMessageSumAggregateOutputType | null
    _min: GroupMessageMinAggregateOutputType | null
    _max: GroupMessageMaxAggregateOutputType | null
  }

  export type GroupMessageAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    senderId: number | null
  }

  export type GroupMessageSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    senderId: number | null
  }

  export type GroupMessageMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    body: string | null
    senderId: number | null
    created_at: Date | null
    read_at: Date | null
  }

  export type GroupMessageMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    body: string | null
    senderId: number | null
    created_at: Date | null
    read_at: Date | null
  }

  export type GroupMessageCountAggregateOutputType = {
    id: number
    groupId: number
    body: number
    senderId: number
    created_at: number
    read_at: number
    _all: number
  }


  export type GroupMessageAvgAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
  }

  export type GroupMessageSumAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
  }

  export type GroupMessageMinAggregateInputType = {
    id?: true
    groupId?: true
    body?: true
    senderId?: true
    created_at?: true
    read_at?: true
  }

  export type GroupMessageMaxAggregateInputType = {
    id?: true
    groupId?: true
    body?: true
    senderId?: true
    created_at?: true
    read_at?: true
  }

  export type GroupMessageCountAggregateInputType = {
    id?: true
    groupId?: true
    body?: true
    senderId?: true
    created_at?: true
    read_at?: true
    _all?: true
  }

  export type GroupMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupMessage to aggregate.
     */
    where?: groupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupMessages to fetch.
     */
    orderBy?: groupMessageOrderByWithRelationInput | groupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groupMessages
    **/
    _count?: true | GroupMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMessageMaxAggregateInputType
  }

  export type GetGroupMessageAggregateType<T extends GroupMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMessage[P]>
      : GetScalarType<T[P], AggregateGroupMessage[P]>
  }




  export type groupMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupMessageWhereInput
    orderBy?: groupMessageOrderByWithAggregationInput | groupMessageOrderByWithAggregationInput[]
    by: GroupMessageScalarFieldEnum[] | GroupMessageScalarFieldEnum
    having?: groupMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMessageCountAggregateInputType | true
    _avg?: GroupMessageAvgAggregateInputType
    _sum?: GroupMessageSumAggregateInputType
    _min?: GroupMessageMinAggregateInputType
    _max?: GroupMessageMaxAggregateInputType
  }

  export type GroupMessageGroupByOutputType = {
    id: number
    groupId: number
    body: string
    senderId: number
    created_at: Date
    read_at: Date | null
    _count: GroupMessageCountAggregateOutputType | null
    _avg: GroupMessageAvgAggregateOutputType | null
    _sum: GroupMessageSumAggregateOutputType | null
    _min: GroupMessageMinAggregateOutputType | null
    _max: GroupMessageMaxAggregateOutputType | null
  }

  type GetGroupMessageGroupByPayload<T extends groupMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMessageGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMessageGroupByOutputType[P]>
        }
      >
    >


  export type groupMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    body?: boolean
    senderId?: boolean
    created_at?: boolean
    read_at?: boolean
    group?: boolean | groupDefaultArgs<ExtArgs>
    sender?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessage"]>

  export type groupMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    body?: boolean
    senderId?: boolean
    created_at?: boolean
    read_at?: boolean
    group?: boolean | groupDefaultArgs<ExtArgs>
    sender?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessage"]>

  export type groupMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    body?: boolean
    senderId?: boolean
    created_at?: boolean
    read_at?: boolean
    group?: boolean | groupDefaultArgs<ExtArgs>
    sender?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessage"]>

  export type groupMessageSelectScalar = {
    id?: boolean
    groupId?: boolean
    body?: boolean
    senderId?: boolean
    created_at?: boolean
    read_at?: boolean
  }

  export type groupMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "body" | "senderId" | "created_at" | "read_at", ExtArgs["result"]["groupMessage"]>
  export type groupMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | groupDefaultArgs<ExtArgs>
    sender?: boolean | userDefaultArgs<ExtArgs>
  }
  export type groupMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | groupDefaultArgs<ExtArgs>
    sender?: boolean | userDefaultArgs<ExtArgs>
  }
  export type groupMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | groupDefaultArgs<ExtArgs>
    sender?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $groupMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groupMessage"
    objects: {
      group: Prisma.$groupPayload<ExtArgs>
      sender: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      body: string
      senderId: number
      created_at: Date
      read_at: Date | null
    }, ExtArgs["result"]["groupMessage"]>
    composites: {}
  }

  type groupMessageGetPayload<S extends boolean | null | undefined | groupMessageDefaultArgs> = $Result.GetResult<Prisma.$groupMessagePayload, S>

  type groupMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<groupMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMessageCountAggregateInputType | true
    }

  export interface groupMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groupMessage'], meta: { name: 'groupMessage' } }
    /**
     * Find zero or one GroupMessage that matches the filter.
     * @param {groupMessageFindUniqueArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupMessageFindUniqueArgs>(args: SelectSubset<T, groupMessageFindUniqueArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {groupMessageFindUniqueOrThrowArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, groupMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupMessageFindFirstArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupMessageFindFirstArgs>(args?: SelectSubset<T, groupMessageFindFirstArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupMessageFindFirstOrThrowArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, groupMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMessages
     * const groupMessages = await prisma.groupMessage.findMany()
     * 
     * // Get first 10 GroupMessages
     * const groupMessages = await prisma.groupMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMessageWithIdOnly = await prisma.groupMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupMessageFindManyArgs>(args?: SelectSubset<T, groupMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMessage.
     * @param {groupMessageCreateArgs} args - Arguments to create a GroupMessage.
     * @example
     * // Create one GroupMessage
     * const GroupMessage = await prisma.groupMessage.create({
     *   data: {
     *     // ... data to create a GroupMessage
     *   }
     * })
     * 
     */
    create<T extends groupMessageCreateArgs>(args: SelectSubset<T, groupMessageCreateArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMessages.
     * @param {groupMessageCreateManyArgs} args - Arguments to create many GroupMessages.
     * @example
     * // Create many GroupMessages
     * const groupMessage = await prisma.groupMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupMessageCreateManyArgs>(args?: SelectSubset<T, groupMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMessages and returns the data saved in the database.
     * @param {groupMessageCreateManyAndReturnArgs} args - Arguments to create many GroupMessages.
     * @example
     * // Create many GroupMessages
     * const groupMessage = await prisma.groupMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMessages and only return the `id`
     * const groupMessageWithIdOnly = await prisma.groupMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends groupMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, groupMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMessage.
     * @param {groupMessageDeleteArgs} args - Arguments to delete one GroupMessage.
     * @example
     * // Delete one GroupMessage
     * const GroupMessage = await prisma.groupMessage.delete({
     *   where: {
     *     // ... filter to delete one GroupMessage
     *   }
     * })
     * 
     */
    delete<T extends groupMessageDeleteArgs>(args: SelectSubset<T, groupMessageDeleteArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMessage.
     * @param {groupMessageUpdateArgs} args - Arguments to update one GroupMessage.
     * @example
     * // Update one GroupMessage
     * const groupMessage = await prisma.groupMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupMessageUpdateArgs>(args: SelectSubset<T, groupMessageUpdateArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMessages.
     * @param {groupMessageDeleteManyArgs} args - Arguments to filter GroupMessages to delete.
     * @example
     * // Delete a few GroupMessages
     * const { count } = await prisma.groupMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupMessageDeleteManyArgs>(args?: SelectSubset<T, groupMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMessages
     * const groupMessage = await prisma.groupMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupMessageUpdateManyArgs>(args: SelectSubset<T, groupMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessages and returns the data updated in the database.
     * @param {groupMessageUpdateManyAndReturnArgs} args - Arguments to update many GroupMessages.
     * @example
     * // Update many GroupMessages
     * const groupMessage = await prisma.groupMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMessages and only return the `id`
     * const groupMessageWithIdOnly = await prisma.groupMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends groupMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, groupMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMessage.
     * @param {groupMessageUpsertArgs} args - Arguments to update or create a GroupMessage.
     * @example
     * // Update or create a GroupMessage
     * const groupMessage = await prisma.groupMessage.upsert({
     *   create: {
     *     // ... data to create a GroupMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMessage we want to update
     *   }
     * })
     */
    upsert<T extends groupMessageUpsertArgs>(args: SelectSubset<T, groupMessageUpsertArgs<ExtArgs>>): Prisma__groupMessageClient<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupMessageCountArgs} args - Arguments to filter GroupMessages to count.
     * @example
     * // Count the number of GroupMessages
     * const count = await prisma.groupMessage.count({
     *   where: {
     *     // ... the filter for the GroupMessages we want to count
     *   }
     * })
    **/
    count<T extends groupMessageCountArgs>(
      args?: Subset<T, groupMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMessageAggregateArgs>(args: Subset<T, GroupMessageAggregateArgs>): Prisma.PrismaPromise<GetGroupMessageAggregateType<T>>

    /**
     * Group by GroupMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupMessageGroupByArgs['orderBy'] }
        : { orderBy?: groupMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groupMessage model
   */
  readonly fields: groupMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groupMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupDefaultArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the groupMessage model
   */
  interface groupMessageFieldRefs {
    readonly id: FieldRef<"groupMessage", 'Int'>
    readonly groupId: FieldRef<"groupMessage", 'Int'>
    readonly body: FieldRef<"groupMessage", 'String'>
    readonly senderId: FieldRef<"groupMessage", 'Int'>
    readonly created_at: FieldRef<"groupMessage", 'DateTime'>
    readonly read_at: FieldRef<"groupMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * groupMessage findUnique
   */
  export type groupMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * Filter, which groupMessage to fetch.
     */
    where: groupMessageWhereUniqueInput
  }

  /**
   * groupMessage findUniqueOrThrow
   */
  export type groupMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * Filter, which groupMessage to fetch.
     */
    where: groupMessageWhereUniqueInput
  }

  /**
   * groupMessage findFirst
   */
  export type groupMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * Filter, which groupMessage to fetch.
     */
    where?: groupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupMessages to fetch.
     */
    orderBy?: groupMessageOrderByWithRelationInput | groupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupMessages.
     */
    cursor?: groupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupMessages.
     */
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * groupMessage findFirstOrThrow
   */
  export type groupMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * Filter, which groupMessage to fetch.
     */
    where?: groupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupMessages to fetch.
     */
    orderBy?: groupMessageOrderByWithRelationInput | groupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupMessages.
     */
    cursor?: groupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupMessages.
     */
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * groupMessage findMany
   */
  export type groupMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * Filter, which groupMessages to fetch.
     */
    where?: groupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupMessages to fetch.
     */
    orderBy?: groupMessageOrderByWithRelationInput | groupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groupMessages.
     */
    cursor?: groupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupMessages.
     */
    skip?: number
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * groupMessage create
   */
  export type groupMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a groupMessage.
     */
    data: XOR<groupMessageCreateInput, groupMessageUncheckedCreateInput>
  }

  /**
   * groupMessage createMany
   */
  export type groupMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groupMessages.
     */
    data: groupMessageCreateManyInput | groupMessageCreateManyInput[]
  }

  /**
   * groupMessage createManyAndReturn
   */
  export type groupMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * The data used to create many groupMessages.
     */
    data: groupMessageCreateManyInput | groupMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * groupMessage update
   */
  export type groupMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a groupMessage.
     */
    data: XOR<groupMessageUpdateInput, groupMessageUncheckedUpdateInput>
    /**
     * Choose, which groupMessage to update.
     */
    where: groupMessageWhereUniqueInput
  }

  /**
   * groupMessage updateMany
   */
  export type groupMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groupMessages.
     */
    data: XOR<groupMessageUpdateManyMutationInput, groupMessageUncheckedUpdateManyInput>
    /**
     * Filter which groupMessages to update
     */
    where?: groupMessageWhereInput
    /**
     * Limit how many groupMessages to update.
     */
    limit?: number
  }

  /**
   * groupMessage updateManyAndReturn
   */
  export type groupMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * The data used to update groupMessages.
     */
    data: XOR<groupMessageUpdateManyMutationInput, groupMessageUncheckedUpdateManyInput>
    /**
     * Filter which groupMessages to update
     */
    where?: groupMessageWhereInput
    /**
     * Limit how many groupMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * groupMessage upsert
   */
  export type groupMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the groupMessage to update in case it exists.
     */
    where: groupMessageWhereUniqueInput
    /**
     * In case the groupMessage found by the `where` argument doesn't exist, create a new groupMessage with this data.
     */
    create: XOR<groupMessageCreateInput, groupMessageUncheckedCreateInput>
    /**
     * In case the groupMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupMessageUpdateInput, groupMessageUncheckedUpdateInput>
  }

  /**
   * groupMessage delete
   */
  export type groupMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    /**
     * Filter which groupMessage to delete.
     */
    where: groupMessageWhereUniqueInput
  }

  /**
   * groupMessage deleteMany
   */
  export type groupMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupMessages to delete
     */
    where?: groupMessageWhereInput
    /**
     * Limit how many groupMessages to delete.
     */
    limit?: number
  }

  /**
   * groupMessage without action
   */
  export type groupMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
  }


  /**
   * Model group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group to aggregate.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupWhereInput
    orderBy?: groupOrderByWithAggregationInput | groupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    name: string
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    members?: boolean | group$membersArgs<ExtArgs>
    groupMessages?: boolean | group$groupMessagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type groupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["group"]>

  export type groupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["group"]>

  export type groupSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["group"]>
  export type groupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | group$membersArgs<ExtArgs>
    groupMessages?: boolean | group$groupMessagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type groupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type groupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group"
    objects: {
      members: Prisma.$userGroupsPayload<ExtArgs>[]
      groupMessages: Prisma.$groupMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type groupGetPayload<S extends boolean | null | undefined | groupDefaultArgs> = $Result.GetResult<Prisma.$groupPayload, S>

  type groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group'], meta: { name: 'group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {groupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupFindUniqueArgs>(args: SelectSubset<T, groupFindUniqueArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {groupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupFindUniqueOrThrowArgs>(args: SelectSubset<T, groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupFindFirstArgs>(args?: SelectSubset<T, groupFindFirstArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupFindFirstOrThrowArgs>(args?: SelectSubset<T, groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupFindManyArgs>(args?: SelectSubset<T, groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {groupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends groupCreateArgs>(args: SelectSubset<T, groupCreateArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {groupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupCreateManyArgs>(args?: SelectSubset<T, groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {groupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends groupCreateManyAndReturnArgs>(args?: SelectSubset<T, groupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {groupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends groupDeleteArgs>(args: SelectSubset<T, groupDeleteArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {groupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupUpdateArgs>(args: SelectSubset<T, groupUpdateArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {groupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupDeleteManyArgs>(args?: SelectSubset<T, groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupUpdateManyArgs>(args: SelectSubset<T, groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {groupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends groupUpdateManyAndReturnArgs>(args: SelectSubset<T, groupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {groupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends groupUpsertArgs>(args: SelectSubset<T, groupUpsertArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupCountArgs>(
      args?: Subset<T, groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupGroupByArgs['orderBy'] }
        : { orderBy?: groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group model
   */
  readonly fields: groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends group$membersArgs<ExtArgs> = {}>(args?: Subset<T, group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMessages<T extends group$groupMessagesArgs<ExtArgs> = {}>(args?: Subset<T, group$groupMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group model
   */
  interface groupFieldRefs {
    readonly id: FieldRef<"group", 'Int'>
    readonly name: FieldRef<"group", 'String'>
  }
    

  // Custom InputTypes
  /**
   * group findUnique
   */
  export type groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group findUniqueOrThrow
   */
  export type groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group findFirst
   */
  export type groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group findFirstOrThrow
   */
  export type groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group findMany
   */
  export type groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group create
   */
  export type groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to create a group.
     */
    data: XOR<groupCreateInput, groupUncheckedCreateInput>
  }

  /**
   * group createMany
   */
  export type groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupCreateManyInput | groupCreateManyInput[]
  }

  /**
   * group createManyAndReturn
   */
  export type groupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * The data used to create many groups.
     */
    data: groupCreateManyInput | groupCreateManyInput[]
  }

  /**
   * group update
   */
  export type groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to update a group.
     */
    data: XOR<groupUpdateInput, groupUncheckedUpdateInput>
    /**
     * Choose, which group to update.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group updateMany
   */
  export type groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupWhereInput
    /**
     * Limit how many groups to update.
     */
    limit?: number
  }

  /**
   * group updateManyAndReturn
   */
  export type groupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * The data used to update groups.
     */
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupWhereInput
    /**
     * Limit how many groups to update.
     */
    limit?: number
  }

  /**
   * group upsert
   */
  export type groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The filter to search for the group to update in case it exists.
     */
    where: groupWhereUniqueInput
    /**
     * In case the group found by the `where` argument doesn't exist, create a new group with this data.
     */
    create: XOR<groupCreateInput, groupUncheckedCreateInput>
    /**
     * In case the group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupUpdateInput, groupUncheckedUpdateInput>
  }

  /**
   * group delete
   */
  export type groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter which group to delete.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group deleteMany
   */
  export type groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupWhereInput
    /**
     * Limit how many groups to delete.
     */
    limit?: number
  }

  /**
   * group.members
   */
  export type group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    where?: userGroupsWhereInput
    orderBy?: userGroupsOrderByWithRelationInput | userGroupsOrderByWithRelationInput[]
    cursor?: userGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }

  /**
   * group.groupMessages
   */
  export type group$groupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupMessage
     */
    select?: groupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groupMessage
     */
    omit?: groupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupMessageInclude<ExtArgs> | null
    where?: groupMessageWhereInput
    orderBy?: groupMessageOrderByWithRelationInput | groupMessageOrderByWithRelationInput[]
    cursor?: groupMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * group without action
   */
  export type groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
  }


  /**
   * Model userGroups
   */

  export type AggregateUserGroups = {
    _count: UserGroupsCountAggregateOutputType | null
    _avg: UserGroupsAvgAggregateOutputType | null
    _sum: UserGroupsSumAggregateOutputType | null
    _min: UserGroupsMinAggregateOutputType | null
    _max: UserGroupsMaxAggregateOutputType | null
  }

  export type UserGroupsAvgAggregateOutputType = {
    userId: number | null
    groupId: number | null
  }

  export type UserGroupsSumAggregateOutputType = {
    userId: number | null
    groupId: number | null
  }

  export type UserGroupsMinAggregateOutputType = {
    userId: number | null
    groupId: number | null
    assignedAt: Date | null
  }

  export type UserGroupsMaxAggregateOutputType = {
    userId: number | null
    groupId: number | null
    assignedAt: Date | null
  }

  export type UserGroupsCountAggregateOutputType = {
    userId: number
    groupId: number
    assignedAt: number
    _all: number
  }


  export type UserGroupsAvgAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type UserGroupsSumAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type UserGroupsMinAggregateInputType = {
    userId?: true
    groupId?: true
    assignedAt?: true
  }

  export type UserGroupsMaxAggregateInputType = {
    userId?: true
    groupId?: true
    assignedAt?: true
  }

  export type UserGroupsCountAggregateInputType = {
    userId?: true
    groupId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userGroups to aggregate.
     */
    where?: userGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userGroups to fetch.
     */
    orderBy?: userGroupsOrderByWithRelationInput | userGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userGroups
    **/
    _count?: true | UserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupsMaxAggregateInputType
  }

  export type GetUserGroupsAggregateType<T extends UserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroups[P]>
      : GetScalarType<T[P], AggregateUserGroups[P]>
  }




  export type userGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userGroupsWhereInput
    orderBy?: userGroupsOrderByWithAggregationInput | userGroupsOrderByWithAggregationInput[]
    by: UserGroupsScalarFieldEnum[] | UserGroupsScalarFieldEnum
    having?: userGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupsCountAggregateInputType | true
    _avg?: UserGroupsAvgAggregateInputType
    _sum?: UserGroupsSumAggregateInputType
    _min?: UserGroupsMinAggregateInputType
    _max?: UserGroupsMaxAggregateInputType
  }

  export type UserGroupsGroupByOutputType = {
    userId: number
    groupId: number
    assignedAt: Date
    _count: UserGroupsCountAggregateOutputType | null
    _avg: UserGroupsAvgAggregateOutputType | null
    _sum: UserGroupsSumAggregateOutputType | null
    _min: UserGroupsMinAggregateOutputType | null
    _max: UserGroupsMaxAggregateOutputType | null
  }

  type GetUserGroupsGroupByPayload<T extends userGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type userGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    group?: boolean | groupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroups"]>

  export type userGroupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    group?: boolean | groupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroups"]>

  export type userGroupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    group?: boolean | groupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroups"]>

  export type userGroupsSelectScalar = {
    userId?: boolean
    groupId?: boolean
    assignedAt?: boolean
  }

  export type userGroupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "groupId" | "assignedAt", ExtArgs["result"]["userGroups"]>
  export type userGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    group?: boolean | groupDefaultArgs<ExtArgs>
  }
  export type userGroupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    group?: boolean | groupDefaultArgs<ExtArgs>
  }
  export type userGroupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    group?: boolean | groupDefaultArgs<ExtArgs>
  }

  export type $userGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userGroups"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      group: Prisma.$groupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      groupId: number
      assignedAt: Date
    }, ExtArgs["result"]["userGroups"]>
    composites: {}
  }

  type userGroupsGetPayload<S extends boolean | null | undefined | userGroupsDefaultArgs> = $Result.GetResult<Prisma.$userGroupsPayload, S>

  type userGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userGroupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGroupsCountAggregateInputType | true
    }

  export interface userGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userGroups'], meta: { name: 'userGroups' } }
    /**
     * Find zero or one UserGroups that matches the filter.
     * @param {userGroupsFindUniqueArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userGroupsFindUniqueArgs>(args: SelectSubset<T, userGroupsFindUniqueArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGroups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userGroupsFindUniqueOrThrowArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userGroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, userGroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupsFindFirstArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userGroupsFindFirstArgs>(args?: SelectSubset<T, userGroupsFindFirstArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupsFindFirstOrThrowArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userGroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, userGroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroups.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroups.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userGroupsWithUserIdOnly = await prisma.userGroups.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends userGroupsFindManyArgs>(args?: SelectSubset<T, userGroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGroups.
     * @param {userGroupsCreateArgs} args - Arguments to create a UserGroups.
     * @example
     * // Create one UserGroups
     * const UserGroups = await prisma.userGroups.create({
     *   data: {
     *     // ... data to create a UserGroups
     *   }
     * })
     * 
     */
    create<T extends userGroupsCreateArgs>(args: SelectSubset<T, userGroupsCreateArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGroups.
     * @param {userGroupsCreateManyArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroups = await prisma.userGroups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userGroupsCreateManyArgs>(args?: SelectSubset<T, userGroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGroups and returns the data saved in the database.
     * @param {userGroupsCreateManyAndReturnArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroups = await prisma.userGroups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGroups and only return the `userId`
     * const userGroupsWithUserIdOnly = await prisma.userGroups.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userGroupsCreateManyAndReturnArgs>(args?: SelectSubset<T, userGroupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGroups.
     * @param {userGroupsDeleteArgs} args - Arguments to delete one UserGroups.
     * @example
     * // Delete one UserGroups
     * const UserGroups = await prisma.userGroups.delete({
     *   where: {
     *     // ... filter to delete one UserGroups
     *   }
     * })
     * 
     */
    delete<T extends userGroupsDeleteArgs>(args: SelectSubset<T, userGroupsDeleteArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGroups.
     * @param {userGroupsUpdateArgs} args - Arguments to update one UserGroups.
     * @example
     * // Update one UserGroups
     * const userGroups = await prisma.userGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userGroupsUpdateArgs>(args: SelectSubset<T, userGroupsUpdateArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGroups.
     * @param {userGroupsDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userGroupsDeleteManyArgs>(args?: SelectSubset<T, userGroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroups = await prisma.userGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userGroupsUpdateManyArgs>(args: SelectSubset<T, userGroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups and returns the data updated in the database.
     * @param {userGroupsUpdateManyAndReturnArgs} args - Arguments to update many UserGroups.
     * @example
     * // Update many UserGroups
     * const userGroups = await prisma.userGroups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGroups and only return the `userId`
     * const userGroupsWithUserIdOnly = await prisma.userGroups.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userGroupsUpdateManyAndReturnArgs>(args: SelectSubset<T, userGroupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGroups.
     * @param {userGroupsUpsertArgs} args - Arguments to update or create a UserGroups.
     * @example
     * // Update or create a UserGroups
     * const userGroups = await prisma.userGroups.upsert({
     *   create: {
     *     // ... data to create a UserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroups we want to update
     *   }
     * })
     */
    upsert<T extends userGroupsUpsertArgs>(args: SelectSubset<T, userGroupsUpsertArgs<ExtArgs>>): Prisma__userGroupsClient<$Result.GetResult<Prisma.$userGroupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupsCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroups.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends userGroupsCountArgs>(
      args?: Subset<T, userGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupsAggregateArgs>(args: Subset<T, UserGroupsAggregateArgs>): Prisma.PrismaPromise<GetUserGroupsAggregateType<T>>

    /**
     * Group by UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupsGroupByArgs['orderBy'] }
        : { orderBy?: userGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userGroups model
   */
  readonly fields: userGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupDefaultArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userGroups model
   */
  interface userGroupsFieldRefs {
    readonly userId: FieldRef<"userGroups", 'Int'>
    readonly groupId: FieldRef<"userGroups", 'Int'>
    readonly assignedAt: FieldRef<"userGroups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userGroups findUnique
   */
  export type userGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * Filter, which userGroups to fetch.
     */
    where: userGroupsWhereUniqueInput
  }

  /**
   * userGroups findUniqueOrThrow
   */
  export type userGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * Filter, which userGroups to fetch.
     */
    where: userGroupsWhereUniqueInput
  }

  /**
   * userGroups findFirst
   */
  export type userGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * Filter, which userGroups to fetch.
     */
    where?: userGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userGroups to fetch.
     */
    orderBy?: userGroupsOrderByWithRelationInput | userGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userGroups.
     */
    cursor?: userGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userGroups.
     */
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }

  /**
   * userGroups findFirstOrThrow
   */
  export type userGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * Filter, which userGroups to fetch.
     */
    where?: userGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userGroups to fetch.
     */
    orderBy?: userGroupsOrderByWithRelationInput | userGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userGroups.
     */
    cursor?: userGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userGroups.
     */
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }

  /**
   * userGroups findMany
   */
  export type userGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * Filter, which userGroups to fetch.
     */
    where?: userGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userGroups to fetch.
     */
    orderBy?: userGroupsOrderByWithRelationInput | userGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userGroups.
     */
    cursor?: userGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userGroups.
     */
    skip?: number
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }

  /**
   * userGroups create
   */
  export type userGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a userGroups.
     */
    data: XOR<userGroupsCreateInput, userGroupsUncheckedCreateInput>
  }

  /**
   * userGroups createMany
   */
  export type userGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userGroups.
     */
    data: userGroupsCreateManyInput | userGroupsCreateManyInput[]
  }

  /**
   * userGroups createManyAndReturn
   */
  export type userGroupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * The data used to create many userGroups.
     */
    data: userGroupsCreateManyInput | userGroupsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userGroups update
   */
  export type userGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a userGroups.
     */
    data: XOR<userGroupsUpdateInput, userGroupsUncheckedUpdateInput>
    /**
     * Choose, which userGroups to update.
     */
    where: userGroupsWhereUniqueInput
  }

  /**
   * userGroups updateMany
   */
  export type userGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userGroups.
     */
    data: XOR<userGroupsUpdateManyMutationInput, userGroupsUncheckedUpdateManyInput>
    /**
     * Filter which userGroups to update
     */
    where?: userGroupsWhereInput
    /**
     * Limit how many userGroups to update.
     */
    limit?: number
  }

  /**
   * userGroups updateManyAndReturn
   */
  export type userGroupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * The data used to update userGroups.
     */
    data: XOR<userGroupsUpdateManyMutationInput, userGroupsUncheckedUpdateManyInput>
    /**
     * Filter which userGroups to update
     */
    where?: userGroupsWhereInput
    /**
     * Limit how many userGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userGroups upsert
   */
  export type userGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the userGroups to update in case it exists.
     */
    where: userGroupsWhereUniqueInput
    /**
     * In case the userGroups found by the `where` argument doesn't exist, create a new userGroups with this data.
     */
    create: XOR<userGroupsCreateInput, userGroupsUncheckedCreateInput>
    /**
     * In case the userGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userGroupsUpdateInput, userGroupsUncheckedUpdateInput>
  }

  /**
   * userGroups delete
   */
  export type userGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
    /**
     * Filter which userGroups to delete.
     */
    where: userGroupsWhereUniqueInput
  }

  /**
   * userGroups deleteMany
   */
  export type userGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userGroups to delete
     */
    where?: userGroupsWhereInput
    /**
     * Limit how many userGroups to delete.
     */
    limit?: number
  }

  /**
   * userGroups without action
   */
  export type userGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userGroups
     */
    select?: userGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userGroups
     */
    omit?: userGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userGroupsInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    notificationPriorityId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    notificationPriorityId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    message: string | null
    notificationPriorityId: number | null
    createdAt: Date | null
    url: string | null
    type: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    message: string | null
    notificationPriorityId: number | null
    createdAt: Date | null
    url: string | null
    type: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    message: number
    notificationPriorityId: number
    createdAt: number
    url: number
    type: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    notificationPriorityId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    notificationPriorityId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    message?: true
    notificationPriorityId?: true
    createdAt?: true
    url?: true
    type?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    message?: true
    notificationPriorityId?: true
    createdAt?: true
    url?: true
    type?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    message?: true
    notificationPriorityId?: true
    createdAt?: true
    url?: true
    type?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    message: string
    notificationPriorityId: number
    createdAt: Date
    url: string
    type: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    notificationPriorityId?: boolean
    createdAt?: boolean
    url?: boolean
    type?: boolean
    notificationPriority?: boolean | notificationPriorityDefaultArgs<ExtArgs>
    roleNotifications?: boolean | notification$roleNotificationsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    notificationPriorityId?: boolean
    createdAt?: boolean
    url?: boolean
    type?: boolean
    notificationPriority?: boolean | notificationPriorityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    notificationPriorityId?: boolean
    createdAt?: boolean
    url?: boolean
    type?: boolean
    notificationPriority?: boolean | notificationPriorityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectScalar = {
    id?: boolean
    message?: boolean
    notificationPriorityId?: boolean
    createdAt?: boolean
    url?: boolean
    type?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "notificationPriorityId" | "createdAt" | "url" | "type", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationPriority?: boolean | notificationPriorityDefaultArgs<ExtArgs>
    roleNotifications?: boolean | notification$roleNotificationsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type notificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationPriority?: boolean | notificationPriorityDefaultArgs<ExtArgs>
  }
  export type notificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationPriority?: boolean | notificationPriorityDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      notificationPriority: Prisma.$notificationPriorityPayload<ExtArgs>
      roleNotifications: Prisma.$roleNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message: string
      notificationPriorityId: number
      createdAt: Date
      url: string
      type: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notificationPriority<T extends notificationPriorityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notificationPriorityDefaultArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roleNotifications<T extends notification$roleNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, notification$roleNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'Int'>
    readonly message: FieldRef<"notification", 'String'>
    readonly notificationPriorityId: FieldRef<"notification", 'Int'>
    readonly createdAt: FieldRef<"notification", 'DateTime'>
    readonly url: FieldRef<"notification", 'String'>
    readonly type: FieldRef<"notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
  }

  /**
   * notification createManyAndReturn
   */
  export type notificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification updateManyAndReturn
   */
  export type notificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification.roleNotifications
   */
  export type notification$roleNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    where?: roleNotificationWhereInput
    orderBy?: roleNotificationOrderByWithRelationInput | roleNotificationOrderByWithRelationInput[]
    cursor?: roleNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleNotificationScalarFieldEnum | RoleNotificationScalarFieldEnum[]
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model notificationPriority
   */

  export type AggregateNotificationPriority = {
    _count: NotificationPriorityCountAggregateOutputType | null
    _avg: NotificationPriorityAvgAggregateOutputType | null
    _sum: NotificationPrioritySumAggregateOutputType | null
    _min: NotificationPriorityMinAggregateOutputType | null
    _max: NotificationPriorityMaxAggregateOutputType | null
  }

  export type NotificationPriorityAvgAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type NotificationPrioritySumAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type NotificationPriorityMinAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type NotificationPriorityMaxAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type NotificationPriorityCountAggregateOutputType = {
    id: number
    level: number
    _all: number
  }


  export type NotificationPriorityAvgAggregateInputType = {
    id?: true
    level?: true
  }

  export type NotificationPrioritySumAggregateInputType = {
    id?: true
    level?: true
  }

  export type NotificationPriorityMinAggregateInputType = {
    id?: true
    level?: true
  }

  export type NotificationPriorityMaxAggregateInputType = {
    id?: true
    level?: true
  }

  export type NotificationPriorityCountAggregateInputType = {
    id?: true
    level?: true
    _all?: true
  }

  export type NotificationPriorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificationPriority to aggregate.
     */
    where?: notificationPriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPriorities to fetch.
     */
    orderBy?: notificationPriorityOrderByWithRelationInput | notificationPriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationPriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notificationPriorities
    **/
    _count?: true | NotificationPriorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPriorityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPrioritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPriorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPriorityMaxAggregateInputType
  }

  export type GetNotificationPriorityAggregateType<T extends NotificationPriorityAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPriority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPriority[P]>
      : GetScalarType<T[P], AggregateNotificationPriority[P]>
  }




  export type notificationPriorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationPriorityWhereInput
    orderBy?: notificationPriorityOrderByWithAggregationInput | notificationPriorityOrderByWithAggregationInput[]
    by: NotificationPriorityScalarFieldEnum[] | NotificationPriorityScalarFieldEnum
    having?: notificationPriorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPriorityCountAggregateInputType | true
    _avg?: NotificationPriorityAvgAggregateInputType
    _sum?: NotificationPrioritySumAggregateInputType
    _min?: NotificationPriorityMinAggregateInputType
    _max?: NotificationPriorityMaxAggregateInputType
  }

  export type NotificationPriorityGroupByOutputType = {
    id: number
    level: number
    _count: NotificationPriorityCountAggregateOutputType | null
    _avg: NotificationPriorityAvgAggregateOutputType | null
    _sum: NotificationPrioritySumAggregateOutputType | null
    _min: NotificationPriorityMinAggregateOutputType | null
    _max: NotificationPriorityMaxAggregateOutputType | null
  }

  type GetNotificationPriorityGroupByPayload<T extends notificationPriorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPriorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPriorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPriorityGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPriorityGroupByOutputType[P]>
        }
      >
    >


  export type notificationPrioritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    notifications?: boolean | notificationPriority$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationPriorityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPriority"]>

  export type notificationPrioritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
  }, ExtArgs["result"]["notificationPriority"]>

  export type notificationPrioritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
  }, ExtArgs["result"]["notificationPriority"]>

  export type notificationPrioritySelectScalar = {
    id?: boolean
    level?: boolean
  }

  export type notificationPriorityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level", ExtArgs["result"]["notificationPriority"]>
  export type notificationPriorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | notificationPriority$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationPriorityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type notificationPriorityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type notificationPriorityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $notificationPriorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notificationPriority"
    objects: {
      notifications: Prisma.$notificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: number
    }, ExtArgs["result"]["notificationPriority"]>
    composites: {}
  }

  type notificationPriorityGetPayload<S extends boolean | null | undefined | notificationPriorityDefaultArgs> = $Result.GetResult<Prisma.$notificationPriorityPayload, S>

  type notificationPriorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationPriorityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPriorityCountAggregateInputType | true
    }

  export interface notificationPriorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notificationPriority'], meta: { name: 'notificationPriority' } }
    /**
     * Find zero or one NotificationPriority that matches the filter.
     * @param {notificationPriorityFindUniqueArgs} args - Arguments to find a NotificationPriority
     * @example
     * // Get one NotificationPriority
     * const notificationPriority = await prisma.notificationPriority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationPriorityFindUniqueArgs>(args: SelectSubset<T, notificationPriorityFindUniqueArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPriority that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationPriorityFindUniqueOrThrowArgs} args - Arguments to find a NotificationPriority
     * @example
     * // Get one NotificationPriority
     * const notificationPriority = await prisma.notificationPriority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationPriorityFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationPriorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPriority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPriorityFindFirstArgs} args - Arguments to find a NotificationPriority
     * @example
     * // Get one NotificationPriority
     * const notificationPriority = await prisma.notificationPriority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationPriorityFindFirstArgs>(args?: SelectSubset<T, notificationPriorityFindFirstArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPriority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPriorityFindFirstOrThrowArgs} args - Arguments to find a NotificationPriority
     * @example
     * // Get one NotificationPriority
     * const notificationPriority = await prisma.notificationPriority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationPriorityFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationPriorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPriorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPriorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPriorities
     * const notificationPriorities = await prisma.notificationPriority.findMany()
     * 
     * // Get first 10 NotificationPriorities
     * const notificationPriorities = await prisma.notificationPriority.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPriorityWithIdOnly = await prisma.notificationPriority.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationPriorityFindManyArgs>(args?: SelectSubset<T, notificationPriorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPriority.
     * @param {notificationPriorityCreateArgs} args - Arguments to create a NotificationPriority.
     * @example
     * // Create one NotificationPriority
     * const NotificationPriority = await prisma.notificationPriority.create({
     *   data: {
     *     // ... data to create a NotificationPriority
     *   }
     * })
     * 
     */
    create<T extends notificationPriorityCreateArgs>(args: SelectSubset<T, notificationPriorityCreateArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPriorities.
     * @param {notificationPriorityCreateManyArgs} args - Arguments to create many NotificationPriorities.
     * @example
     * // Create many NotificationPriorities
     * const notificationPriority = await prisma.notificationPriority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationPriorityCreateManyArgs>(args?: SelectSubset<T, notificationPriorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPriorities and returns the data saved in the database.
     * @param {notificationPriorityCreateManyAndReturnArgs} args - Arguments to create many NotificationPriorities.
     * @example
     * // Create many NotificationPriorities
     * const notificationPriority = await prisma.notificationPriority.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPriorities and only return the `id`
     * const notificationPriorityWithIdOnly = await prisma.notificationPriority.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationPriorityCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationPriorityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPriority.
     * @param {notificationPriorityDeleteArgs} args - Arguments to delete one NotificationPriority.
     * @example
     * // Delete one NotificationPriority
     * const NotificationPriority = await prisma.notificationPriority.delete({
     *   where: {
     *     // ... filter to delete one NotificationPriority
     *   }
     * })
     * 
     */
    delete<T extends notificationPriorityDeleteArgs>(args: SelectSubset<T, notificationPriorityDeleteArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPriority.
     * @param {notificationPriorityUpdateArgs} args - Arguments to update one NotificationPriority.
     * @example
     * // Update one NotificationPriority
     * const notificationPriority = await prisma.notificationPriority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationPriorityUpdateArgs>(args: SelectSubset<T, notificationPriorityUpdateArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPriorities.
     * @param {notificationPriorityDeleteManyArgs} args - Arguments to filter NotificationPriorities to delete.
     * @example
     * // Delete a few NotificationPriorities
     * const { count } = await prisma.notificationPriority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationPriorityDeleteManyArgs>(args?: SelectSubset<T, notificationPriorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPriorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPriorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPriorities
     * const notificationPriority = await prisma.notificationPriority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationPriorityUpdateManyArgs>(args: SelectSubset<T, notificationPriorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPriorities and returns the data updated in the database.
     * @param {notificationPriorityUpdateManyAndReturnArgs} args - Arguments to update many NotificationPriorities.
     * @example
     * // Update many NotificationPriorities
     * const notificationPriority = await prisma.notificationPriority.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPriorities and only return the `id`
     * const notificationPriorityWithIdOnly = await prisma.notificationPriority.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationPriorityUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationPriorityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPriority.
     * @param {notificationPriorityUpsertArgs} args - Arguments to update or create a NotificationPriority.
     * @example
     * // Update or create a NotificationPriority
     * const notificationPriority = await prisma.notificationPriority.upsert({
     *   create: {
     *     // ... data to create a NotificationPriority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPriority we want to update
     *   }
     * })
     */
    upsert<T extends notificationPriorityUpsertArgs>(args: SelectSubset<T, notificationPriorityUpsertArgs<ExtArgs>>): Prisma__notificationPriorityClient<$Result.GetResult<Prisma.$notificationPriorityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPriorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPriorityCountArgs} args - Arguments to filter NotificationPriorities to count.
     * @example
     * // Count the number of NotificationPriorities
     * const count = await prisma.notificationPriority.count({
     *   where: {
     *     // ... the filter for the NotificationPriorities we want to count
     *   }
     * })
    **/
    count<T extends notificationPriorityCountArgs>(
      args?: Subset<T, notificationPriorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPriorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPriority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPriorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPriorityAggregateArgs>(args: Subset<T, NotificationPriorityAggregateArgs>): Prisma.PrismaPromise<GetNotificationPriorityAggregateType<T>>

    /**
     * Group by NotificationPriority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationPriorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationPriorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationPriorityGroupByArgs['orderBy'] }
        : { orderBy?: notificationPriorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationPriorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPriorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notificationPriority model
   */
  readonly fields: notificationPriorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notificationPriority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationPriorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends notificationPriority$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, notificationPriority$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notificationPriority model
   */
  interface notificationPriorityFieldRefs {
    readonly id: FieldRef<"notificationPriority", 'Int'>
    readonly level: FieldRef<"notificationPriority", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * notificationPriority findUnique
   */
  export type notificationPriorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * Filter, which notificationPriority to fetch.
     */
    where: notificationPriorityWhereUniqueInput
  }

  /**
   * notificationPriority findUniqueOrThrow
   */
  export type notificationPriorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * Filter, which notificationPriority to fetch.
     */
    where: notificationPriorityWhereUniqueInput
  }

  /**
   * notificationPriority findFirst
   */
  export type notificationPriorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * Filter, which notificationPriority to fetch.
     */
    where?: notificationPriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPriorities to fetch.
     */
    orderBy?: notificationPriorityOrderByWithRelationInput | notificationPriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificationPriorities.
     */
    cursor?: notificationPriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificationPriorities.
     */
    distinct?: NotificationPriorityScalarFieldEnum | NotificationPriorityScalarFieldEnum[]
  }

  /**
   * notificationPriority findFirstOrThrow
   */
  export type notificationPriorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * Filter, which notificationPriority to fetch.
     */
    where?: notificationPriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPriorities to fetch.
     */
    orderBy?: notificationPriorityOrderByWithRelationInput | notificationPriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificationPriorities.
     */
    cursor?: notificationPriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificationPriorities.
     */
    distinct?: NotificationPriorityScalarFieldEnum | NotificationPriorityScalarFieldEnum[]
  }

  /**
   * notificationPriority findMany
   */
  export type notificationPriorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * Filter, which notificationPriorities to fetch.
     */
    where?: notificationPriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificationPriorities to fetch.
     */
    orderBy?: notificationPriorityOrderByWithRelationInput | notificationPriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notificationPriorities.
     */
    cursor?: notificationPriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificationPriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificationPriorities.
     */
    skip?: number
    distinct?: NotificationPriorityScalarFieldEnum | NotificationPriorityScalarFieldEnum[]
  }

  /**
   * notificationPriority create
   */
  export type notificationPriorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * The data needed to create a notificationPriority.
     */
    data: XOR<notificationPriorityCreateInput, notificationPriorityUncheckedCreateInput>
  }

  /**
   * notificationPriority createMany
   */
  export type notificationPriorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notificationPriorities.
     */
    data: notificationPriorityCreateManyInput | notificationPriorityCreateManyInput[]
  }

  /**
   * notificationPriority createManyAndReturn
   */
  export type notificationPriorityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * The data used to create many notificationPriorities.
     */
    data: notificationPriorityCreateManyInput | notificationPriorityCreateManyInput[]
  }

  /**
   * notificationPriority update
   */
  export type notificationPriorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * The data needed to update a notificationPriority.
     */
    data: XOR<notificationPriorityUpdateInput, notificationPriorityUncheckedUpdateInput>
    /**
     * Choose, which notificationPriority to update.
     */
    where: notificationPriorityWhereUniqueInput
  }

  /**
   * notificationPriority updateMany
   */
  export type notificationPriorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notificationPriorities.
     */
    data: XOR<notificationPriorityUpdateManyMutationInput, notificationPriorityUncheckedUpdateManyInput>
    /**
     * Filter which notificationPriorities to update
     */
    where?: notificationPriorityWhereInput
    /**
     * Limit how many notificationPriorities to update.
     */
    limit?: number
  }

  /**
   * notificationPriority updateManyAndReturn
   */
  export type notificationPriorityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * The data used to update notificationPriorities.
     */
    data: XOR<notificationPriorityUpdateManyMutationInput, notificationPriorityUncheckedUpdateManyInput>
    /**
     * Filter which notificationPriorities to update
     */
    where?: notificationPriorityWhereInput
    /**
     * Limit how many notificationPriorities to update.
     */
    limit?: number
  }

  /**
   * notificationPriority upsert
   */
  export type notificationPriorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * The filter to search for the notificationPriority to update in case it exists.
     */
    where: notificationPriorityWhereUniqueInput
    /**
     * In case the notificationPriority found by the `where` argument doesn't exist, create a new notificationPriority with this data.
     */
    create: XOR<notificationPriorityCreateInput, notificationPriorityUncheckedCreateInput>
    /**
     * In case the notificationPriority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationPriorityUpdateInput, notificationPriorityUncheckedUpdateInput>
  }

  /**
   * notificationPriority delete
   */
  export type notificationPriorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
    /**
     * Filter which notificationPriority to delete.
     */
    where: notificationPriorityWhereUniqueInput
  }

  /**
   * notificationPriority deleteMany
   */
  export type notificationPriorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificationPriorities to delete
     */
    where?: notificationPriorityWhereInput
    /**
     * Limit how many notificationPriorities to delete.
     */
    limit?: number
  }

  /**
   * notificationPriority.notifications
   */
  export type notificationPriority$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notificationPriority without action
   */
  export type notificationPriorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificationPriority
     */
    select?: notificationPrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificationPriority
     */
    omit?: notificationPriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationPriorityInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | role$usersArgs<ExtArgs>
    roleNotifications?: boolean | role$roleNotificationsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | role$usersArgs<ExtArgs>
    roleNotifications?: boolean | role$roleNotificationsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      users: Prisma.$userrolePayload<ExtArgs>[]
      roleNotifications: Prisma.$roleNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {roleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends roleUpdateManyAndReturnArgs>(args: SelectSubset<T, roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends role$usersArgs<ExtArgs> = {}>(args?: Subset<T, role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleNotifications<T extends role$roleNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, role$roleNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'Int'>
    readonly name: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data?: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
  }

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role updateManyAndReturn
   */
  export type roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.users
   */
  export type role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * role.roleNotifications
   */
  export type role$roleNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    where?: roleNotificationWhereInput
    orderBy?: roleNotificationOrderByWithRelationInput | roleNotificationOrderByWithRelationInput[]
    cursor?: roleNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleNotificationScalarFieldEnum | RoleNotificationScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model roleNotification
   */

  export type AggregateRoleNotification = {
    _count: RoleNotificationCountAggregateOutputType | null
    _avg: RoleNotificationAvgAggregateOutputType | null
    _sum: RoleNotificationSumAggregateOutputType | null
    _min: RoleNotificationMinAggregateOutputType | null
    _max: RoleNotificationMaxAggregateOutputType | null
  }

  export type RoleNotificationAvgAggregateOutputType = {
    roleId: number | null
    notificationId: number | null
  }

  export type RoleNotificationSumAggregateOutputType = {
    roleId: number | null
    notificationId: number | null
  }

  export type RoleNotificationMinAggregateOutputType = {
    roleId: number | null
    notificationId: number | null
  }

  export type RoleNotificationMaxAggregateOutputType = {
    roleId: number | null
    notificationId: number | null
  }

  export type RoleNotificationCountAggregateOutputType = {
    roleId: number
    notificationId: number
    _all: number
  }


  export type RoleNotificationAvgAggregateInputType = {
    roleId?: true
    notificationId?: true
  }

  export type RoleNotificationSumAggregateInputType = {
    roleId?: true
    notificationId?: true
  }

  export type RoleNotificationMinAggregateInputType = {
    roleId?: true
    notificationId?: true
  }

  export type RoleNotificationMaxAggregateInputType = {
    roleId?: true
    notificationId?: true
  }

  export type RoleNotificationCountAggregateInputType = {
    roleId?: true
    notificationId?: true
    _all?: true
  }

  export type RoleNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roleNotification to aggregate.
     */
    where?: roleNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roleNotifications to fetch.
     */
    orderBy?: roleNotificationOrderByWithRelationInput | roleNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roleNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roleNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roleNotifications
    **/
    _count?: true | RoleNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleNotificationMaxAggregateInputType
  }

  export type GetRoleNotificationAggregateType<T extends RoleNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleNotification[P]>
      : GetScalarType<T[P], AggregateRoleNotification[P]>
  }




  export type roleNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleNotificationWhereInput
    orderBy?: roleNotificationOrderByWithAggregationInput | roleNotificationOrderByWithAggregationInput[]
    by: RoleNotificationScalarFieldEnum[] | RoleNotificationScalarFieldEnum
    having?: roleNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleNotificationCountAggregateInputType | true
    _avg?: RoleNotificationAvgAggregateInputType
    _sum?: RoleNotificationSumAggregateInputType
    _min?: RoleNotificationMinAggregateInputType
    _max?: RoleNotificationMaxAggregateInputType
  }

  export type RoleNotificationGroupByOutputType = {
    roleId: number
    notificationId: number
    _count: RoleNotificationCountAggregateOutputType | null
    _avg: RoleNotificationAvgAggregateOutputType | null
    _sum: RoleNotificationSumAggregateOutputType | null
    _min: RoleNotificationMinAggregateOutputType | null
    _max: RoleNotificationMaxAggregateOutputType | null
  }

  type GetRoleNotificationGroupByPayload<T extends roleNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], RoleNotificationGroupByOutputType[P]>
        }
      >
    >


  export type roleNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    notificationId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    notification?: boolean | notificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleNotification"]>

  export type roleNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    notificationId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    notification?: boolean | notificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleNotification"]>

  export type roleNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    notificationId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    notification?: boolean | notificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleNotification"]>

  export type roleNotificationSelectScalar = {
    roleId?: boolean
    notificationId?: boolean
  }

  export type roleNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "notificationId", ExtArgs["result"]["roleNotification"]>
  export type roleNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    notification?: boolean | notificationDefaultArgs<ExtArgs>
  }
  export type roleNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    notification?: boolean | notificationDefaultArgs<ExtArgs>
  }
  export type roleNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    notification?: boolean | notificationDefaultArgs<ExtArgs>
  }

  export type $roleNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roleNotification"
    objects: {
      role: Prisma.$rolePayload<ExtArgs>
      notification: Prisma.$notificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      notificationId: number
    }, ExtArgs["result"]["roleNotification"]>
    composites: {}
  }

  type roleNotificationGetPayload<S extends boolean | null | undefined | roleNotificationDefaultArgs> = $Result.GetResult<Prisma.$roleNotificationPayload, S>

  type roleNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleNotificationCountAggregateInputType | true
    }

  export interface roleNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roleNotification'], meta: { name: 'roleNotification' } }
    /**
     * Find zero or one RoleNotification that matches the filter.
     * @param {roleNotificationFindUniqueArgs} args - Arguments to find a RoleNotification
     * @example
     * // Get one RoleNotification
     * const roleNotification = await prisma.roleNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleNotificationFindUniqueArgs>(args: SelectSubset<T, roleNotificationFindUniqueArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleNotificationFindUniqueOrThrowArgs} args - Arguments to find a RoleNotification
     * @example
     * // Get one RoleNotification
     * const roleNotification = await prisma.roleNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, roleNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleNotificationFindFirstArgs} args - Arguments to find a RoleNotification
     * @example
     * // Get one RoleNotification
     * const roleNotification = await prisma.roleNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleNotificationFindFirstArgs>(args?: SelectSubset<T, roleNotificationFindFirstArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleNotificationFindFirstOrThrowArgs} args - Arguments to find a RoleNotification
     * @example
     * // Get one RoleNotification
     * const roleNotification = await prisma.roleNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, roleNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleNotifications
     * const roleNotifications = await prisma.roleNotification.findMany()
     * 
     * // Get first 10 RoleNotifications
     * const roleNotifications = await prisma.roleNotification.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const roleNotificationWithRoleIdOnly = await prisma.roleNotification.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends roleNotificationFindManyArgs>(args?: SelectSubset<T, roleNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleNotification.
     * @param {roleNotificationCreateArgs} args - Arguments to create a RoleNotification.
     * @example
     * // Create one RoleNotification
     * const RoleNotification = await prisma.roleNotification.create({
     *   data: {
     *     // ... data to create a RoleNotification
     *   }
     * })
     * 
     */
    create<T extends roleNotificationCreateArgs>(args: SelectSubset<T, roleNotificationCreateArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleNotifications.
     * @param {roleNotificationCreateManyArgs} args - Arguments to create many RoleNotifications.
     * @example
     * // Create many RoleNotifications
     * const roleNotification = await prisma.roleNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleNotificationCreateManyArgs>(args?: SelectSubset<T, roleNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleNotifications and returns the data saved in the database.
     * @param {roleNotificationCreateManyAndReturnArgs} args - Arguments to create many RoleNotifications.
     * @example
     * // Create many RoleNotifications
     * const roleNotification = await prisma.roleNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleNotifications and only return the `roleId`
     * const roleNotificationWithRoleIdOnly = await prisma.roleNotification.createManyAndReturn({
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, roleNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleNotification.
     * @param {roleNotificationDeleteArgs} args - Arguments to delete one RoleNotification.
     * @example
     * // Delete one RoleNotification
     * const RoleNotification = await prisma.roleNotification.delete({
     *   where: {
     *     // ... filter to delete one RoleNotification
     *   }
     * })
     * 
     */
    delete<T extends roleNotificationDeleteArgs>(args: SelectSubset<T, roleNotificationDeleteArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleNotification.
     * @param {roleNotificationUpdateArgs} args - Arguments to update one RoleNotification.
     * @example
     * // Update one RoleNotification
     * const roleNotification = await prisma.roleNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleNotificationUpdateArgs>(args: SelectSubset<T, roleNotificationUpdateArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleNotifications.
     * @param {roleNotificationDeleteManyArgs} args - Arguments to filter RoleNotifications to delete.
     * @example
     * // Delete a few RoleNotifications
     * const { count } = await prisma.roleNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleNotificationDeleteManyArgs>(args?: SelectSubset<T, roleNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleNotifications
     * const roleNotification = await prisma.roleNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleNotificationUpdateManyArgs>(args: SelectSubset<T, roleNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleNotifications and returns the data updated in the database.
     * @param {roleNotificationUpdateManyAndReturnArgs} args - Arguments to update many RoleNotifications.
     * @example
     * // Update many RoleNotifications
     * const roleNotification = await prisma.roleNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleNotifications and only return the `roleId`
     * const roleNotificationWithRoleIdOnly = await prisma.roleNotification.updateManyAndReturn({
     *   select: { roleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends roleNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, roleNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleNotification.
     * @param {roleNotificationUpsertArgs} args - Arguments to update or create a RoleNotification.
     * @example
     * // Update or create a RoleNotification
     * const roleNotification = await prisma.roleNotification.upsert({
     *   create: {
     *     // ... data to create a RoleNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleNotification we want to update
     *   }
     * })
     */
    upsert<T extends roleNotificationUpsertArgs>(args: SelectSubset<T, roleNotificationUpsertArgs<ExtArgs>>): Prisma__roleNotificationClient<$Result.GetResult<Prisma.$roleNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleNotificationCountArgs} args - Arguments to filter RoleNotifications to count.
     * @example
     * // Count the number of RoleNotifications
     * const count = await prisma.roleNotification.count({
     *   where: {
     *     // ... the filter for the RoleNotifications we want to count
     *   }
     * })
    **/
    count<T extends roleNotificationCountArgs>(
      args?: Subset<T, roleNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleNotificationAggregateArgs>(args: Subset<T, RoleNotificationAggregateArgs>): Prisma.PrismaPromise<GetRoleNotificationAggregateType<T>>

    /**
     * Group by RoleNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleNotificationGroupByArgs['orderBy'] }
        : { orderBy?: roleNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roleNotification model
   */
  readonly fields: roleNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roleNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notification<T extends notificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notificationDefaultArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roleNotification model
   */
  interface roleNotificationFieldRefs {
    readonly roleId: FieldRef<"roleNotification", 'Int'>
    readonly notificationId: FieldRef<"roleNotification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * roleNotification findUnique
   */
  export type roleNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * Filter, which roleNotification to fetch.
     */
    where: roleNotificationWhereUniqueInput
  }

  /**
   * roleNotification findUniqueOrThrow
   */
  export type roleNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * Filter, which roleNotification to fetch.
     */
    where: roleNotificationWhereUniqueInput
  }

  /**
   * roleNotification findFirst
   */
  export type roleNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * Filter, which roleNotification to fetch.
     */
    where?: roleNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roleNotifications to fetch.
     */
    orderBy?: roleNotificationOrderByWithRelationInput | roleNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roleNotifications.
     */
    cursor?: roleNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roleNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roleNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roleNotifications.
     */
    distinct?: RoleNotificationScalarFieldEnum | RoleNotificationScalarFieldEnum[]
  }

  /**
   * roleNotification findFirstOrThrow
   */
  export type roleNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * Filter, which roleNotification to fetch.
     */
    where?: roleNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roleNotifications to fetch.
     */
    orderBy?: roleNotificationOrderByWithRelationInput | roleNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roleNotifications.
     */
    cursor?: roleNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roleNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roleNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roleNotifications.
     */
    distinct?: RoleNotificationScalarFieldEnum | RoleNotificationScalarFieldEnum[]
  }

  /**
   * roleNotification findMany
   */
  export type roleNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * Filter, which roleNotifications to fetch.
     */
    where?: roleNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roleNotifications to fetch.
     */
    orderBy?: roleNotificationOrderByWithRelationInput | roleNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roleNotifications.
     */
    cursor?: roleNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roleNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roleNotifications.
     */
    skip?: number
    distinct?: RoleNotificationScalarFieldEnum | RoleNotificationScalarFieldEnum[]
  }

  /**
   * roleNotification create
   */
  export type roleNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a roleNotification.
     */
    data: XOR<roleNotificationCreateInput, roleNotificationUncheckedCreateInput>
  }

  /**
   * roleNotification createMany
   */
  export type roleNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roleNotifications.
     */
    data: roleNotificationCreateManyInput | roleNotificationCreateManyInput[]
  }

  /**
   * roleNotification createManyAndReturn
   */
  export type roleNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many roleNotifications.
     */
    data: roleNotificationCreateManyInput | roleNotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * roleNotification update
   */
  export type roleNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a roleNotification.
     */
    data: XOR<roleNotificationUpdateInput, roleNotificationUncheckedUpdateInput>
    /**
     * Choose, which roleNotification to update.
     */
    where: roleNotificationWhereUniqueInput
  }

  /**
   * roleNotification updateMany
   */
  export type roleNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roleNotifications.
     */
    data: XOR<roleNotificationUpdateManyMutationInput, roleNotificationUncheckedUpdateManyInput>
    /**
     * Filter which roleNotifications to update
     */
    where?: roleNotificationWhereInput
    /**
     * Limit how many roleNotifications to update.
     */
    limit?: number
  }

  /**
   * roleNotification updateManyAndReturn
   */
  export type roleNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * The data used to update roleNotifications.
     */
    data: XOR<roleNotificationUpdateManyMutationInput, roleNotificationUncheckedUpdateManyInput>
    /**
     * Filter which roleNotifications to update
     */
    where?: roleNotificationWhereInput
    /**
     * Limit how many roleNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * roleNotification upsert
   */
  export type roleNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the roleNotification to update in case it exists.
     */
    where: roleNotificationWhereUniqueInput
    /**
     * In case the roleNotification found by the `where` argument doesn't exist, create a new roleNotification with this data.
     */
    create: XOR<roleNotificationCreateInput, roleNotificationUncheckedCreateInput>
    /**
     * In case the roleNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleNotificationUpdateInput, roleNotificationUncheckedUpdateInput>
  }

  /**
   * roleNotification delete
   */
  export type roleNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
    /**
     * Filter which roleNotification to delete.
     */
    where: roleNotificationWhereUniqueInput
  }

  /**
   * roleNotification deleteMany
   */
  export type roleNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roleNotifications to delete
     */
    where?: roleNotificationWhereInput
    /**
     * Limit how many roleNotifications to delete.
     */
    limit?: number
  }

  /**
   * roleNotification without action
   */
  export type roleNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roleNotification
     */
    select?: roleNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roleNotification
     */
    omit?: roleNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleNotificationInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserroleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserroleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserroleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserroleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserroleSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserroleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserroleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserroleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
  }

  export type userroleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId", ExtArgs["result"]["userrole"]>
  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userroleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userroleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      role: Prisma.$rolePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roleId: number
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userroleWithIdOnly = await prisma.userrole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userroles and returns the data saved in the database.
     * @param {userroleCreateManyAndReturnArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userroles and only return the `id`
     * const userroleWithIdOnly = await prisma.userrole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userroleCreateManyAndReturnArgs>(args?: SelectSubset<T, userroleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles and returns the data updated in the database.
     * @param {userroleUpdateManyAndReturnArgs} args - Arguments to update many Userroles.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userroles and only return the `id`
     * const userroleWithIdOnly = await prisma.userrole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userroleUpdateManyAndReturnArgs>(args: SelectSubset<T, userroleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */
  interface userroleFieldRefs {
    readonly id: FieldRef<"userrole", 'Int'>
    readonly userId: FieldRef<"userrole", 'Int'>
    readonly roleId: FieldRef<"userrole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
  }

  /**
   * userrole createManyAndReturn
   */
  export type userroleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
  }

  /**
   * userrole updateManyAndReturn
   */
  export type userroleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to delete.
     */
    limit?: number
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Model client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client to aggregate.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type clientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientWhereInput
    orderBy?: clientOrderByWithAggregationInput | clientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends clientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type clientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    campaigns?: boolean | client$campaignsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type clientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["client"]>

  export type clientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["client"]>

  export type clientSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type clientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "updated_at", ExtArgs["result"]["client"]>
  export type clientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | client$campaignsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client"
    objects: {
      campaigns: Prisma.$campaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type clientGetPayload<S extends boolean | null | undefined | clientDefaultArgs> = $Result.GetResult<Prisma.$clientPayload, S>

  type clientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface clientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client'], meta: { name: 'client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {clientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientFindUniqueArgs>(args: SelectSubset<T, clientFindUniqueArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientFindUniqueOrThrowArgs>(args: SelectSubset<T, clientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientFindFirstArgs>(args?: SelectSubset<T, clientFindFirstArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientFindFirstOrThrowArgs>(args?: SelectSubset<T, clientFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientFindManyArgs>(args?: SelectSubset<T, clientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {clientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends clientCreateArgs>(args: SelectSubset<T, clientCreateArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {clientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientCreateManyArgs>(args?: SelectSubset<T, clientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {clientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clientCreateManyAndReturnArgs>(args?: SelectSubset<T, clientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {clientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends clientDeleteArgs>(args: SelectSubset<T, clientDeleteArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {clientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientUpdateArgs>(args: SelectSubset<T, clientUpdateArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientDeleteManyArgs>(args?: SelectSubset<T, clientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientUpdateManyArgs>(args: SelectSubset<T, clientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {clientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clientUpdateManyAndReturnArgs>(args: SelectSubset<T, clientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {clientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends clientUpsertArgs>(args: SelectSubset<T, clientUpsertArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientCountArgs>(
      args?: Subset<T, clientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientGroupByArgs['orderBy'] }
        : { orderBy?: clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client model
   */
  readonly fields: clientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends client$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, client$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client model
   */
  interface clientFieldRefs {
    readonly id: FieldRef<"client", 'Int'>
    readonly name: FieldRef<"client", 'String'>
    readonly created_at: FieldRef<"client", 'DateTime'>
    readonly updated_at: FieldRef<"client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * client findUnique
   */
  export type clientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client findUniqueOrThrow
   */
  export type clientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client findFirst
   */
  export type clientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * client findFirstOrThrow
   */
  export type clientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * client findMany
   */
  export type clientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * client create
   */
  export type clientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The data needed to create a client.
     */
    data: XOR<clientCreateInput, clientUncheckedCreateInput>
  }

  /**
   * client createMany
   */
  export type clientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientCreateManyInput | clientCreateManyInput[]
  }

  /**
   * client createManyAndReturn
   */
  export type clientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * The data used to create many clients.
     */
    data: clientCreateManyInput | clientCreateManyInput[]
  }

  /**
   * client update
   */
  export type clientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The data needed to update a client.
     */
    data: XOR<clientUpdateInput, clientUncheckedUpdateInput>
    /**
     * Choose, which client to update.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client updateMany
   */
  export type clientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * client updateManyAndReturn
   */
  export type clientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * The data used to update clients.
     */
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * client upsert
   */
  export type clientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The filter to search for the client to update in case it exists.
     */
    where: clientWhereUniqueInput
    /**
     * In case the client found by the `where` argument doesn't exist, create a new client with this data.
     */
    create: XOR<clientCreateInput, clientUncheckedCreateInput>
    /**
     * In case the client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientUpdateInput, clientUncheckedUpdateInput>
  }

  /**
   * client delete
   */
  export type clientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter which client to delete.
     */
    where: clientWhereUniqueInput
  }

  /**
   * client deleteMany
   */
  export type clientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientWhereInput
    /**
     * Limit how many clients to delete.
     */
    limit?: number
  }

  /**
   * client.campaigns
   */
  export type client$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    where?: campaignWhereInput
    orderBy?: campaignOrderByWithRelationInput | campaignOrderByWithRelationInput[]
    cursor?: campaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * client without action
   */
  export type clientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client
     */
    omit?: clientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientInclude<ExtArgs> | null
  }


  /**
   * Model campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    leadgoal: number | null
    completed: number | null
    pending: number | null
  }

  export type CampaignSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    leadgoal: number | null
    completed: number | null
    pending: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    clientId: number | null
    leadgoal: number | null
    completed: number | null
    pending: number | null
    duedate: Date | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    clientId: number | null
    leadgoal: number | null
    completed: number | null
    pending: number | null
    duedate: Date | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    code: number
    clientId: number
    leadgoal: number
    completed: number
    pending: number
    duedate: number
    info: number
    content: number
    filesInfo: number
    updates: number
    created_at: number
    updated_at: number
    status: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    id?: true
    clientId?: true
    leadgoal?: true
    completed?: true
    pending?: true
  }

  export type CampaignSumAggregateInputType = {
    id?: true
    clientId?: true
    leadgoal?: true
    completed?: true
    pending?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clientId?: true
    leadgoal?: true
    completed?: true
    pending?: true
    duedate?: true
    created_at?: true
    updated_at?: true
    status?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clientId?: true
    leadgoal?: true
    completed?: true
    pending?: true
    duedate?: true
    created_at?: true
    updated_at?: true
    status?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    clientId?: true
    leadgoal?: true
    completed?: true
    pending?: true
    duedate?: true
    info?: true
    content?: true
    filesInfo?: true
    updates?: true
    created_at?: true
    updated_at?: true
    status?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign to aggregate.
     */
    where?: campaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignOrderByWithRelationInput | campaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type campaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignWhereInput
    orderBy?: campaignOrderByWithAggregationInput | campaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: campaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: number
    name: string
    code: string
    clientId: number
    leadgoal: number
    completed: number
    pending: number
    duedate: Date
    info: JsonValue
    content: JsonValue
    filesInfo: JsonValue
    updates: JsonValue
    created_at: Date
    updated_at: Date
    status: string
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends campaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type campaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    clientId?: boolean
    leadgoal?: boolean
    completed?: boolean
    pending?: boolean
    duedate?: boolean
    info?: boolean
    content?: boolean
    filesInfo?: boolean
    updates?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    client?: boolean | clientDefaultArgs<ExtArgs>
    volumes?: boolean | campaign$volumesArgs<ExtArgs>
    leads?: boolean | campaign$leadsArgs<ExtArgs>
    campaignDeliveries?: boolean | campaign$campaignDeliveriesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type campaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    clientId?: boolean
    leadgoal?: boolean
    completed?: boolean
    pending?: boolean
    duedate?: boolean
    info?: boolean
    content?: boolean
    filesInfo?: boolean
    updates?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    client?: boolean | clientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type campaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    clientId?: boolean
    leadgoal?: boolean
    completed?: boolean
    pending?: boolean
    duedate?: boolean
    info?: boolean
    content?: boolean
    filesInfo?: boolean
    updates?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    client?: boolean | clientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type campaignSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    clientId?: boolean
    leadgoal?: boolean
    completed?: boolean
    pending?: boolean
    duedate?: boolean
    info?: boolean
    content?: boolean
    filesInfo?: boolean
    updates?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
  }

  export type campaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "clientId" | "leadgoal" | "completed" | "pending" | "duedate" | "info" | "content" | "filesInfo" | "updates" | "created_at" | "updated_at" | "status", ExtArgs["result"]["campaign"]>
  export type campaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | clientDefaultArgs<ExtArgs>
    volumes?: boolean | campaign$volumesArgs<ExtArgs>
    leads?: boolean | campaign$leadsArgs<ExtArgs>
    campaignDeliveries?: boolean | campaign$campaignDeliveriesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type campaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | clientDefaultArgs<ExtArgs>
  }
  export type campaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | clientDefaultArgs<ExtArgs>
  }

  export type $campaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaign"
    objects: {
      client: Prisma.$clientPayload<ExtArgs>
      volumes: Prisma.$volumePayload<ExtArgs>[]
      leads: Prisma.$leadPayload<ExtArgs>[]
      campaignDeliveries: Prisma.$campaignDeliveriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      clientId: number
      leadgoal: number
      completed: number
      pending: number
      duedate: Date
      info: Prisma.JsonValue
      content: Prisma.JsonValue
      filesInfo: Prisma.JsonValue
      updates: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      status: string
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type campaignGetPayload<S extends boolean | null | undefined | campaignDefaultArgs> = $Result.GetResult<Prisma.$campaignPayload, S>

  type campaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface campaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaign'], meta: { name: 'campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {campaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaignFindUniqueArgs>(args: SelectSubset<T, campaignFindUniqueArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaignFindUniqueOrThrowArgs>(args: SelectSubset<T, campaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaignFindFirstArgs>(args?: SelectSubset<T, campaignFindFirstArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaignFindFirstOrThrowArgs>(args?: SelectSubset<T, campaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaignFindManyArgs>(args?: SelectSubset<T, campaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {campaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends campaignCreateArgs>(args: SelectSubset<T, campaignCreateArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {campaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaignCreateManyArgs>(args?: SelectSubset<T, campaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {campaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaignCreateManyAndReturnArgs>(args?: SelectSubset<T, campaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {campaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends campaignDeleteArgs>(args: SelectSubset<T, campaignDeleteArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {campaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaignUpdateArgs>(args: SelectSubset<T, campaignUpdateArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {campaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaignDeleteManyArgs>(args?: SelectSubset<T, campaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaignUpdateManyArgs>(args: SelectSubset<T, campaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {campaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campaignUpdateManyAndReturnArgs>(args: SelectSubset<T, campaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {campaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends campaignUpsertArgs>(args: SelectSubset<T, campaignUpsertArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends campaignCountArgs>(
      args?: Subset<T, campaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaignGroupByArgs['orderBy'] }
        : { orderBy?: campaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaign model
   */
  readonly fields: campaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends clientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientDefaultArgs<ExtArgs>>): Prisma__clientClient<$Result.GetResult<Prisma.$clientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    volumes<T extends campaign$volumesArgs<ExtArgs> = {}>(args?: Subset<T, campaign$volumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends campaign$leadsArgs<ExtArgs> = {}>(args?: Subset<T, campaign$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaignDeliveries<T extends campaign$campaignDeliveriesArgs<ExtArgs> = {}>(args?: Subset<T, campaign$campaignDeliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaign model
   */
  interface campaignFieldRefs {
    readonly id: FieldRef<"campaign", 'Int'>
    readonly name: FieldRef<"campaign", 'String'>
    readonly code: FieldRef<"campaign", 'String'>
    readonly clientId: FieldRef<"campaign", 'Int'>
    readonly leadgoal: FieldRef<"campaign", 'Int'>
    readonly completed: FieldRef<"campaign", 'Int'>
    readonly pending: FieldRef<"campaign", 'Int'>
    readonly duedate: FieldRef<"campaign", 'DateTime'>
    readonly info: FieldRef<"campaign", 'Json'>
    readonly content: FieldRef<"campaign", 'Json'>
    readonly filesInfo: FieldRef<"campaign", 'Json'>
    readonly updates: FieldRef<"campaign", 'Json'>
    readonly created_at: FieldRef<"campaign", 'DateTime'>
    readonly updated_at: FieldRef<"campaign", 'DateTime'>
    readonly status: FieldRef<"campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * campaign findUnique
   */
  export type campaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * Filter, which campaign to fetch.
     */
    where: campaignWhereUniqueInput
  }

  /**
   * campaign findUniqueOrThrow
   */
  export type campaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * Filter, which campaign to fetch.
     */
    where: campaignWhereUniqueInput
  }

  /**
   * campaign findFirst
   */
  export type campaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * Filter, which campaign to fetch.
     */
    where?: campaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignOrderByWithRelationInput | campaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaigns.
     */
    cursor?: campaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * campaign findFirstOrThrow
   */
  export type campaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * Filter, which campaign to fetch.
     */
    where?: campaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignOrderByWithRelationInput | campaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaigns.
     */
    cursor?: campaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * campaign findMany
   */
  export type campaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignOrderByWithRelationInput | campaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaigns.
     */
    cursor?: campaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * campaign create
   */
  export type campaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * The data needed to create a campaign.
     */
    data: XOR<campaignCreateInput, campaignUncheckedCreateInput>
  }

  /**
   * campaign createMany
   */
  export type campaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaigns.
     */
    data: campaignCreateManyInput | campaignCreateManyInput[]
  }

  /**
   * campaign createManyAndReturn
   */
  export type campaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * The data used to create many campaigns.
     */
    data: campaignCreateManyInput | campaignCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaign update
   */
  export type campaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * The data needed to update a campaign.
     */
    data: XOR<campaignUpdateInput, campaignUncheckedUpdateInput>
    /**
     * Choose, which campaign to update.
     */
    where: campaignWhereUniqueInput
  }

  /**
   * campaign updateMany
   */
  export type campaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaigns.
     */
    data: XOR<campaignUpdateManyMutationInput, campaignUncheckedUpdateManyInput>
    /**
     * Filter which campaigns to update
     */
    where?: campaignWhereInput
    /**
     * Limit how many campaigns to update.
     */
    limit?: number
  }

  /**
   * campaign updateManyAndReturn
   */
  export type campaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * The data used to update campaigns.
     */
    data: XOR<campaignUpdateManyMutationInput, campaignUncheckedUpdateManyInput>
    /**
     * Filter which campaigns to update
     */
    where?: campaignWhereInput
    /**
     * Limit how many campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaign upsert
   */
  export type campaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * The filter to search for the campaign to update in case it exists.
     */
    where: campaignWhereUniqueInput
    /**
     * In case the campaign found by the `where` argument doesn't exist, create a new campaign with this data.
     */
    create: XOR<campaignCreateInput, campaignUncheckedCreateInput>
    /**
     * In case the campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaignUpdateInput, campaignUncheckedUpdateInput>
  }

  /**
   * campaign delete
   */
  export type campaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
    /**
     * Filter which campaign to delete.
     */
    where: campaignWhereUniqueInput
  }

  /**
   * campaign deleteMany
   */
  export type campaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaigns to delete
     */
    where?: campaignWhereInput
    /**
     * Limit how many campaigns to delete.
     */
    limit?: number
  }

  /**
   * campaign.volumes
   */
  export type campaign$volumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    where?: volumeWhereInput
    orderBy?: volumeOrderByWithRelationInput | volumeOrderByWithRelationInput[]
    cursor?: volumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * campaign.leads
   */
  export type campaign$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    where?: leadWhereInput
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    cursor?: leadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * campaign.campaignDeliveries
   */
  export type campaign$campaignDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    where?: campaignDeliveriesWhereInput
    orderBy?: campaignDeliveriesOrderByWithRelationInput | campaignDeliveriesOrderByWithRelationInput[]
    cursor?: campaignDeliveriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignDeliveriesScalarFieldEnum | CampaignDeliveriesScalarFieldEnum[]
  }

  /**
   * campaign without action
   */
  export type campaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign
     */
    select?: campaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaign
     */
    omit?: campaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignInclude<ExtArgs> | null
  }


  /**
   * Model campaignDeliveries
   */

  export type AggregateCampaignDeliveries = {
    _count: CampaignDeliveriesCountAggregateOutputType | null
    _avg: CampaignDeliveriesAvgAggregateOutputType | null
    _sum: CampaignDeliveriesSumAggregateOutputType | null
    _min: CampaignDeliveriesMinAggregateOutputType | null
    _max: CampaignDeliveriesMaxAggregateOutputType | null
  }

  export type CampaignDeliveriesAvgAggregateOutputType = {
    id: number | null
    campaignId: number | null
    submitted: number | null
    accepted: number | null
    errors: number | null
    rejections: number | null
    uploaderId: number | null
  }

  export type CampaignDeliveriesSumAggregateOutputType = {
    id: number | null
    campaignId: number | null
    submitted: number | null
    accepted: number | null
    errors: number | null
    rejections: number | null
    uploaderId: number | null
  }

  export type CampaignDeliveriesMinAggregateOutputType = {
    id: number | null
    campaignId: number | null
    date: Date | null
    fileName: string | null
    submitted: number | null
    accepted: number | null
    errors: number | null
    rejections: number | null
    uploaderId: number | null
    data: string | null
  }

  export type CampaignDeliveriesMaxAggregateOutputType = {
    id: number | null
    campaignId: number | null
    date: Date | null
    fileName: string | null
    submitted: number | null
    accepted: number | null
    errors: number | null
    rejections: number | null
    uploaderId: number | null
    data: string | null
  }

  export type CampaignDeliveriesCountAggregateOutputType = {
    id: number
    campaignId: number
    date: number
    fileName: number
    submitted: number
    accepted: number
    errors: number
    rejections: number
    uploaderId: number
    data: number
    _all: number
  }


  export type CampaignDeliveriesAvgAggregateInputType = {
    id?: true
    campaignId?: true
    submitted?: true
    accepted?: true
    errors?: true
    rejections?: true
    uploaderId?: true
  }

  export type CampaignDeliveriesSumAggregateInputType = {
    id?: true
    campaignId?: true
    submitted?: true
    accepted?: true
    errors?: true
    rejections?: true
    uploaderId?: true
  }

  export type CampaignDeliveriesMinAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    fileName?: true
    submitted?: true
    accepted?: true
    errors?: true
    rejections?: true
    uploaderId?: true
    data?: true
  }

  export type CampaignDeliveriesMaxAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    fileName?: true
    submitted?: true
    accepted?: true
    errors?: true
    rejections?: true
    uploaderId?: true
    data?: true
  }

  export type CampaignDeliveriesCountAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    fileName?: true
    submitted?: true
    accepted?: true
    errors?: true
    rejections?: true
    uploaderId?: true
    data?: true
    _all?: true
  }

  export type CampaignDeliveriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaignDeliveries to aggregate.
     */
    where?: campaignDeliveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignDeliveries to fetch.
     */
    orderBy?: campaignDeliveriesOrderByWithRelationInput | campaignDeliveriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaignDeliveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaignDeliveries
    **/
    _count?: true | CampaignDeliveriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignDeliveriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignDeliveriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignDeliveriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignDeliveriesMaxAggregateInputType
  }

  export type GetCampaignDeliveriesAggregateType<T extends CampaignDeliveriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignDeliveries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignDeliveries[P]>
      : GetScalarType<T[P], AggregateCampaignDeliveries[P]>
  }




  export type campaignDeliveriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignDeliveriesWhereInput
    orderBy?: campaignDeliveriesOrderByWithAggregationInput | campaignDeliveriesOrderByWithAggregationInput[]
    by: CampaignDeliveriesScalarFieldEnum[] | CampaignDeliveriesScalarFieldEnum
    having?: campaignDeliveriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignDeliveriesCountAggregateInputType | true
    _avg?: CampaignDeliveriesAvgAggregateInputType
    _sum?: CampaignDeliveriesSumAggregateInputType
    _min?: CampaignDeliveriesMinAggregateInputType
    _max?: CampaignDeliveriesMaxAggregateInputType
  }

  export type CampaignDeliveriesGroupByOutputType = {
    id: number
    campaignId: number
    date: Date
    fileName: string
    submitted: number
    accepted: number
    errors: number
    rejections: number
    uploaderId: number | null
    data: string
    _count: CampaignDeliveriesCountAggregateOutputType | null
    _avg: CampaignDeliveriesAvgAggregateOutputType | null
    _sum: CampaignDeliveriesSumAggregateOutputType | null
    _min: CampaignDeliveriesMinAggregateOutputType | null
    _max: CampaignDeliveriesMaxAggregateOutputType | null
  }

  type GetCampaignDeliveriesGroupByPayload<T extends campaignDeliveriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignDeliveriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignDeliveriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignDeliveriesGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignDeliveriesGroupByOutputType[P]>
        }
      >
    >


  export type campaignDeliveriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    fileName?: boolean
    submitted?: boolean
    accepted?: boolean
    errors?: boolean
    rejections?: boolean
    uploaderId?: boolean
    data?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    uploader?: boolean | campaignDeliveries$uploaderArgs<ExtArgs>
    leads?: boolean | campaignDeliveries$leadsArgs<ExtArgs>
    _count?: boolean | CampaignDeliveriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignDeliveries"]>

  export type campaignDeliveriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    fileName?: boolean
    submitted?: boolean
    accepted?: boolean
    errors?: boolean
    rejections?: boolean
    uploaderId?: boolean
    data?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    uploader?: boolean | campaignDeliveries$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["campaignDeliveries"]>

  export type campaignDeliveriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    fileName?: boolean
    submitted?: boolean
    accepted?: boolean
    errors?: boolean
    rejections?: boolean
    uploaderId?: boolean
    data?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    uploader?: boolean | campaignDeliveries$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["campaignDeliveries"]>

  export type campaignDeliveriesSelectScalar = {
    id?: boolean
    campaignId?: boolean
    date?: boolean
    fileName?: boolean
    submitted?: boolean
    accepted?: boolean
    errors?: boolean
    rejections?: boolean
    uploaderId?: boolean
    data?: boolean
  }

  export type campaignDeliveriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "date" | "fileName" | "submitted" | "accepted" | "errors" | "rejections" | "uploaderId" | "data", ExtArgs["result"]["campaignDeliveries"]>
  export type campaignDeliveriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    uploader?: boolean | campaignDeliveries$uploaderArgs<ExtArgs>
    leads?: boolean | campaignDeliveries$leadsArgs<ExtArgs>
    _count?: boolean | CampaignDeliveriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type campaignDeliveriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    uploader?: boolean | campaignDeliveries$uploaderArgs<ExtArgs>
  }
  export type campaignDeliveriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    uploader?: boolean | campaignDeliveries$uploaderArgs<ExtArgs>
  }

  export type $campaignDeliveriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaignDeliveries"
    objects: {
      campaign: Prisma.$campaignPayload<ExtArgs>
      uploader: Prisma.$userPayload<ExtArgs> | null
      leads: Prisma.$leadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      campaignId: number
      date: Date
      fileName: string
      submitted: number
      accepted: number
      errors: number
      rejections: number
      uploaderId: number | null
      data: string
    }, ExtArgs["result"]["campaignDeliveries"]>
    composites: {}
  }

  type campaignDeliveriesGetPayload<S extends boolean | null | undefined | campaignDeliveriesDefaultArgs> = $Result.GetResult<Prisma.$campaignDeliveriesPayload, S>

  type campaignDeliveriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campaignDeliveriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignDeliveriesCountAggregateInputType | true
    }

  export interface campaignDeliveriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaignDeliveries'], meta: { name: 'campaignDeliveries' } }
    /**
     * Find zero or one CampaignDeliveries that matches the filter.
     * @param {campaignDeliveriesFindUniqueArgs} args - Arguments to find a CampaignDeliveries
     * @example
     * // Get one CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaignDeliveriesFindUniqueArgs>(args: SelectSubset<T, campaignDeliveriesFindUniqueArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignDeliveries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campaignDeliveriesFindUniqueOrThrowArgs} args - Arguments to find a CampaignDeliveries
     * @example
     * // Get one CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaignDeliveriesFindUniqueOrThrowArgs>(args: SelectSubset<T, campaignDeliveriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignDeliveriesFindFirstArgs} args - Arguments to find a CampaignDeliveries
     * @example
     * // Get one CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaignDeliveriesFindFirstArgs>(args?: SelectSubset<T, campaignDeliveriesFindFirstArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignDeliveries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignDeliveriesFindFirstOrThrowArgs} args - Arguments to find a CampaignDeliveries
     * @example
     * // Get one CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaignDeliveriesFindFirstOrThrowArgs>(args?: SelectSubset<T, campaignDeliveriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignDeliveriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.findMany()
     * 
     * // Get first 10 CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignDeliveriesWithIdOnly = await prisma.campaignDeliveries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaignDeliveriesFindManyArgs>(args?: SelectSubset<T, campaignDeliveriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignDeliveries.
     * @param {campaignDeliveriesCreateArgs} args - Arguments to create a CampaignDeliveries.
     * @example
     * // Create one CampaignDeliveries
     * const CampaignDeliveries = await prisma.campaignDeliveries.create({
     *   data: {
     *     // ... data to create a CampaignDeliveries
     *   }
     * })
     * 
     */
    create<T extends campaignDeliveriesCreateArgs>(args: SelectSubset<T, campaignDeliveriesCreateArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignDeliveries.
     * @param {campaignDeliveriesCreateManyArgs} args - Arguments to create many CampaignDeliveries.
     * @example
     * // Create many CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaignDeliveriesCreateManyArgs>(args?: SelectSubset<T, campaignDeliveriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignDeliveries and returns the data saved in the database.
     * @param {campaignDeliveriesCreateManyAndReturnArgs} args - Arguments to create many CampaignDeliveries.
     * @example
     * // Create many CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignDeliveries and only return the `id`
     * const campaignDeliveriesWithIdOnly = await prisma.campaignDeliveries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaignDeliveriesCreateManyAndReturnArgs>(args?: SelectSubset<T, campaignDeliveriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignDeliveries.
     * @param {campaignDeliveriesDeleteArgs} args - Arguments to delete one CampaignDeliveries.
     * @example
     * // Delete one CampaignDeliveries
     * const CampaignDeliveries = await prisma.campaignDeliveries.delete({
     *   where: {
     *     // ... filter to delete one CampaignDeliveries
     *   }
     * })
     * 
     */
    delete<T extends campaignDeliveriesDeleteArgs>(args: SelectSubset<T, campaignDeliveriesDeleteArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignDeliveries.
     * @param {campaignDeliveriesUpdateArgs} args - Arguments to update one CampaignDeliveries.
     * @example
     * // Update one CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaignDeliveriesUpdateArgs>(args: SelectSubset<T, campaignDeliveriesUpdateArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignDeliveries.
     * @param {campaignDeliveriesDeleteManyArgs} args - Arguments to filter CampaignDeliveries to delete.
     * @example
     * // Delete a few CampaignDeliveries
     * const { count } = await prisma.campaignDeliveries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaignDeliveriesDeleteManyArgs>(args?: SelectSubset<T, campaignDeliveriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignDeliveriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaignDeliveriesUpdateManyArgs>(args: SelectSubset<T, campaignDeliveriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignDeliveries and returns the data updated in the database.
     * @param {campaignDeliveriesUpdateManyAndReturnArgs} args - Arguments to update many CampaignDeliveries.
     * @example
     * // Update many CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignDeliveries and only return the `id`
     * const campaignDeliveriesWithIdOnly = await prisma.campaignDeliveries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campaignDeliveriesUpdateManyAndReturnArgs>(args: SelectSubset<T, campaignDeliveriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignDeliveries.
     * @param {campaignDeliveriesUpsertArgs} args - Arguments to update or create a CampaignDeliveries.
     * @example
     * // Update or create a CampaignDeliveries
     * const campaignDeliveries = await prisma.campaignDeliveries.upsert({
     *   create: {
     *     // ... data to create a CampaignDeliveries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignDeliveries we want to update
     *   }
     * })
     */
    upsert<T extends campaignDeliveriesUpsertArgs>(args: SelectSubset<T, campaignDeliveriesUpsertArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignDeliveriesCountArgs} args - Arguments to filter CampaignDeliveries to count.
     * @example
     * // Count the number of CampaignDeliveries
     * const count = await prisma.campaignDeliveries.count({
     *   where: {
     *     // ... the filter for the CampaignDeliveries we want to count
     *   }
     * })
    **/
    count<T extends campaignDeliveriesCountArgs>(
      args?: Subset<T, campaignDeliveriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignDeliveriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDeliveriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignDeliveriesAggregateArgs>(args: Subset<T, CampaignDeliveriesAggregateArgs>): Prisma.PrismaPromise<GetCampaignDeliveriesAggregateType<T>>

    /**
     * Group by CampaignDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignDeliveriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaignDeliveriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaignDeliveriesGroupByArgs['orderBy'] }
        : { orderBy?: campaignDeliveriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaignDeliveriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignDeliveriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaignDeliveries model
   */
  readonly fields: campaignDeliveriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaignDeliveries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaignDeliveriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends campaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignDefaultArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends campaignDeliveries$uploaderArgs<ExtArgs> = {}>(args?: Subset<T, campaignDeliveries$uploaderArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    leads<T extends campaignDeliveries$leadsArgs<ExtArgs> = {}>(args?: Subset<T, campaignDeliveries$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaignDeliveries model
   */
  interface campaignDeliveriesFieldRefs {
    readonly id: FieldRef<"campaignDeliveries", 'Int'>
    readonly campaignId: FieldRef<"campaignDeliveries", 'Int'>
    readonly date: FieldRef<"campaignDeliveries", 'DateTime'>
    readonly fileName: FieldRef<"campaignDeliveries", 'String'>
    readonly submitted: FieldRef<"campaignDeliveries", 'Int'>
    readonly accepted: FieldRef<"campaignDeliveries", 'Int'>
    readonly errors: FieldRef<"campaignDeliveries", 'Int'>
    readonly rejections: FieldRef<"campaignDeliveries", 'Int'>
    readonly uploaderId: FieldRef<"campaignDeliveries", 'Int'>
    readonly data: FieldRef<"campaignDeliveries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * campaignDeliveries findUnique
   */
  export type campaignDeliveriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * Filter, which campaignDeliveries to fetch.
     */
    where: campaignDeliveriesWhereUniqueInput
  }

  /**
   * campaignDeliveries findUniqueOrThrow
   */
  export type campaignDeliveriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * Filter, which campaignDeliveries to fetch.
     */
    where: campaignDeliveriesWhereUniqueInput
  }

  /**
   * campaignDeliveries findFirst
   */
  export type campaignDeliveriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * Filter, which campaignDeliveries to fetch.
     */
    where?: campaignDeliveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignDeliveries to fetch.
     */
    orderBy?: campaignDeliveriesOrderByWithRelationInput | campaignDeliveriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaignDeliveries.
     */
    cursor?: campaignDeliveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaignDeliveries.
     */
    distinct?: CampaignDeliveriesScalarFieldEnum | CampaignDeliveriesScalarFieldEnum[]
  }

  /**
   * campaignDeliveries findFirstOrThrow
   */
  export type campaignDeliveriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * Filter, which campaignDeliveries to fetch.
     */
    where?: campaignDeliveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignDeliveries to fetch.
     */
    orderBy?: campaignDeliveriesOrderByWithRelationInput | campaignDeliveriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaignDeliveries.
     */
    cursor?: campaignDeliveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaignDeliveries.
     */
    distinct?: CampaignDeliveriesScalarFieldEnum | CampaignDeliveriesScalarFieldEnum[]
  }

  /**
   * campaignDeliveries findMany
   */
  export type campaignDeliveriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * Filter, which campaignDeliveries to fetch.
     */
    where?: campaignDeliveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignDeliveries to fetch.
     */
    orderBy?: campaignDeliveriesOrderByWithRelationInput | campaignDeliveriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaignDeliveries.
     */
    cursor?: campaignDeliveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignDeliveries.
     */
    skip?: number
    distinct?: CampaignDeliveriesScalarFieldEnum | CampaignDeliveriesScalarFieldEnum[]
  }

  /**
   * campaignDeliveries create
   */
  export type campaignDeliveriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * The data needed to create a campaignDeliveries.
     */
    data: XOR<campaignDeliveriesCreateInput, campaignDeliveriesUncheckedCreateInput>
  }

  /**
   * campaignDeliveries createMany
   */
  export type campaignDeliveriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaignDeliveries.
     */
    data: campaignDeliveriesCreateManyInput | campaignDeliveriesCreateManyInput[]
  }

  /**
   * campaignDeliveries createManyAndReturn
   */
  export type campaignDeliveriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * The data used to create many campaignDeliveries.
     */
    data: campaignDeliveriesCreateManyInput | campaignDeliveriesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaignDeliveries update
   */
  export type campaignDeliveriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * The data needed to update a campaignDeliveries.
     */
    data: XOR<campaignDeliveriesUpdateInput, campaignDeliveriesUncheckedUpdateInput>
    /**
     * Choose, which campaignDeliveries to update.
     */
    where: campaignDeliveriesWhereUniqueInput
  }

  /**
   * campaignDeliveries updateMany
   */
  export type campaignDeliveriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaignDeliveries.
     */
    data: XOR<campaignDeliveriesUpdateManyMutationInput, campaignDeliveriesUncheckedUpdateManyInput>
    /**
     * Filter which campaignDeliveries to update
     */
    where?: campaignDeliveriesWhereInput
    /**
     * Limit how many campaignDeliveries to update.
     */
    limit?: number
  }

  /**
   * campaignDeliveries updateManyAndReturn
   */
  export type campaignDeliveriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * The data used to update campaignDeliveries.
     */
    data: XOR<campaignDeliveriesUpdateManyMutationInput, campaignDeliveriesUncheckedUpdateManyInput>
    /**
     * Filter which campaignDeliveries to update
     */
    where?: campaignDeliveriesWhereInput
    /**
     * Limit how many campaignDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaignDeliveries upsert
   */
  export type campaignDeliveriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * The filter to search for the campaignDeliveries to update in case it exists.
     */
    where: campaignDeliveriesWhereUniqueInput
    /**
     * In case the campaignDeliveries found by the `where` argument doesn't exist, create a new campaignDeliveries with this data.
     */
    create: XOR<campaignDeliveriesCreateInput, campaignDeliveriesUncheckedCreateInput>
    /**
     * In case the campaignDeliveries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaignDeliveriesUpdateInput, campaignDeliveriesUncheckedUpdateInput>
  }

  /**
   * campaignDeliveries delete
   */
  export type campaignDeliveriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    /**
     * Filter which campaignDeliveries to delete.
     */
    where: campaignDeliveriesWhereUniqueInput
  }

  /**
   * campaignDeliveries deleteMany
   */
  export type campaignDeliveriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaignDeliveries to delete
     */
    where?: campaignDeliveriesWhereInput
    /**
     * Limit how many campaignDeliveries to delete.
     */
    limit?: number
  }

  /**
   * campaignDeliveries.uploader
   */
  export type campaignDeliveries$uploaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * campaignDeliveries.leads
   */
  export type campaignDeliveries$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    where?: leadWhereInput
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    cursor?: leadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * campaignDeliveries without action
   */
  export type campaignDeliveriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
  }


  /**
   * Model campaignType
   */

  export type AggregateCampaignType = {
    _count: CampaignTypeCountAggregateOutputType | null
    _avg: CampaignTypeAvgAggregateOutputType | null
    _sum: CampaignTypeSumAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  export type CampaignTypeAvgAggregateOutputType = {
    id: number | null
    campaignId: number | null
  }

  export type CampaignTypeSumAggregateOutputType = {
    id: number | null
    campaignId: number | null
  }

  export type CampaignTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    campaignId: number | null
  }

  export type CampaignTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    campaignId: number | null
  }

  export type CampaignTypeCountAggregateOutputType = {
    id: number
    name: number
    campaignId: number
    _all: number
  }


  export type CampaignTypeAvgAggregateInputType = {
    id?: true
    campaignId?: true
  }

  export type CampaignTypeSumAggregateInputType = {
    id?: true
    campaignId?: true
  }

  export type CampaignTypeMinAggregateInputType = {
    id?: true
    name?: true
    campaignId?: true
  }

  export type CampaignTypeMaxAggregateInputType = {
    id?: true
    name?: true
    campaignId?: true
  }

  export type CampaignTypeCountAggregateInputType = {
    id?: true
    name?: true
    campaignId?: true
    _all?: true
  }

  export type CampaignTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaignType to aggregate.
     */
    where?: campaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignTypes to fetch.
     */
    orderBy?: campaignTypeOrderByWithRelationInput | campaignTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaignTypes
    **/
    _count?: true | CampaignTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTypeMaxAggregateInputType
  }

  export type GetCampaignTypeAggregateType<T extends CampaignTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignType[P]>
      : GetScalarType<T[P], AggregateCampaignType[P]>
  }




  export type campaignTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignTypeWhereInput
    orderBy?: campaignTypeOrderByWithAggregationInput | campaignTypeOrderByWithAggregationInput[]
    by: CampaignTypeScalarFieldEnum[] | CampaignTypeScalarFieldEnum
    having?: campaignTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTypeCountAggregateInputType | true
    _avg?: CampaignTypeAvgAggregateInputType
    _sum?: CampaignTypeSumAggregateInputType
    _min?: CampaignTypeMinAggregateInputType
    _max?: CampaignTypeMaxAggregateInputType
  }

  export type CampaignTypeGroupByOutputType = {
    id: number
    name: string
    campaignId: number
    _count: CampaignTypeCountAggregateOutputType | null
    _avg: CampaignTypeAvgAggregateOutputType | null
    _sum: CampaignTypeSumAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  type GetCampaignTypeGroupByPayload<T extends campaignTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
        }
      >
    >


  export type campaignTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    campaignId?: boolean
  }, ExtArgs["result"]["campaignType"]>

  export type campaignTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    campaignId?: boolean
  }, ExtArgs["result"]["campaignType"]>

  export type campaignTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    campaignId?: boolean
  }, ExtArgs["result"]["campaignType"]>

  export type campaignTypeSelectScalar = {
    id?: boolean
    name?: boolean
    campaignId?: boolean
  }

  export type campaignTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "campaignId", ExtArgs["result"]["campaignType"]>

  export type $campaignTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaignType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      campaignId: number
    }, ExtArgs["result"]["campaignType"]>
    composites: {}
  }

  type campaignTypeGetPayload<S extends boolean | null | undefined | campaignTypeDefaultArgs> = $Result.GetResult<Prisma.$campaignTypePayload, S>

  type campaignTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campaignTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignTypeCountAggregateInputType | true
    }

  export interface campaignTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaignType'], meta: { name: 'campaignType' } }
    /**
     * Find zero or one CampaignType that matches the filter.
     * @param {campaignTypeFindUniqueArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaignTypeFindUniqueArgs>(args: SelectSubset<T, campaignTypeFindUniqueArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campaignTypeFindUniqueOrThrowArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaignTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, campaignTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignTypeFindFirstArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaignTypeFindFirstArgs>(args?: SelectSubset<T, campaignTypeFindFirstArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignTypeFindFirstOrThrowArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaignTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, campaignTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany()
     * 
     * // Get first 10 CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTypeWithIdOnly = await prisma.campaignType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaignTypeFindManyArgs>(args?: SelectSubset<T, campaignTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignType.
     * @param {campaignTypeCreateArgs} args - Arguments to create a CampaignType.
     * @example
     * // Create one CampaignType
     * const CampaignType = await prisma.campaignType.create({
     *   data: {
     *     // ... data to create a CampaignType
     *   }
     * })
     * 
     */
    create<T extends campaignTypeCreateArgs>(args: SelectSubset<T, campaignTypeCreateArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignTypes.
     * @param {campaignTypeCreateManyArgs} args - Arguments to create many CampaignTypes.
     * @example
     * // Create many CampaignTypes
     * const campaignType = await prisma.campaignType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaignTypeCreateManyArgs>(args?: SelectSubset<T, campaignTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignTypes and returns the data saved in the database.
     * @param {campaignTypeCreateManyAndReturnArgs} args - Arguments to create many CampaignTypes.
     * @example
     * // Create many CampaignTypes
     * const campaignType = await prisma.campaignType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignTypes and only return the `id`
     * const campaignTypeWithIdOnly = await prisma.campaignType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaignTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, campaignTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignType.
     * @param {campaignTypeDeleteArgs} args - Arguments to delete one CampaignType.
     * @example
     * // Delete one CampaignType
     * const CampaignType = await prisma.campaignType.delete({
     *   where: {
     *     // ... filter to delete one CampaignType
     *   }
     * })
     * 
     */
    delete<T extends campaignTypeDeleteArgs>(args: SelectSubset<T, campaignTypeDeleteArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignType.
     * @param {campaignTypeUpdateArgs} args - Arguments to update one CampaignType.
     * @example
     * // Update one CampaignType
     * const campaignType = await prisma.campaignType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaignTypeUpdateArgs>(args: SelectSubset<T, campaignTypeUpdateArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignTypes.
     * @param {campaignTypeDeleteManyArgs} args - Arguments to filter CampaignTypes to delete.
     * @example
     * // Delete a few CampaignTypes
     * const { count } = await prisma.campaignType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaignTypeDeleteManyArgs>(args?: SelectSubset<T, campaignTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTypes
     * const campaignType = await prisma.campaignType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaignTypeUpdateManyArgs>(args: SelectSubset<T, campaignTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTypes and returns the data updated in the database.
     * @param {campaignTypeUpdateManyAndReturnArgs} args - Arguments to update many CampaignTypes.
     * @example
     * // Update many CampaignTypes
     * const campaignType = await prisma.campaignType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignTypes and only return the `id`
     * const campaignTypeWithIdOnly = await prisma.campaignType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campaignTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, campaignTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignType.
     * @param {campaignTypeUpsertArgs} args - Arguments to update or create a CampaignType.
     * @example
     * // Update or create a CampaignType
     * const campaignType = await prisma.campaignType.upsert({
     *   create: {
     *     // ... data to create a CampaignType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignType we want to update
     *   }
     * })
     */
    upsert<T extends campaignTypeUpsertArgs>(args: SelectSubset<T, campaignTypeUpsertArgs<ExtArgs>>): Prisma__campaignTypeClient<$Result.GetResult<Prisma.$campaignTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignTypeCountArgs} args - Arguments to filter CampaignTypes to count.
     * @example
     * // Count the number of CampaignTypes
     * const count = await prisma.campaignType.count({
     *   where: {
     *     // ... the filter for the CampaignTypes we want to count
     *   }
     * })
    **/
    count<T extends campaignTypeCountArgs>(
      args?: Subset<T, campaignTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTypeAggregateArgs>(args: Subset<T, CampaignTypeAggregateArgs>): Prisma.PrismaPromise<GetCampaignTypeAggregateType<T>>

    /**
     * Group by CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaignTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaignTypeGroupByArgs['orderBy'] }
        : { orderBy?: campaignTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaignTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaignType model
   */
  readonly fields: campaignTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaignType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaignTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaignType model
   */
  interface campaignTypeFieldRefs {
    readonly id: FieldRef<"campaignType", 'Int'>
    readonly name: FieldRef<"campaignType", 'String'>
    readonly campaignId: FieldRef<"campaignType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * campaignType findUnique
   */
  export type campaignTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * Filter, which campaignType to fetch.
     */
    where: campaignTypeWhereUniqueInput
  }

  /**
   * campaignType findUniqueOrThrow
   */
  export type campaignTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * Filter, which campaignType to fetch.
     */
    where: campaignTypeWhereUniqueInput
  }

  /**
   * campaignType findFirst
   */
  export type campaignTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * Filter, which campaignType to fetch.
     */
    where?: campaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignTypes to fetch.
     */
    orderBy?: campaignTypeOrderByWithRelationInput | campaignTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaignTypes.
     */
    cursor?: campaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaignTypes.
     */
    distinct?: CampaignTypeScalarFieldEnum | CampaignTypeScalarFieldEnum[]
  }

  /**
   * campaignType findFirstOrThrow
   */
  export type campaignTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * Filter, which campaignType to fetch.
     */
    where?: campaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignTypes to fetch.
     */
    orderBy?: campaignTypeOrderByWithRelationInput | campaignTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaignTypes.
     */
    cursor?: campaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaignTypes.
     */
    distinct?: CampaignTypeScalarFieldEnum | CampaignTypeScalarFieldEnum[]
  }

  /**
   * campaignType findMany
   */
  export type campaignTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * Filter, which campaignTypes to fetch.
     */
    where?: campaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignTypes to fetch.
     */
    orderBy?: campaignTypeOrderByWithRelationInput | campaignTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaignTypes.
     */
    cursor?: campaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignTypes.
     */
    skip?: number
    distinct?: CampaignTypeScalarFieldEnum | CampaignTypeScalarFieldEnum[]
  }

  /**
   * campaignType create
   */
  export type campaignTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a campaignType.
     */
    data: XOR<campaignTypeCreateInput, campaignTypeUncheckedCreateInput>
  }

  /**
   * campaignType createMany
   */
  export type campaignTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaignTypes.
     */
    data: campaignTypeCreateManyInput | campaignTypeCreateManyInput[]
  }

  /**
   * campaignType createManyAndReturn
   */
  export type campaignTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * The data used to create many campaignTypes.
     */
    data: campaignTypeCreateManyInput | campaignTypeCreateManyInput[]
  }

  /**
   * campaignType update
   */
  export type campaignTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a campaignType.
     */
    data: XOR<campaignTypeUpdateInput, campaignTypeUncheckedUpdateInput>
    /**
     * Choose, which campaignType to update.
     */
    where: campaignTypeWhereUniqueInput
  }

  /**
   * campaignType updateMany
   */
  export type campaignTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaignTypes.
     */
    data: XOR<campaignTypeUpdateManyMutationInput, campaignTypeUncheckedUpdateManyInput>
    /**
     * Filter which campaignTypes to update
     */
    where?: campaignTypeWhereInput
    /**
     * Limit how many campaignTypes to update.
     */
    limit?: number
  }

  /**
   * campaignType updateManyAndReturn
   */
  export type campaignTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * The data used to update campaignTypes.
     */
    data: XOR<campaignTypeUpdateManyMutationInput, campaignTypeUncheckedUpdateManyInput>
    /**
     * Filter which campaignTypes to update
     */
    where?: campaignTypeWhereInput
    /**
     * Limit how many campaignTypes to update.
     */
    limit?: number
  }

  /**
   * campaignType upsert
   */
  export type campaignTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the campaignType to update in case it exists.
     */
    where: campaignTypeWhereUniqueInput
    /**
     * In case the campaignType found by the `where` argument doesn't exist, create a new campaignType with this data.
     */
    create: XOR<campaignTypeCreateInput, campaignTypeUncheckedCreateInput>
    /**
     * In case the campaignType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaignTypeUpdateInput, campaignTypeUncheckedUpdateInput>
  }

  /**
   * campaignType delete
   */
  export type campaignTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
    /**
     * Filter which campaignType to delete.
     */
    where: campaignTypeWhereUniqueInput
  }

  /**
   * campaignType deleteMany
   */
  export type campaignTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaignTypes to delete
     */
    where?: campaignTypeWhereInput
    /**
     * Limit how many campaignTypes to delete.
     */
    limit?: number
  }

  /**
   * campaignType without action
   */
  export type campaignTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignType
     */
    select?: campaignTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignType
     */
    omit?: campaignTypeOmit<ExtArgs> | null
  }


  /**
   * Model volume
   */

  export type AggregateVolume = {
    _count: VolumeCountAggregateOutputType | null
    _avg: VolumeAvgAggregateOutputType | null
    _sum: VolumeSumAggregateOutputType | null
    _min: VolumeMinAggregateOutputType | null
    _max: VolumeMaxAggregateOutputType | null
  }

  export type VolumeAvgAggregateOutputType = {
    id: number | null
    campaignId: number | null
    leadGoal: number | null
    completed: number | null
    pending: number | null
  }

  export type VolumeSumAggregateOutputType = {
    id: number | null
    campaignId: number | null
    leadGoal: number | null
    completed: number | null
    pending: number | null
  }

  export type VolumeMinAggregateOutputType = {
    id: number | null
    name: string | null
    campaignId: number | null
    leadGoal: number | null
    completed: number | null
    pending: number | null
    status: $Enums.VolumeStatus | null
    leadTemplate: string | null
    externalRules: string | null
  }

  export type VolumeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    campaignId: number | null
    leadGoal: number | null
    completed: number | null
    pending: number | null
    status: $Enums.VolumeStatus | null
    leadTemplate: string | null
    externalRules: string | null
  }

  export type VolumeCountAggregateOutputType = {
    id: number
    name: number
    campaignId: number
    leadGoal: number
    completed: number
    pending: number
    status: number
    validationProfile: number
    headers: number
    leadTemplate: number
    externalRules: number
    _all: number
  }


  export type VolumeAvgAggregateInputType = {
    id?: true
    campaignId?: true
    leadGoal?: true
    completed?: true
    pending?: true
  }

  export type VolumeSumAggregateInputType = {
    id?: true
    campaignId?: true
    leadGoal?: true
    completed?: true
    pending?: true
  }

  export type VolumeMinAggregateInputType = {
    id?: true
    name?: true
    campaignId?: true
    leadGoal?: true
    completed?: true
    pending?: true
    status?: true
    leadTemplate?: true
    externalRules?: true
  }

  export type VolumeMaxAggregateInputType = {
    id?: true
    name?: true
    campaignId?: true
    leadGoal?: true
    completed?: true
    pending?: true
    status?: true
    leadTemplate?: true
    externalRules?: true
  }

  export type VolumeCountAggregateInputType = {
    id?: true
    name?: true
    campaignId?: true
    leadGoal?: true
    completed?: true
    pending?: true
    status?: true
    validationProfile?: true
    headers?: true
    leadTemplate?: true
    externalRules?: true
    _all?: true
  }

  export type VolumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which volume to aggregate.
     */
    where?: volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volumes to fetch.
     */
    orderBy?: volumeOrderByWithRelationInput | volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned volumes
    **/
    _count?: true | VolumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolumeMaxAggregateInputType
  }

  export type GetVolumeAggregateType<T extends VolumeAggregateArgs> = {
        [P in keyof T & keyof AggregateVolume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolume[P]>
      : GetScalarType<T[P], AggregateVolume[P]>
  }




  export type volumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: volumeWhereInput
    orderBy?: volumeOrderByWithAggregationInput | volumeOrderByWithAggregationInput[]
    by: VolumeScalarFieldEnum[] | VolumeScalarFieldEnum
    having?: volumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolumeCountAggregateInputType | true
    _avg?: VolumeAvgAggregateInputType
    _sum?: VolumeSumAggregateInputType
    _min?: VolumeMinAggregateInputType
    _max?: VolumeMaxAggregateInputType
  }

  export type VolumeGroupByOutputType = {
    id: number
    name: string
    campaignId: number
    leadGoal: number
    completed: number
    pending: number
    status: $Enums.VolumeStatus
    validationProfile: JsonValue
    headers: JsonValue
    leadTemplate: string
    externalRules: string
    _count: VolumeCountAggregateOutputType | null
    _avg: VolumeAvgAggregateOutputType | null
    _sum: VolumeSumAggregateOutputType | null
    _min: VolumeMinAggregateOutputType | null
    _max: VolumeMaxAggregateOutputType | null
  }

  type GetVolumeGroupByPayload<T extends volumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolumeGroupByOutputType[P]>
            : GetScalarType<T[P], VolumeGroupByOutputType[P]>
        }
      >
    >


  export type volumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    campaignId?: boolean
    leadGoal?: boolean
    completed?: boolean
    pending?: boolean
    status?: boolean
    validationProfile?: boolean
    headers?: boolean
    leadTemplate?: boolean
    externalRules?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacings?: boolean | volume$pacingsArgs<ExtArgs>
    leads?: boolean | volume$leadsArgs<ExtArgs>
    _count?: boolean | VolumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volume"]>

  export type volumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    campaignId?: boolean
    leadGoal?: boolean
    completed?: boolean
    pending?: boolean
    status?: boolean
    validationProfile?: boolean
    headers?: boolean
    leadTemplate?: boolean
    externalRules?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volume"]>

  export type volumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    campaignId?: boolean
    leadGoal?: boolean
    completed?: boolean
    pending?: boolean
    status?: boolean
    validationProfile?: boolean
    headers?: boolean
    leadTemplate?: boolean
    externalRules?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volume"]>

  export type volumeSelectScalar = {
    id?: boolean
    name?: boolean
    campaignId?: boolean
    leadGoal?: boolean
    completed?: boolean
    pending?: boolean
    status?: boolean
    validationProfile?: boolean
    headers?: boolean
    leadTemplate?: boolean
    externalRules?: boolean
  }

  export type volumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "campaignId" | "leadGoal" | "completed" | "pending" | "status" | "validationProfile" | "headers" | "leadTemplate" | "externalRules", ExtArgs["result"]["volume"]>
  export type volumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacings?: boolean | volume$pacingsArgs<ExtArgs>
    leads?: boolean | volume$leadsArgs<ExtArgs>
    _count?: boolean | VolumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type volumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
  }
  export type volumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
  }

  export type $volumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "volume"
    objects: {
      campaign: Prisma.$campaignPayload<ExtArgs>
      pacings: Prisma.$pacingPayload<ExtArgs>[]
      leads: Prisma.$leadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      campaignId: number
      leadGoal: number
      completed: number
      pending: number
      status: $Enums.VolumeStatus
      validationProfile: Prisma.JsonValue
      headers: Prisma.JsonValue
      leadTemplate: string
      externalRules: string
    }, ExtArgs["result"]["volume"]>
    composites: {}
  }

  type volumeGetPayload<S extends boolean | null | undefined | volumeDefaultArgs> = $Result.GetResult<Prisma.$volumePayload, S>

  type volumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<volumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VolumeCountAggregateInputType | true
    }

  export interface volumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['volume'], meta: { name: 'volume' } }
    /**
     * Find zero or one Volume that matches the filter.
     * @param {volumeFindUniqueArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends volumeFindUniqueArgs>(args: SelectSubset<T, volumeFindUniqueArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Volume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {volumeFindUniqueOrThrowArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends volumeFindUniqueOrThrowArgs>(args: SelectSubset<T, volumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volumeFindFirstArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends volumeFindFirstArgs>(args?: SelectSubset<T, volumeFindFirstArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volumeFindFirstOrThrowArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends volumeFindFirstOrThrowArgs>(args?: SelectSubset<T, volumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Volumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Volumes
     * const volumes = await prisma.volume.findMany()
     * 
     * // Get first 10 Volumes
     * const volumes = await prisma.volume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volumeWithIdOnly = await prisma.volume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends volumeFindManyArgs>(args?: SelectSubset<T, volumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Volume.
     * @param {volumeCreateArgs} args - Arguments to create a Volume.
     * @example
     * // Create one Volume
     * const Volume = await prisma.volume.create({
     *   data: {
     *     // ... data to create a Volume
     *   }
     * })
     * 
     */
    create<T extends volumeCreateArgs>(args: SelectSubset<T, volumeCreateArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Volumes.
     * @param {volumeCreateManyArgs} args - Arguments to create many Volumes.
     * @example
     * // Create many Volumes
     * const volume = await prisma.volume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends volumeCreateManyArgs>(args?: SelectSubset<T, volumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Volumes and returns the data saved in the database.
     * @param {volumeCreateManyAndReturnArgs} args - Arguments to create many Volumes.
     * @example
     * // Create many Volumes
     * const volume = await prisma.volume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Volumes and only return the `id`
     * const volumeWithIdOnly = await prisma.volume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends volumeCreateManyAndReturnArgs>(args?: SelectSubset<T, volumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Volume.
     * @param {volumeDeleteArgs} args - Arguments to delete one Volume.
     * @example
     * // Delete one Volume
     * const Volume = await prisma.volume.delete({
     *   where: {
     *     // ... filter to delete one Volume
     *   }
     * })
     * 
     */
    delete<T extends volumeDeleteArgs>(args: SelectSubset<T, volumeDeleteArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Volume.
     * @param {volumeUpdateArgs} args - Arguments to update one Volume.
     * @example
     * // Update one Volume
     * const volume = await prisma.volume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends volumeUpdateArgs>(args: SelectSubset<T, volumeUpdateArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Volumes.
     * @param {volumeDeleteManyArgs} args - Arguments to filter Volumes to delete.
     * @example
     * // Delete a few Volumes
     * const { count } = await prisma.volume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends volumeDeleteManyArgs>(args?: SelectSubset<T, volumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Volumes
     * const volume = await prisma.volume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends volumeUpdateManyArgs>(args: SelectSubset<T, volumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volumes and returns the data updated in the database.
     * @param {volumeUpdateManyAndReturnArgs} args - Arguments to update many Volumes.
     * @example
     * // Update many Volumes
     * const volume = await prisma.volume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Volumes and only return the `id`
     * const volumeWithIdOnly = await prisma.volume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends volumeUpdateManyAndReturnArgs>(args: SelectSubset<T, volumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Volume.
     * @param {volumeUpsertArgs} args - Arguments to update or create a Volume.
     * @example
     * // Update or create a Volume
     * const volume = await prisma.volume.upsert({
     *   create: {
     *     // ... data to create a Volume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Volume we want to update
     *   }
     * })
     */
    upsert<T extends volumeUpsertArgs>(args: SelectSubset<T, volumeUpsertArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volumeCountArgs} args - Arguments to filter Volumes to count.
     * @example
     * // Count the number of Volumes
     * const count = await prisma.volume.count({
     *   where: {
     *     // ... the filter for the Volumes we want to count
     *   }
     * })
    **/
    count<T extends volumeCountArgs>(
      args?: Subset<T, volumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolumeAggregateArgs>(args: Subset<T, VolumeAggregateArgs>): Prisma.PrismaPromise<GetVolumeAggregateType<T>>

    /**
     * Group by Volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends volumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: volumeGroupByArgs['orderBy'] }
        : { orderBy?: volumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, volumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the volume model
   */
  readonly fields: volumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for volume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__volumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends campaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignDefaultArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pacings<T extends volume$pacingsArgs<ExtArgs> = {}>(args?: Subset<T, volume$pacingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends volume$leadsArgs<ExtArgs> = {}>(args?: Subset<T, volume$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the volume model
   */
  interface volumeFieldRefs {
    readonly id: FieldRef<"volume", 'Int'>
    readonly name: FieldRef<"volume", 'String'>
    readonly campaignId: FieldRef<"volume", 'Int'>
    readonly leadGoal: FieldRef<"volume", 'Int'>
    readonly completed: FieldRef<"volume", 'Int'>
    readonly pending: FieldRef<"volume", 'Int'>
    readonly status: FieldRef<"volume", 'VolumeStatus'>
    readonly validationProfile: FieldRef<"volume", 'Json'>
    readonly headers: FieldRef<"volume", 'Json'>
    readonly leadTemplate: FieldRef<"volume", 'String'>
    readonly externalRules: FieldRef<"volume", 'String'>
  }
    

  // Custom InputTypes
  /**
   * volume findUnique
   */
  export type volumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * Filter, which volume to fetch.
     */
    where: volumeWhereUniqueInput
  }

  /**
   * volume findUniqueOrThrow
   */
  export type volumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * Filter, which volume to fetch.
     */
    where: volumeWhereUniqueInput
  }

  /**
   * volume findFirst
   */
  export type volumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * Filter, which volume to fetch.
     */
    where?: volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volumes to fetch.
     */
    orderBy?: volumeOrderByWithRelationInput | volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for volumes.
     */
    cursor?: volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of volumes.
     */
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * volume findFirstOrThrow
   */
  export type volumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * Filter, which volume to fetch.
     */
    where?: volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volumes to fetch.
     */
    orderBy?: volumeOrderByWithRelationInput | volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for volumes.
     */
    cursor?: volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of volumes.
     */
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * volume findMany
   */
  export type volumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * Filter, which volumes to fetch.
     */
    where?: volumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volumes to fetch.
     */
    orderBy?: volumeOrderByWithRelationInput | volumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing volumes.
     */
    cursor?: volumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volumes.
     */
    skip?: number
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * volume create
   */
  export type volumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * The data needed to create a volume.
     */
    data: XOR<volumeCreateInput, volumeUncheckedCreateInput>
  }

  /**
   * volume createMany
   */
  export type volumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many volumes.
     */
    data: volumeCreateManyInput | volumeCreateManyInput[]
  }

  /**
   * volume createManyAndReturn
   */
  export type volumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * The data used to create many volumes.
     */
    data: volumeCreateManyInput | volumeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * volume update
   */
  export type volumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * The data needed to update a volume.
     */
    data: XOR<volumeUpdateInput, volumeUncheckedUpdateInput>
    /**
     * Choose, which volume to update.
     */
    where: volumeWhereUniqueInput
  }

  /**
   * volume updateMany
   */
  export type volumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update volumes.
     */
    data: XOR<volumeUpdateManyMutationInput, volumeUncheckedUpdateManyInput>
    /**
     * Filter which volumes to update
     */
    where?: volumeWhereInput
    /**
     * Limit how many volumes to update.
     */
    limit?: number
  }

  /**
   * volume updateManyAndReturn
   */
  export type volumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * The data used to update volumes.
     */
    data: XOR<volumeUpdateManyMutationInput, volumeUncheckedUpdateManyInput>
    /**
     * Filter which volumes to update
     */
    where?: volumeWhereInput
    /**
     * Limit how many volumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * volume upsert
   */
  export type volumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * The filter to search for the volume to update in case it exists.
     */
    where: volumeWhereUniqueInput
    /**
     * In case the volume found by the `where` argument doesn't exist, create a new volume with this data.
     */
    create: XOR<volumeCreateInput, volumeUncheckedCreateInput>
    /**
     * In case the volume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<volumeUpdateInput, volumeUncheckedUpdateInput>
  }

  /**
   * volume delete
   */
  export type volumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
    /**
     * Filter which volume to delete.
     */
    where: volumeWhereUniqueInput
  }

  /**
   * volume deleteMany
   */
  export type volumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which volumes to delete
     */
    where?: volumeWhereInput
    /**
     * Limit how many volumes to delete.
     */
    limit?: number
  }

  /**
   * volume.pacings
   */
  export type volume$pacingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    where?: pacingWhereInput
    orderBy?: pacingOrderByWithRelationInput | pacingOrderByWithRelationInput[]
    cursor?: pacingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacingScalarFieldEnum | PacingScalarFieldEnum[]
  }

  /**
   * volume.leads
   */
  export type volume$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    where?: leadWhereInput
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    cursor?: leadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * volume without action
   */
  export type volumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volume
     */
    select?: volumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volume
     */
    omit?: volumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volumeInclude<ExtArgs> | null
  }


  /**
   * Model Brief
   */

  export type AggregateBrief = {
    _count: BriefCountAggregateOutputType | null
    _avg: BriefAvgAggregateOutputType | null
    _sum: BriefSumAggregateOutputType | null
    _min: BriefMinAggregateOutputType | null
    _max: BriefMaxAggregateOutputType | null
  }

  export type BriefAvgAggregateOutputType = {
    id: number | null
    campaignId: number | null
  }

  export type BriefSumAggregateOutputType = {
    id: number | null
    campaignId: number | null
  }

  export type BriefMinAggregateOutputType = {
    id: number | null
    name: string | null
    arrivedOn: Date | null
    arrivedOnTime: string | null
    dueTime: string | null
    due: Date | null
    status: $Enums.BriefStatus | null
    leadDetailsSection: string | null
    type: $Enums.BriefType | null
    campaignId: number | null
    remark: string | null
    briefHyperlink: string | null
  }

  export type BriefMaxAggregateOutputType = {
    id: number | null
    name: string | null
    arrivedOn: Date | null
    arrivedOnTime: string | null
    dueTime: string | null
    due: Date | null
    status: $Enums.BriefStatus | null
    leadDetailsSection: string | null
    type: $Enums.BriefType | null
    campaignId: number | null
    remark: string | null
    briefHyperlink: string | null
  }

  export type BriefCountAggregateOutputType = {
    id: number
    name: number
    arrivedOn: number
    arrivedOnTime: number
    dueTime: number
    due: number
    status: number
    leadDetails: number
    leadDetailsSection: number
    type: number
    quotes: number
    campaignId: number
    remark: number
    briefHyperlink: number
    _all: number
  }


  export type BriefAvgAggregateInputType = {
    id?: true
    campaignId?: true
  }

  export type BriefSumAggregateInputType = {
    id?: true
    campaignId?: true
  }

  export type BriefMinAggregateInputType = {
    id?: true
    name?: true
    arrivedOn?: true
    arrivedOnTime?: true
    dueTime?: true
    due?: true
    status?: true
    leadDetailsSection?: true
    type?: true
    campaignId?: true
    remark?: true
    briefHyperlink?: true
  }

  export type BriefMaxAggregateInputType = {
    id?: true
    name?: true
    arrivedOn?: true
    arrivedOnTime?: true
    dueTime?: true
    due?: true
    status?: true
    leadDetailsSection?: true
    type?: true
    campaignId?: true
    remark?: true
    briefHyperlink?: true
  }

  export type BriefCountAggregateInputType = {
    id?: true
    name?: true
    arrivedOn?: true
    arrivedOnTime?: true
    dueTime?: true
    due?: true
    status?: true
    leadDetails?: true
    leadDetailsSection?: true
    type?: true
    quotes?: true
    campaignId?: true
    remark?: true
    briefHyperlink?: true
    _all?: true
  }

  export type BriefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brief to aggregate.
     */
    where?: BriefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Briefs to fetch.
     */
    orderBy?: BriefOrderByWithRelationInput | BriefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BriefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Briefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Briefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Briefs
    **/
    _count?: true | BriefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BriefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BriefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BriefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BriefMaxAggregateInputType
  }

  export type GetBriefAggregateType<T extends BriefAggregateArgs> = {
        [P in keyof T & keyof AggregateBrief]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrief[P]>
      : GetScalarType<T[P], AggregateBrief[P]>
  }




  export type BriefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BriefWhereInput
    orderBy?: BriefOrderByWithAggregationInput | BriefOrderByWithAggregationInput[]
    by: BriefScalarFieldEnum[] | BriefScalarFieldEnum
    having?: BriefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BriefCountAggregateInputType | true
    _avg?: BriefAvgAggregateInputType
    _sum?: BriefSumAggregateInputType
    _min?: BriefMinAggregateInputType
    _max?: BriefMaxAggregateInputType
  }

  export type BriefGroupByOutputType = {
    id: number
    name: string
    arrivedOn: Date
    arrivedOnTime: string
    dueTime: string
    due: Date
    status: $Enums.BriefStatus
    leadDetails: JsonValue | null
    leadDetailsSection: string
    type: $Enums.BriefType
    quotes: JsonValue | null
    campaignId: number | null
    remark: string | null
    briefHyperlink: string | null
    _count: BriefCountAggregateOutputType | null
    _avg: BriefAvgAggregateOutputType | null
    _sum: BriefSumAggregateOutputType | null
    _min: BriefMinAggregateOutputType | null
    _max: BriefMaxAggregateOutputType | null
  }

  type GetBriefGroupByPayload<T extends BriefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BriefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BriefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BriefGroupByOutputType[P]>
            : GetScalarType<T[P], BriefGroupByOutputType[P]>
        }
      >
    >


  export type BriefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    arrivedOn?: boolean
    arrivedOnTime?: boolean
    dueTime?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    leadDetailsSection?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
    briefUpdates?: boolean | Brief$briefUpdatesArgs<ExtArgs>
    _count?: boolean | BriefCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brief"]>

  export type BriefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    arrivedOn?: boolean
    arrivedOnTime?: boolean
    dueTime?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    leadDetailsSection?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
  }, ExtArgs["result"]["brief"]>

  export type BriefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    arrivedOn?: boolean
    arrivedOnTime?: boolean
    dueTime?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    leadDetailsSection?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
  }, ExtArgs["result"]["brief"]>

  export type BriefSelectScalar = {
    id?: boolean
    name?: boolean
    arrivedOn?: boolean
    arrivedOnTime?: boolean
    dueTime?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    leadDetailsSection?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
  }

  export type BriefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "arrivedOn" | "arrivedOnTime" | "dueTime" | "due" | "status" | "leadDetails" | "leadDetailsSection" | "type" | "quotes" | "campaignId" | "remark" | "briefHyperlink", ExtArgs["result"]["brief"]>
  export type BriefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    briefUpdates?: boolean | Brief$briefUpdatesArgs<ExtArgs>
    _count?: boolean | BriefCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BriefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BriefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BriefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brief"
    objects: {
      briefUpdates: Prisma.$BriefUpdatesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      arrivedOn: Date
      arrivedOnTime: string
      dueTime: string
      due: Date
      status: $Enums.BriefStatus
      leadDetails: Prisma.JsonValue | null
      leadDetailsSection: string
      type: $Enums.BriefType
      quotes: Prisma.JsonValue | null
      campaignId: number | null
      remark: string | null
      briefHyperlink: string | null
    }, ExtArgs["result"]["brief"]>
    composites: {}
  }

  type BriefGetPayload<S extends boolean | null | undefined | BriefDefaultArgs> = $Result.GetResult<Prisma.$BriefPayload, S>

  type BriefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BriefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BriefCountAggregateInputType | true
    }

  export interface BriefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brief'], meta: { name: 'Brief' } }
    /**
     * Find zero or one Brief that matches the filter.
     * @param {BriefFindUniqueArgs} args - Arguments to find a Brief
     * @example
     * // Get one Brief
     * const brief = await prisma.brief.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BriefFindUniqueArgs>(args: SelectSubset<T, BriefFindUniqueArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brief that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BriefFindUniqueOrThrowArgs} args - Arguments to find a Brief
     * @example
     * // Get one Brief
     * const brief = await prisma.brief.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BriefFindUniqueOrThrowArgs>(args: SelectSubset<T, BriefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brief that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefFindFirstArgs} args - Arguments to find a Brief
     * @example
     * // Get one Brief
     * const brief = await prisma.brief.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BriefFindFirstArgs>(args?: SelectSubset<T, BriefFindFirstArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brief that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefFindFirstOrThrowArgs} args - Arguments to find a Brief
     * @example
     * // Get one Brief
     * const brief = await prisma.brief.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BriefFindFirstOrThrowArgs>(args?: SelectSubset<T, BriefFindFirstOrThrowArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Briefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Briefs
     * const briefs = await prisma.brief.findMany()
     * 
     * // Get first 10 Briefs
     * const briefs = await prisma.brief.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const briefWithIdOnly = await prisma.brief.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BriefFindManyArgs>(args?: SelectSubset<T, BriefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brief.
     * @param {BriefCreateArgs} args - Arguments to create a Brief.
     * @example
     * // Create one Brief
     * const Brief = await prisma.brief.create({
     *   data: {
     *     // ... data to create a Brief
     *   }
     * })
     * 
     */
    create<T extends BriefCreateArgs>(args: SelectSubset<T, BriefCreateArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Briefs.
     * @param {BriefCreateManyArgs} args - Arguments to create many Briefs.
     * @example
     * // Create many Briefs
     * const brief = await prisma.brief.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BriefCreateManyArgs>(args?: SelectSubset<T, BriefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Briefs and returns the data saved in the database.
     * @param {BriefCreateManyAndReturnArgs} args - Arguments to create many Briefs.
     * @example
     * // Create many Briefs
     * const brief = await prisma.brief.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Briefs and only return the `id`
     * const briefWithIdOnly = await prisma.brief.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BriefCreateManyAndReturnArgs>(args?: SelectSubset<T, BriefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brief.
     * @param {BriefDeleteArgs} args - Arguments to delete one Brief.
     * @example
     * // Delete one Brief
     * const Brief = await prisma.brief.delete({
     *   where: {
     *     // ... filter to delete one Brief
     *   }
     * })
     * 
     */
    delete<T extends BriefDeleteArgs>(args: SelectSubset<T, BriefDeleteArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brief.
     * @param {BriefUpdateArgs} args - Arguments to update one Brief.
     * @example
     * // Update one Brief
     * const brief = await prisma.brief.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BriefUpdateArgs>(args: SelectSubset<T, BriefUpdateArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Briefs.
     * @param {BriefDeleteManyArgs} args - Arguments to filter Briefs to delete.
     * @example
     * // Delete a few Briefs
     * const { count } = await prisma.brief.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BriefDeleteManyArgs>(args?: SelectSubset<T, BriefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Briefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Briefs
     * const brief = await prisma.brief.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BriefUpdateManyArgs>(args: SelectSubset<T, BriefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Briefs and returns the data updated in the database.
     * @param {BriefUpdateManyAndReturnArgs} args - Arguments to update many Briefs.
     * @example
     * // Update many Briefs
     * const brief = await prisma.brief.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Briefs and only return the `id`
     * const briefWithIdOnly = await prisma.brief.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BriefUpdateManyAndReturnArgs>(args: SelectSubset<T, BriefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brief.
     * @param {BriefUpsertArgs} args - Arguments to update or create a Brief.
     * @example
     * // Update or create a Brief
     * const brief = await prisma.brief.upsert({
     *   create: {
     *     // ... data to create a Brief
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brief we want to update
     *   }
     * })
     */
    upsert<T extends BriefUpsertArgs>(args: SelectSubset<T, BriefUpsertArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Briefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefCountArgs} args - Arguments to filter Briefs to count.
     * @example
     * // Count the number of Briefs
     * const count = await prisma.brief.count({
     *   where: {
     *     // ... the filter for the Briefs we want to count
     *   }
     * })
    **/
    count<T extends BriefCountArgs>(
      args?: Subset<T, BriefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BriefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brief.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BriefAggregateArgs>(args: Subset<T, BriefAggregateArgs>): Prisma.PrismaPromise<GetBriefAggregateType<T>>

    /**
     * Group by Brief.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BriefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BriefGroupByArgs['orderBy'] }
        : { orderBy?: BriefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BriefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBriefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brief model
   */
  readonly fields: BriefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brief.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BriefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    briefUpdates<T extends Brief$briefUpdatesArgs<ExtArgs> = {}>(args?: Subset<T, Brief$briefUpdatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brief model
   */
  interface BriefFieldRefs {
    readonly id: FieldRef<"Brief", 'Int'>
    readonly name: FieldRef<"Brief", 'String'>
    readonly arrivedOn: FieldRef<"Brief", 'DateTime'>
    readonly arrivedOnTime: FieldRef<"Brief", 'String'>
    readonly dueTime: FieldRef<"Brief", 'String'>
    readonly due: FieldRef<"Brief", 'DateTime'>
    readonly status: FieldRef<"Brief", 'BriefStatus'>
    readonly leadDetails: FieldRef<"Brief", 'Json'>
    readonly leadDetailsSection: FieldRef<"Brief", 'String'>
    readonly type: FieldRef<"Brief", 'BriefType'>
    readonly quotes: FieldRef<"Brief", 'Json'>
    readonly campaignId: FieldRef<"Brief", 'Int'>
    readonly remark: FieldRef<"Brief", 'String'>
    readonly briefHyperlink: FieldRef<"Brief", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Brief findUnique
   */
  export type BriefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * Filter, which Brief to fetch.
     */
    where: BriefWhereUniqueInput
  }

  /**
   * Brief findUniqueOrThrow
   */
  export type BriefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * Filter, which Brief to fetch.
     */
    where: BriefWhereUniqueInput
  }

  /**
   * Brief findFirst
   */
  export type BriefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * Filter, which Brief to fetch.
     */
    where?: BriefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Briefs to fetch.
     */
    orderBy?: BriefOrderByWithRelationInput | BriefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Briefs.
     */
    cursor?: BriefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Briefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Briefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Briefs.
     */
    distinct?: BriefScalarFieldEnum | BriefScalarFieldEnum[]
  }

  /**
   * Brief findFirstOrThrow
   */
  export type BriefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * Filter, which Brief to fetch.
     */
    where?: BriefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Briefs to fetch.
     */
    orderBy?: BriefOrderByWithRelationInput | BriefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Briefs.
     */
    cursor?: BriefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Briefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Briefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Briefs.
     */
    distinct?: BriefScalarFieldEnum | BriefScalarFieldEnum[]
  }

  /**
   * Brief findMany
   */
  export type BriefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * Filter, which Briefs to fetch.
     */
    where?: BriefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Briefs to fetch.
     */
    orderBy?: BriefOrderByWithRelationInput | BriefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Briefs.
     */
    cursor?: BriefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Briefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Briefs.
     */
    skip?: number
    distinct?: BriefScalarFieldEnum | BriefScalarFieldEnum[]
  }

  /**
   * Brief create
   */
  export type BriefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * The data needed to create a Brief.
     */
    data: XOR<BriefCreateInput, BriefUncheckedCreateInput>
  }

  /**
   * Brief createMany
   */
  export type BriefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Briefs.
     */
    data: BriefCreateManyInput | BriefCreateManyInput[]
  }

  /**
   * Brief createManyAndReturn
   */
  export type BriefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * The data used to create many Briefs.
     */
    data: BriefCreateManyInput | BriefCreateManyInput[]
  }

  /**
   * Brief update
   */
  export type BriefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * The data needed to update a Brief.
     */
    data: XOR<BriefUpdateInput, BriefUncheckedUpdateInput>
    /**
     * Choose, which Brief to update.
     */
    where: BriefWhereUniqueInput
  }

  /**
   * Brief updateMany
   */
  export type BriefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Briefs.
     */
    data: XOR<BriefUpdateManyMutationInput, BriefUncheckedUpdateManyInput>
    /**
     * Filter which Briefs to update
     */
    where?: BriefWhereInput
    /**
     * Limit how many Briefs to update.
     */
    limit?: number
  }

  /**
   * Brief updateManyAndReturn
   */
  export type BriefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * The data used to update Briefs.
     */
    data: XOR<BriefUpdateManyMutationInput, BriefUncheckedUpdateManyInput>
    /**
     * Filter which Briefs to update
     */
    where?: BriefWhereInput
    /**
     * Limit how many Briefs to update.
     */
    limit?: number
  }

  /**
   * Brief upsert
   */
  export type BriefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * The filter to search for the Brief to update in case it exists.
     */
    where: BriefWhereUniqueInput
    /**
     * In case the Brief found by the `where` argument doesn't exist, create a new Brief with this data.
     */
    create: XOR<BriefCreateInput, BriefUncheckedCreateInput>
    /**
     * In case the Brief was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BriefUpdateInput, BriefUncheckedUpdateInput>
  }

  /**
   * Brief delete
   */
  export type BriefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
    /**
     * Filter which Brief to delete.
     */
    where: BriefWhereUniqueInput
  }

  /**
   * Brief deleteMany
   */
  export type BriefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Briefs to delete
     */
    where?: BriefWhereInput
    /**
     * Limit how many Briefs to delete.
     */
    limit?: number
  }

  /**
   * Brief.briefUpdates
   */
  export type Brief$briefUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    where?: BriefUpdatesWhereInput
    orderBy?: BriefUpdatesOrderByWithRelationInput | BriefUpdatesOrderByWithRelationInput[]
    cursor?: BriefUpdatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BriefUpdatesScalarFieldEnum | BriefUpdatesScalarFieldEnum[]
  }

  /**
   * Brief without action
   */
  export type BriefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brief
     */
    select?: BriefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brief
     */
    omit?: BriefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefInclude<ExtArgs> | null
  }


  /**
   * Model BriefUpdates
   */

  export type AggregateBriefUpdates = {
    _count: BriefUpdatesCountAggregateOutputType | null
    _avg: BriefUpdatesAvgAggregateOutputType | null
    _sum: BriefUpdatesSumAggregateOutputType | null
    _min: BriefUpdatesMinAggregateOutputType | null
    _max: BriefUpdatesMaxAggregateOutputType | null
  }

  export type BriefUpdatesAvgAggregateOutputType = {
    id: number | null
    briefId: number | null
    campaignId: number | null
  }

  export type BriefUpdatesSumAggregateOutputType = {
    id: number | null
    briefId: number | null
    campaignId: number | null
  }

  export type BriefUpdatesMinAggregateOutputType = {
    id: number | null
    briefId: number | null
    arrivedOn: Date | null
    due: Date | null
    status: $Enums.BriefStatus | null
    type: $Enums.BriefType | null
    campaignId: number | null
    remark: string | null
    briefHyperlink: string | null
  }

  export type BriefUpdatesMaxAggregateOutputType = {
    id: number | null
    briefId: number | null
    arrivedOn: Date | null
    due: Date | null
    status: $Enums.BriefStatus | null
    type: $Enums.BriefType | null
    campaignId: number | null
    remark: string | null
    briefHyperlink: string | null
  }

  export type BriefUpdatesCountAggregateOutputType = {
    id: number
    briefId: number
    arrivedOn: number
    due: number
    status: number
    leadDetails: number
    type: number
    quotes: number
    campaignId: number
    remark: number
    briefHyperlink: number
    _all: number
  }


  export type BriefUpdatesAvgAggregateInputType = {
    id?: true
    briefId?: true
    campaignId?: true
  }

  export type BriefUpdatesSumAggregateInputType = {
    id?: true
    briefId?: true
    campaignId?: true
  }

  export type BriefUpdatesMinAggregateInputType = {
    id?: true
    briefId?: true
    arrivedOn?: true
    due?: true
    status?: true
    type?: true
    campaignId?: true
    remark?: true
    briefHyperlink?: true
  }

  export type BriefUpdatesMaxAggregateInputType = {
    id?: true
    briefId?: true
    arrivedOn?: true
    due?: true
    status?: true
    type?: true
    campaignId?: true
    remark?: true
    briefHyperlink?: true
  }

  export type BriefUpdatesCountAggregateInputType = {
    id?: true
    briefId?: true
    arrivedOn?: true
    due?: true
    status?: true
    leadDetails?: true
    type?: true
    quotes?: true
    campaignId?: true
    remark?: true
    briefHyperlink?: true
    _all?: true
  }

  export type BriefUpdatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BriefUpdates to aggregate.
     */
    where?: BriefUpdatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BriefUpdates to fetch.
     */
    orderBy?: BriefUpdatesOrderByWithRelationInput | BriefUpdatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BriefUpdatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BriefUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BriefUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BriefUpdates
    **/
    _count?: true | BriefUpdatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BriefUpdatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BriefUpdatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BriefUpdatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BriefUpdatesMaxAggregateInputType
  }

  export type GetBriefUpdatesAggregateType<T extends BriefUpdatesAggregateArgs> = {
        [P in keyof T & keyof AggregateBriefUpdates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBriefUpdates[P]>
      : GetScalarType<T[P], AggregateBriefUpdates[P]>
  }




  export type BriefUpdatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BriefUpdatesWhereInput
    orderBy?: BriefUpdatesOrderByWithAggregationInput | BriefUpdatesOrderByWithAggregationInput[]
    by: BriefUpdatesScalarFieldEnum[] | BriefUpdatesScalarFieldEnum
    having?: BriefUpdatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BriefUpdatesCountAggregateInputType | true
    _avg?: BriefUpdatesAvgAggregateInputType
    _sum?: BriefUpdatesSumAggregateInputType
    _min?: BriefUpdatesMinAggregateInputType
    _max?: BriefUpdatesMaxAggregateInputType
  }

  export type BriefUpdatesGroupByOutputType = {
    id: number
    briefId: number
    arrivedOn: Date
    due: Date
    status: $Enums.BriefStatus
    leadDetails: JsonValue | null
    type: $Enums.BriefType
    quotes: JsonValue | null
    campaignId: number | null
    remark: string | null
    briefHyperlink: string | null
    _count: BriefUpdatesCountAggregateOutputType | null
    _avg: BriefUpdatesAvgAggregateOutputType | null
    _sum: BriefUpdatesSumAggregateOutputType | null
    _min: BriefUpdatesMinAggregateOutputType | null
    _max: BriefUpdatesMaxAggregateOutputType | null
  }

  type GetBriefUpdatesGroupByPayload<T extends BriefUpdatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BriefUpdatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BriefUpdatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BriefUpdatesGroupByOutputType[P]>
            : GetScalarType<T[P], BriefUpdatesGroupByOutputType[P]>
        }
      >
    >


  export type BriefUpdatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    briefId?: boolean
    arrivedOn?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
    breif?: boolean | BriefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["briefUpdates"]>

  export type BriefUpdatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    briefId?: boolean
    arrivedOn?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
    breif?: boolean | BriefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["briefUpdates"]>

  export type BriefUpdatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    briefId?: boolean
    arrivedOn?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
    breif?: boolean | BriefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["briefUpdates"]>

  export type BriefUpdatesSelectScalar = {
    id?: boolean
    briefId?: boolean
    arrivedOn?: boolean
    due?: boolean
    status?: boolean
    leadDetails?: boolean
    type?: boolean
    quotes?: boolean
    campaignId?: boolean
    remark?: boolean
    briefHyperlink?: boolean
  }

  export type BriefUpdatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "briefId" | "arrivedOn" | "due" | "status" | "leadDetails" | "type" | "quotes" | "campaignId" | "remark" | "briefHyperlink", ExtArgs["result"]["briefUpdates"]>
  export type BriefUpdatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breif?: boolean | BriefDefaultArgs<ExtArgs>
  }
  export type BriefUpdatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breif?: boolean | BriefDefaultArgs<ExtArgs>
  }
  export type BriefUpdatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breif?: boolean | BriefDefaultArgs<ExtArgs>
  }

  export type $BriefUpdatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BriefUpdates"
    objects: {
      breif: Prisma.$BriefPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      briefId: number
      arrivedOn: Date
      due: Date
      status: $Enums.BriefStatus
      leadDetails: Prisma.JsonValue | null
      type: $Enums.BriefType
      quotes: Prisma.JsonValue | null
      campaignId: number | null
      remark: string | null
      briefHyperlink: string | null
    }, ExtArgs["result"]["briefUpdates"]>
    composites: {}
  }

  type BriefUpdatesGetPayload<S extends boolean | null | undefined | BriefUpdatesDefaultArgs> = $Result.GetResult<Prisma.$BriefUpdatesPayload, S>

  type BriefUpdatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BriefUpdatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BriefUpdatesCountAggregateInputType | true
    }

  export interface BriefUpdatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BriefUpdates'], meta: { name: 'BriefUpdates' } }
    /**
     * Find zero or one BriefUpdates that matches the filter.
     * @param {BriefUpdatesFindUniqueArgs} args - Arguments to find a BriefUpdates
     * @example
     * // Get one BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BriefUpdatesFindUniqueArgs>(args: SelectSubset<T, BriefUpdatesFindUniqueArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BriefUpdates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BriefUpdatesFindUniqueOrThrowArgs} args - Arguments to find a BriefUpdates
     * @example
     * // Get one BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BriefUpdatesFindUniqueOrThrowArgs>(args: SelectSubset<T, BriefUpdatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BriefUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesFindFirstArgs} args - Arguments to find a BriefUpdates
     * @example
     * // Get one BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BriefUpdatesFindFirstArgs>(args?: SelectSubset<T, BriefUpdatesFindFirstArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BriefUpdates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesFindFirstOrThrowArgs} args - Arguments to find a BriefUpdates
     * @example
     * // Get one BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BriefUpdatesFindFirstOrThrowArgs>(args?: SelectSubset<T, BriefUpdatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BriefUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.findMany()
     * 
     * // Get first 10 BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const briefUpdatesWithIdOnly = await prisma.briefUpdates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BriefUpdatesFindManyArgs>(args?: SelectSubset<T, BriefUpdatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BriefUpdates.
     * @param {BriefUpdatesCreateArgs} args - Arguments to create a BriefUpdates.
     * @example
     * // Create one BriefUpdates
     * const BriefUpdates = await prisma.briefUpdates.create({
     *   data: {
     *     // ... data to create a BriefUpdates
     *   }
     * })
     * 
     */
    create<T extends BriefUpdatesCreateArgs>(args: SelectSubset<T, BriefUpdatesCreateArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BriefUpdates.
     * @param {BriefUpdatesCreateManyArgs} args - Arguments to create many BriefUpdates.
     * @example
     * // Create many BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BriefUpdatesCreateManyArgs>(args?: SelectSubset<T, BriefUpdatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BriefUpdates and returns the data saved in the database.
     * @param {BriefUpdatesCreateManyAndReturnArgs} args - Arguments to create many BriefUpdates.
     * @example
     * // Create many BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BriefUpdates and only return the `id`
     * const briefUpdatesWithIdOnly = await prisma.briefUpdates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BriefUpdatesCreateManyAndReturnArgs>(args?: SelectSubset<T, BriefUpdatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BriefUpdates.
     * @param {BriefUpdatesDeleteArgs} args - Arguments to delete one BriefUpdates.
     * @example
     * // Delete one BriefUpdates
     * const BriefUpdates = await prisma.briefUpdates.delete({
     *   where: {
     *     // ... filter to delete one BriefUpdates
     *   }
     * })
     * 
     */
    delete<T extends BriefUpdatesDeleteArgs>(args: SelectSubset<T, BriefUpdatesDeleteArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BriefUpdates.
     * @param {BriefUpdatesUpdateArgs} args - Arguments to update one BriefUpdates.
     * @example
     * // Update one BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BriefUpdatesUpdateArgs>(args: SelectSubset<T, BriefUpdatesUpdateArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BriefUpdates.
     * @param {BriefUpdatesDeleteManyArgs} args - Arguments to filter BriefUpdates to delete.
     * @example
     * // Delete a few BriefUpdates
     * const { count } = await prisma.briefUpdates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BriefUpdatesDeleteManyArgs>(args?: SelectSubset<T, BriefUpdatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BriefUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BriefUpdatesUpdateManyArgs>(args: SelectSubset<T, BriefUpdatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BriefUpdates and returns the data updated in the database.
     * @param {BriefUpdatesUpdateManyAndReturnArgs} args - Arguments to update many BriefUpdates.
     * @example
     * // Update many BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BriefUpdates and only return the `id`
     * const briefUpdatesWithIdOnly = await prisma.briefUpdates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BriefUpdatesUpdateManyAndReturnArgs>(args: SelectSubset<T, BriefUpdatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BriefUpdates.
     * @param {BriefUpdatesUpsertArgs} args - Arguments to update or create a BriefUpdates.
     * @example
     * // Update or create a BriefUpdates
     * const briefUpdates = await prisma.briefUpdates.upsert({
     *   create: {
     *     // ... data to create a BriefUpdates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BriefUpdates we want to update
     *   }
     * })
     */
    upsert<T extends BriefUpdatesUpsertArgs>(args: SelectSubset<T, BriefUpdatesUpsertArgs<ExtArgs>>): Prisma__BriefUpdatesClient<$Result.GetResult<Prisma.$BriefUpdatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BriefUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesCountArgs} args - Arguments to filter BriefUpdates to count.
     * @example
     * // Count the number of BriefUpdates
     * const count = await prisma.briefUpdates.count({
     *   where: {
     *     // ... the filter for the BriefUpdates we want to count
     *   }
     * })
    **/
    count<T extends BriefUpdatesCountArgs>(
      args?: Subset<T, BriefUpdatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BriefUpdatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BriefUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BriefUpdatesAggregateArgs>(args: Subset<T, BriefUpdatesAggregateArgs>): Prisma.PrismaPromise<GetBriefUpdatesAggregateType<T>>

    /**
     * Group by BriefUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BriefUpdatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BriefUpdatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BriefUpdatesGroupByArgs['orderBy'] }
        : { orderBy?: BriefUpdatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BriefUpdatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBriefUpdatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BriefUpdates model
   */
  readonly fields: BriefUpdatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BriefUpdates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BriefUpdatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    breif<T extends BriefDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BriefDefaultArgs<ExtArgs>>): Prisma__BriefClient<$Result.GetResult<Prisma.$BriefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BriefUpdates model
   */
  interface BriefUpdatesFieldRefs {
    readonly id: FieldRef<"BriefUpdates", 'Int'>
    readonly briefId: FieldRef<"BriefUpdates", 'Int'>
    readonly arrivedOn: FieldRef<"BriefUpdates", 'DateTime'>
    readonly due: FieldRef<"BriefUpdates", 'DateTime'>
    readonly status: FieldRef<"BriefUpdates", 'BriefStatus'>
    readonly leadDetails: FieldRef<"BriefUpdates", 'Json'>
    readonly type: FieldRef<"BriefUpdates", 'BriefType'>
    readonly quotes: FieldRef<"BriefUpdates", 'Json'>
    readonly campaignId: FieldRef<"BriefUpdates", 'Int'>
    readonly remark: FieldRef<"BriefUpdates", 'String'>
    readonly briefHyperlink: FieldRef<"BriefUpdates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BriefUpdates findUnique
   */
  export type BriefUpdatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * Filter, which BriefUpdates to fetch.
     */
    where: BriefUpdatesWhereUniqueInput
  }

  /**
   * BriefUpdates findUniqueOrThrow
   */
  export type BriefUpdatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * Filter, which BriefUpdates to fetch.
     */
    where: BriefUpdatesWhereUniqueInput
  }

  /**
   * BriefUpdates findFirst
   */
  export type BriefUpdatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * Filter, which BriefUpdates to fetch.
     */
    where?: BriefUpdatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BriefUpdates to fetch.
     */
    orderBy?: BriefUpdatesOrderByWithRelationInput | BriefUpdatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BriefUpdates.
     */
    cursor?: BriefUpdatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BriefUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BriefUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BriefUpdates.
     */
    distinct?: BriefUpdatesScalarFieldEnum | BriefUpdatesScalarFieldEnum[]
  }

  /**
   * BriefUpdates findFirstOrThrow
   */
  export type BriefUpdatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * Filter, which BriefUpdates to fetch.
     */
    where?: BriefUpdatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BriefUpdates to fetch.
     */
    orderBy?: BriefUpdatesOrderByWithRelationInput | BriefUpdatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BriefUpdates.
     */
    cursor?: BriefUpdatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BriefUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BriefUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BriefUpdates.
     */
    distinct?: BriefUpdatesScalarFieldEnum | BriefUpdatesScalarFieldEnum[]
  }

  /**
   * BriefUpdates findMany
   */
  export type BriefUpdatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * Filter, which BriefUpdates to fetch.
     */
    where?: BriefUpdatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BriefUpdates to fetch.
     */
    orderBy?: BriefUpdatesOrderByWithRelationInput | BriefUpdatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BriefUpdates.
     */
    cursor?: BriefUpdatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BriefUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BriefUpdates.
     */
    skip?: number
    distinct?: BriefUpdatesScalarFieldEnum | BriefUpdatesScalarFieldEnum[]
  }

  /**
   * BriefUpdates create
   */
  export type BriefUpdatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * The data needed to create a BriefUpdates.
     */
    data: XOR<BriefUpdatesCreateInput, BriefUpdatesUncheckedCreateInput>
  }

  /**
   * BriefUpdates createMany
   */
  export type BriefUpdatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BriefUpdates.
     */
    data: BriefUpdatesCreateManyInput | BriefUpdatesCreateManyInput[]
  }

  /**
   * BriefUpdates createManyAndReturn
   */
  export type BriefUpdatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * The data used to create many BriefUpdates.
     */
    data: BriefUpdatesCreateManyInput | BriefUpdatesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BriefUpdates update
   */
  export type BriefUpdatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * The data needed to update a BriefUpdates.
     */
    data: XOR<BriefUpdatesUpdateInput, BriefUpdatesUncheckedUpdateInput>
    /**
     * Choose, which BriefUpdates to update.
     */
    where: BriefUpdatesWhereUniqueInput
  }

  /**
   * BriefUpdates updateMany
   */
  export type BriefUpdatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BriefUpdates.
     */
    data: XOR<BriefUpdatesUpdateManyMutationInput, BriefUpdatesUncheckedUpdateManyInput>
    /**
     * Filter which BriefUpdates to update
     */
    where?: BriefUpdatesWhereInput
    /**
     * Limit how many BriefUpdates to update.
     */
    limit?: number
  }

  /**
   * BriefUpdates updateManyAndReturn
   */
  export type BriefUpdatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * The data used to update BriefUpdates.
     */
    data: XOR<BriefUpdatesUpdateManyMutationInput, BriefUpdatesUncheckedUpdateManyInput>
    /**
     * Filter which BriefUpdates to update
     */
    where?: BriefUpdatesWhereInput
    /**
     * Limit how many BriefUpdates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BriefUpdates upsert
   */
  export type BriefUpdatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * The filter to search for the BriefUpdates to update in case it exists.
     */
    where: BriefUpdatesWhereUniqueInput
    /**
     * In case the BriefUpdates found by the `where` argument doesn't exist, create a new BriefUpdates with this data.
     */
    create: XOR<BriefUpdatesCreateInput, BriefUpdatesUncheckedCreateInput>
    /**
     * In case the BriefUpdates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BriefUpdatesUpdateInput, BriefUpdatesUncheckedUpdateInput>
  }

  /**
   * BriefUpdates delete
   */
  export type BriefUpdatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
    /**
     * Filter which BriefUpdates to delete.
     */
    where: BriefUpdatesWhereUniqueInput
  }

  /**
   * BriefUpdates deleteMany
   */
  export type BriefUpdatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BriefUpdates to delete
     */
    where?: BriefUpdatesWhereInput
    /**
     * Limit how many BriefUpdates to delete.
     */
    limit?: number
  }

  /**
   * BriefUpdates without action
   */
  export type BriefUpdatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BriefUpdates
     */
    select?: BriefUpdatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BriefUpdates
     */
    omit?: BriefUpdatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BriefUpdatesInclude<ExtArgs> | null
  }


  /**
   * Model pacing
   */

  export type AggregatePacing = {
    _count: PacingCountAggregateOutputType | null
    _avg: PacingAvgAggregateOutputType | null
    _sum: PacingSumAggregateOutputType | null
    _min: PacingMinAggregateOutputType | null
    _max: PacingMaxAggregateOutputType | null
  }

  export type PacingAvgAggregateOutputType = {
    id: number | null
    volumeId: number | null
    leadGoal: number | null
    actualLeads: number | null
  }

  export type PacingSumAggregateOutputType = {
    id: number | null
    volumeId: number | null
    leadGoal: number | null
    actualLeads: number | null
  }

  export type PacingMinAggregateOutputType = {
    id: number | null
    volumeId: number | null
    scheduledFor: Date | null
    leadGoal: number | null
    status: string | null
    actualLeads: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PacingMaxAggregateOutputType = {
    id: number | null
    volumeId: number | null
    scheduledFor: Date | null
    leadGoal: number | null
    status: string | null
    actualLeads: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PacingCountAggregateOutputType = {
    id: number
    volumeId: number
    scheduledFor: number
    leadGoal: number
    status: number
    actualLeads: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PacingAvgAggregateInputType = {
    id?: true
    volumeId?: true
    leadGoal?: true
    actualLeads?: true
  }

  export type PacingSumAggregateInputType = {
    id?: true
    volumeId?: true
    leadGoal?: true
    actualLeads?: true
  }

  export type PacingMinAggregateInputType = {
    id?: true
    volumeId?: true
    scheduledFor?: true
    leadGoal?: true
    status?: true
    actualLeads?: true
    created_at?: true
    updated_at?: true
  }

  export type PacingMaxAggregateInputType = {
    id?: true
    volumeId?: true
    scheduledFor?: true
    leadGoal?: true
    status?: true
    actualLeads?: true
    created_at?: true
    updated_at?: true
  }

  export type PacingCountAggregateInputType = {
    id?: true
    volumeId?: true
    scheduledFor?: true
    leadGoal?: true
    status?: true
    actualLeads?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PacingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacing to aggregate.
     */
    where?: pacingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacings to fetch.
     */
    orderBy?: pacingOrderByWithRelationInput | pacingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pacingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pacings
    **/
    _count?: true | PacingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacingMaxAggregateInputType
  }

  export type GetPacingAggregateType<T extends PacingAggregateArgs> = {
        [P in keyof T & keyof AggregatePacing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePacing[P]>
      : GetScalarType<T[P], AggregatePacing[P]>
  }




  export type pacingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacingWhereInput
    orderBy?: pacingOrderByWithAggregationInput | pacingOrderByWithAggregationInput[]
    by: PacingScalarFieldEnum[] | PacingScalarFieldEnum
    having?: pacingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacingCountAggregateInputType | true
    _avg?: PacingAvgAggregateInputType
    _sum?: PacingSumAggregateInputType
    _min?: PacingMinAggregateInputType
    _max?: PacingMaxAggregateInputType
  }

  export type PacingGroupByOutputType = {
    id: number
    volumeId: number
    scheduledFor: Date
    leadGoal: number
    status: string
    actualLeads: number
    created_at: Date
    updated_at: Date
    _count: PacingCountAggregateOutputType | null
    _avg: PacingAvgAggregateOutputType | null
    _sum: PacingSumAggregateOutputType | null
    _min: PacingMinAggregateOutputType | null
    _max: PacingMaxAggregateOutputType | null
  }

  type GetPacingGroupByPayload<T extends pacingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacingGroupByOutputType[P]>
            : GetScalarType<T[P], PacingGroupByOutputType[P]>
        }
      >
    >


  export type pacingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volumeId?: boolean
    scheduledFor?: boolean
    leadGoal?: boolean
    status?: boolean
    actualLeads?: boolean
    created_at?: boolean
    updated_at?: boolean
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    leads?: boolean | pacing$leadsArgs<ExtArgs>
    uploads?: boolean | pacing$uploadsArgs<ExtArgs>
    _count?: boolean | PacingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacing"]>

  export type pacingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volumeId?: boolean
    scheduledFor?: boolean
    leadGoal?: boolean
    status?: boolean
    actualLeads?: boolean
    created_at?: boolean
    updated_at?: boolean
    volume?: boolean | volumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacing"]>

  export type pacingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volumeId?: boolean
    scheduledFor?: boolean
    leadGoal?: boolean
    status?: boolean
    actualLeads?: boolean
    created_at?: boolean
    updated_at?: boolean
    volume?: boolean | volumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacing"]>

  export type pacingSelectScalar = {
    id?: boolean
    volumeId?: boolean
    scheduledFor?: boolean
    leadGoal?: boolean
    status?: boolean
    actualLeads?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type pacingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volumeId" | "scheduledFor" | "leadGoal" | "status" | "actualLeads" | "created_at" | "updated_at", ExtArgs["result"]["pacing"]>
  export type pacingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    leads?: boolean | pacing$leadsArgs<ExtArgs>
    uploads?: boolean | pacing$uploadsArgs<ExtArgs>
    _count?: boolean | PacingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pacingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volume?: boolean | volumeDefaultArgs<ExtArgs>
  }
  export type pacingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volume?: boolean | volumeDefaultArgs<ExtArgs>
  }

  export type $pacingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pacing"
    objects: {
      volume: Prisma.$volumePayload<ExtArgs>
      leads: Prisma.$leadPayload<ExtArgs>[]
      uploads: Prisma.$leadsUploadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      volumeId: number
      scheduledFor: Date
      leadGoal: number
      status: string
      actualLeads: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["pacing"]>
    composites: {}
  }

  type pacingGetPayload<S extends boolean | null | undefined | pacingDefaultArgs> = $Result.GetResult<Prisma.$pacingPayload, S>

  type pacingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pacingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PacingCountAggregateInputType | true
    }

  export interface pacingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pacing'], meta: { name: 'pacing' } }
    /**
     * Find zero or one Pacing that matches the filter.
     * @param {pacingFindUniqueArgs} args - Arguments to find a Pacing
     * @example
     * // Get one Pacing
     * const pacing = await prisma.pacing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pacingFindUniqueArgs>(args: SelectSubset<T, pacingFindUniqueArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pacing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pacingFindUniqueOrThrowArgs} args - Arguments to find a Pacing
     * @example
     * // Get one Pacing
     * const pacing = await prisma.pacing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pacingFindUniqueOrThrowArgs>(args: SelectSubset<T, pacingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pacing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingFindFirstArgs} args - Arguments to find a Pacing
     * @example
     * // Get one Pacing
     * const pacing = await prisma.pacing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pacingFindFirstArgs>(args?: SelectSubset<T, pacingFindFirstArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pacing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingFindFirstOrThrowArgs} args - Arguments to find a Pacing
     * @example
     * // Get one Pacing
     * const pacing = await prisma.pacing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pacingFindFirstOrThrowArgs>(args?: SelectSubset<T, pacingFindFirstOrThrowArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pacings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pacings
     * const pacings = await prisma.pacing.findMany()
     * 
     * // Get first 10 Pacings
     * const pacings = await prisma.pacing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pacingWithIdOnly = await prisma.pacing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pacingFindManyArgs>(args?: SelectSubset<T, pacingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pacing.
     * @param {pacingCreateArgs} args - Arguments to create a Pacing.
     * @example
     * // Create one Pacing
     * const Pacing = await prisma.pacing.create({
     *   data: {
     *     // ... data to create a Pacing
     *   }
     * })
     * 
     */
    create<T extends pacingCreateArgs>(args: SelectSubset<T, pacingCreateArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pacings.
     * @param {pacingCreateManyArgs} args - Arguments to create many Pacings.
     * @example
     * // Create many Pacings
     * const pacing = await prisma.pacing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pacingCreateManyArgs>(args?: SelectSubset<T, pacingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pacings and returns the data saved in the database.
     * @param {pacingCreateManyAndReturnArgs} args - Arguments to create many Pacings.
     * @example
     * // Create many Pacings
     * const pacing = await prisma.pacing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pacings and only return the `id`
     * const pacingWithIdOnly = await prisma.pacing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pacingCreateManyAndReturnArgs>(args?: SelectSubset<T, pacingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pacing.
     * @param {pacingDeleteArgs} args - Arguments to delete one Pacing.
     * @example
     * // Delete one Pacing
     * const Pacing = await prisma.pacing.delete({
     *   where: {
     *     // ... filter to delete one Pacing
     *   }
     * })
     * 
     */
    delete<T extends pacingDeleteArgs>(args: SelectSubset<T, pacingDeleteArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pacing.
     * @param {pacingUpdateArgs} args - Arguments to update one Pacing.
     * @example
     * // Update one Pacing
     * const pacing = await prisma.pacing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pacingUpdateArgs>(args: SelectSubset<T, pacingUpdateArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pacings.
     * @param {pacingDeleteManyArgs} args - Arguments to filter Pacings to delete.
     * @example
     * // Delete a few Pacings
     * const { count } = await prisma.pacing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pacingDeleteManyArgs>(args?: SelectSubset<T, pacingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pacings
     * const pacing = await prisma.pacing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pacingUpdateManyArgs>(args: SelectSubset<T, pacingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacings and returns the data updated in the database.
     * @param {pacingUpdateManyAndReturnArgs} args - Arguments to update many Pacings.
     * @example
     * // Update many Pacings
     * const pacing = await prisma.pacing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pacings and only return the `id`
     * const pacingWithIdOnly = await prisma.pacing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pacingUpdateManyAndReturnArgs>(args: SelectSubset<T, pacingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pacing.
     * @param {pacingUpsertArgs} args - Arguments to update or create a Pacing.
     * @example
     * // Update or create a Pacing
     * const pacing = await prisma.pacing.upsert({
     *   create: {
     *     // ... data to create a Pacing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pacing we want to update
     *   }
     * })
     */
    upsert<T extends pacingUpsertArgs>(args: SelectSubset<T, pacingUpsertArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pacings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingCountArgs} args - Arguments to filter Pacings to count.
     * @example
     * // Count the number of Pacings
     * const count = await prisma.pacing.count({
     *   where: {
     *     // ... the filter for the Pacings we want to count
     *   }
     * })
    **/
    count<T extends pacingCountArgs>(
      args?: Subset<T, pacingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pacing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacingAggregateArgs>(args: Subset<T, PacingAggregateArgs>): Prisma.PrismaPromise<GetPacingAggregateType<T>>

    /**
     * Group by Pacing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pacingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pacingGroupByArgs['orderBy'] }
        : { orderBy?: pacingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pacingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pacing model
   */
  readonly fields: pacingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pacing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pacingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    volume<T extends volumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, volumeDefaultArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leads<T extends pacing$leadsArgs<ExtArgs> = {}>(args?: Subset<T, pacing$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploads<T extends pacing$uploadsArgs<ExtArgs> = {}>(args?: Subset<T, pacing$uploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pacing model
   */
  interface pacingFieldRefs {
    readonly id: FieldRef<"pacing", 'Int'>
    readonly volumeId: FieldRef<"pacing", 'Int'>
    readonly scheduledFor: FieldRef<"pacing", 'DateTime'>
    readonly leadGoal: FieldRef<"pacing", 'Int'>
    readonly status: FieldRef<"pacing", 'String'>
    readonly actualLeads: FieldRef<"pacing", 'Int'>
    readonly created_at: FieldRef<"pacing", 'DateTime'>
    readonly updated_at: FieldRef<"pacing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pacing findUnique
   */
  export type pacingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * Filter, which pacing to fetch.
     */
    where: pacingWhereUniqueInput
  }

  /**
   * pacing findUniqueOrThrow
   */
  export type pacingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * Filter, which pacing to fetch.
     */
    where: pacingWhereUniqueInput
  }

  /**
   * pacing findFirst
   */
  export type pacingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * Filter, which pacing to fetch.
     */
    where?: pacingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacings to fetch.
     */
    orderBy?: pacingOrderByWithRelationInput | pacingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacings.
     */
    cursor?: pacingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacings.
     */
    distinct?: PacingScalarFieldEnum | PacingScalarFieldEnum[]
  }

  /**
   * pacing findFirstOrThrow
   */
  export type pacingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * Filter, which pacing to fetch.
     */
    where?: pacingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacings to fetch.
     */
    orderBy?: pacingOrderByWithRelationInput | pacingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacings.
     */
    cursor?: pacingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacings.
     */
    distinct?: PacingScalarFieldEnum | PacingScalarFieldEnum[]
  }

  /**
   * pacing findMany
   */
  export type pacingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * Filter, which pacings to fetch.
     */
    where?: pacingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacings to fetch.
     */
    orderBy?: pacingOrderByWithRelationInput | pacingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pacings.
     */
    cursor?: pacingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacings.
     */
    skip?: number
    distinct?: PacingScalarFieldEnum | PacingScalarFieldEnum[]
  }

  /**
   * pacing create
   */
  export type pacingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * The data needed to create a pacing.
     */
    data: XOR<pacingCreateInput, pacingUncheckedCreateInput>
  }

  /**
   * pacing createMany
   */
  export type pacingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pacings.
     */
    data: pacingCreateManyInput | pacingCreateManyInput[]
  }

  /**
   * pacing createManyAndReturn
   */
  export type pacingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * The data used to create many pacings.
     */
    data: pacingCreateManyInput | pacingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pacing update
   */
  export type pacingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * The data needed to update a pacing.
     */
    data: XOR<pacingUpdateInput, pacingUncheckedUpdateInput>
    /**
     * Choose, which pacing to update.
     */
    where: pacingWhereUniqueInput
  }

  /**
   * pacing updateMany
   */
  export type pacingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pacings.
     */
    data: XOR<pacingUpdateManyMutationInput, pacingUncheckedUpdateManyInput>
    /**
     * Filter which pacings to update
     */
    where?: pacingWhereInput
    /**
     * Limit how many pacings to update.
     */
    limit?: number
  }

  /**
   * pacing updateManyAndReturn
   */
  export type pacingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * The data used to update pacings.
     */
    data: XOR<pacingUpdateManyMutationInput, pacingUncheckedUpdateManyInput>
    /**
     * Filter which pacings to update
     */
    where?: pacingWhereInput
    /**
     * Limit how many pacings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pacing upsert
   */
  export type pacingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * The filter to search for the pacing to update in case it exists.
     */
    where: pacingWhereUniqueInput
    /**
     * In case the pacing found by the `where` argument doesn't exist, create a new pacing with this data.
     */
    create: XOR<pacingCreateInput, pacingUncheckedCreateInput>
    /**
     * In case the pacing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pacingUpdateInput, pacingUncheckedUpdateInput>
  }

  /**
   * pacing delete
   */
  export type pacingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
    /**
     * Filter which pacing to delete.
     */
    where: pacingWhereUniqueInput
  }

  /**
   * pacing deleteMany
   */
  export type pacingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacings to delete
     */
    where?: pacingWhereInput
    /**
     * Limit how many pacings to delete.
     */
    limit?: number
  }

  /**
   * pacing.leads
   */
  export type pacing$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    where?: leadWhereInput
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    cursor?: leadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * pacing.uploads
   */
  export type pacing$uploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    where?: leadsUploadWhereInput
    orderBy?: leadsUploadOrderByWithRelationInput | leadsUploadOrderByWithRelationInput[]
    cursor?: leadsUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadsUploadScalarFieldEnum | LeadsUploadScalarFieldEnum[]
  }

  /**
   * pacing without action
   */
  export type pacingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacing
     */
    select?: pacingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacing
     */
    omit?: pacingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacingInclude<ExtArgs> | null
  }


  /**
   * Model lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    id: number | null
    campaignId: number | null
    pacingId: number | null
    volumeId: number | null
    uploadId: number | null
    campaignDeliveryId: number | null
  }

  export type LeadSumAggregateOutputType = {
    id: number | null
    campaignId: number | null
    pacingId: number | null
    volumeId: number | null
    uploadId: number | null
    campaignDeliveryId: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: number | null
    email: string | null
    campaignId: number | null
    pacingId: number | null
    volumeId: number | null
    uploadId: number | null
    uploadType: string | null
    created_at: Date | null
    updated_at: Date | null
    phase1Validation: boolean | null
    leadTemplateValidation: boolean | null
    campaignDeliveryId: number | null
    accepted: boolean | null
    pending: boolean | null
    rejected: boolean | null
    rejectedReason: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: number | null
    email: string | null
    campaignId: number | null
    pacingId: number | null
    volumeId: number | null
    uploadId: number | null
    uploadType: string | null
    created_at: Date | null
    updated_at: Date | null
    phase1Validation: boolean | null
    leadTemplateValidation: boolean | null
    campaignDeliveryId: number | null
    accepted: boolean | null
    pending: boolean | null
    rejected: boolean | null
    rejectedReason: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    data: number
    email: number
    campaignId: number
    pacingId: number
    volumeId: number
    uploadId: number
    uploadType: number
    created_at: number
    updated_at: number
    phase1Validation: number
    leadTemplateValidation: number
    campaignDeliveryId: number
    accepted: number
    pending: number
    rejected: number
    rejectedReason: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    id?: true
    campaignId?: true
    pacingId?: true
    volumeId?: true
    uploadId?: true
    campaignDeliveryId?: true
  }

  export type LeadSumAggregateInputType = {
    id?: true
    campaignId?: true
    pacingId?: true
    volumeId?: true
    uploadId?: true
    campaignDeliveryId?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    email?: true
    campaignId?: true
    pacingId?: true
    volumeId?: true
    uploadId?: true
    uploadType?: true
    created_at?: true
    updated_at?: true
    phase1Validation?: true
    leadTemplateValidation?: true
    campaignDeliveryId?: true
    accepted?: true
    pending?: true
    rejected?: true
    rejectedReason?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    email?: true
    campaignId?: true
    pacingId?: true
    volumeId?: true
    uploadId?: true
    uploadType?: true
    created_at?: true
    updated_at?: true
    phase1Validation?: true
    leadTemplateValidation?: true
    campaignDeliveryId?: true
    accepted?: true
    pending?: true
    rejected?: true
    rejectedReason?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    data?: true
    email?: true
    campaignId?: true
    pacingId?: true
    volumeId?: true
    uploadId?: true
    uploadType?: true
    created_at?: true
    updated_at?: true
    phase1Validation?: true
    leadTemplateValidation?: true
    campaignDeliveryId?: true
    accepted?: true
    pending?: true
    rejected?: true
    rejectedReason?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lead to aggregate.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type leadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
    orderBy?: leadOrderByWithAggregationInput | leadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: leadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: number
    data: JsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadId: number | null
    uploadType: string
    created_at: Date
    updated_at: Date
    phase1Validation: boolean
    leadTemplateValidation: boolean
    campaignDeliveryId: number | null
    accepted: boolean
    pending: boolean
    rejected: boolean
    rejectedReason: string
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends leadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type leadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    email?: boolean
    campaignId?: boolean
    pacingId?: boolean
    volumeId?: boolean
    uploadId?: boolean
    uploadType?: boolean
    created_at?: boolean
    updated_at?: boolean
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    upload?: boolean | lead$uploadArgs<ExtArgs>
    campaignDelivery?: boolean | lead$campaignDeliveryArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type leadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    email?: boolean
    campaignId?: boolean
    pacingId?: boolean
    volumeId?: boolean
    uploadId?: boolean
    uploadType?: boolean
    created_at?: boolean
    updated_at?: boolean
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    upload?: boolean | lead$uploadArgs<ExtArgs>
    campaignDelivery?: boolean | lead$campaignDeliveryArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type leadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    email?: boolean
    campaignId?: boolean
    pacingId?: boolean
    volumeId?: boolean
    uploadId?: boolean
    uploadType?: boolean
    created_at?: boolean
    updated_at?: boolean
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: boolean
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    upload?: boolean | lead$uploadArgs<ExtArgs>
    campaignDelivery?: boolean | lead$campaignDeliveryArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type leadSelectScalar = {
    id?: boolean
    data?: boolean
    email?: boolean
    campaignId?: boolean
    pacingId?: boolean
    volumeId?: boolean
    uploadId?: boolean
    uploadType?: boolean
    created_at?: boolean
    updated_at?: boolean
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: boolean
  }

  export type leadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "data" | "email" | "campaignId" | "pacingId" | "volumeId" | "uploadId" | "uploadType" | "created_at" | "updated_at" | "phase1Validation" | "leadTemplateValidation" | "campaignDeliveryId" | "accepted" | "pending" | "rejected" | "rejectedReason", ExtArgs["result"]["lead"]>
  export type leadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    upload?: boolean | lead$uploadArgs<ExtArgs>
    campaignDelivery?: boolean | lead$campaignDeliveryArgs<ExtArgs>
  }
  export type leadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    upload?: boolean | lead$uploadArgs<ExtArgs>
    campaignDelivery?: boolean | lead$campaignDeliveryArgs<ExtArgs>
  }
  export type leadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | campaignDefaultArgs<ExtArgs>
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    volume?: boolean | volumeDefaultArgs<ExtArgs>
    upload?: boolean | lead$uploadArgs<ExtArgs>
    campaignDelivery?: boolean | lead$campaignDeliveryArgs<ExtArgs>
  }

  export type $leadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lead"
    objects: {
      campaign: Prisma.$campaignPayload<ExtArgs>
      pacing: Prisma.$pacingPayload<ExtArgs>
      volume: Prisma.$volumePayload<ExtArgs>
      upload: Prisma.$leadsUploadPayload<ExtArgs> | null
      campaignDelivery: Prisma.$campaignDeliveriesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      data: Prisma.JsonValue
      email: string
      campaignId: number
      pacingId: number
      volumeId: number
      uploadId: number | null
      uploadType: string
      created_at: Date
      updated_at: Date
      phase1Validation: boolean
      leadTemplateValidation: boolean
      campaignDeliveryId: number | null
      accepted: boolean
      pending: boolean
      rejected: boolean
      rejectedReason: string
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type leadGetPayload<S extends boolean | null | undefined | leadDefaultArgs> = $Result.GetResult<Prisma.$leadPayload, S>

  type leadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<leadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface leadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lead'], meta: { name: 'lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {leadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends leadFindUniqueArgs>(args: SelectSubset<T, leadFindUniqueArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {leadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends leadFindUniqueOrThrowArgs>(args: SelectSubset<T, leadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends leadFindFirstArgs>(args?: SelectSubset<T, leadFindFirstArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends leadFindFirstOrThrowArgs>(args?: SelectSubset<T, leadFindFirstOrThrowArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends leadFindManyArgs>(args?: SelectSubset<T, leadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {leadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends leadCreateArgs>(args: SelectSubset<T, leadCreateArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {leadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends leadCreateManyArgs>(args?: SelectSubset<T, leadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {leadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends leadCreateManyAndReturnArgs>(args?: SelectSubset<T, leadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {leadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends leadDeleteArgs>(args: SelectSubset<T, leadDeleteArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {leadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends leadUpdateArgs>(args: SelectSubset<T, leadUpdateArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {leadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends leadDeleteManyArgs>(args?: SelectSubset<T, leadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends leadUpdateManyArgs>(args: SelectSubset<T, leadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {leadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends leadUpdateManyAndReturnArgs>(args: SelectSubset<T, leadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {leadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends leadUpsertArgs>(args: SelectSubset<T, leadUpsertArgs<ExtArgs>>): Prisma__leadClient<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends leadCountArgs>(
      args?: Subset<T, leadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leadGroupByArgs['orderBy'] }
        : { orderBy?: leadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lead model
   */
  readonly fields: leadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__leadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends campaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignDefaultArgs<ExtArgs>>): Prisma__campaignClient<$Result.GetResult<Prisma.$campaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pacing<T extends pacingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pacingDefaultArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    volume<T extends volumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, volumeDefaultArgs<ExtArgs>>): Prisma__volumeClient<$Result.GetResult<Prisma.$volumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    upload<T extends lead$uploadArgs<ExtArgs> = {}>(args?: Subset<T, lead$uploadArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    campaignDelivery<T extends lead$campaignDeliveryArgs<ExtArgs> = {}>(args?: Subset<T, lead$campaignDeliveryArgs<ExtArgs>>): Prisma__campaignDeliveriesClient<$Result.GetResult<Prisma.$campaignDeliveriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lead model
   */
  interface leadFieldRefs {
    readonly id: FieldRef<"lead", 'Int'>
    readonly data: FieldRef<"lead", 'Json'>
    readonly email: FieldRef<"lead", 'String'>
    readonly campaignId: FieldRef<"lead", 'Int'>
    readonly pacingId: FieldRef<"lead", 'Int'>
    readonly volumeId: FieldRef<"lead", 'Int'>
    readonly uploadId: FieldRef<"lead", 'Int'>
    readonly uploadType: FieldRef<"lead", 'String'>
    readonly created_at: FieldRef<"lead", 'DateTime'>
    readonly updated_at: FieldRef<"lead", 'DateTime'>
    readonly phase1Validation: FieldRef<"lead", 'Boolean'>
    readonly leadTemplateValidation: FieldRef<"lead", 'Boolean'>
    readonly campaignDeliveryId: FieldRef<"lead", 'Int'>
    readonly accepted: FieldRef<"lead", 'Boolean'>
    readonly pending: FieldRef<"lead", 'Boolean'>
    readonly rejected: FieldRef<"lead", 'Boolean'>
    readonly rejectedReason: FieldRef<"lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lead findUnique
   */
  export type leadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where: leadWhereUniqueInput
  }

  /**
   * lead findUniqueOrThrow
   */
  export type leadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where: leadWhereUniqueInput
  }

  /**
   * lead findFirst
   */
  export type leadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leads.
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * lead findFirstOrThrow
   */
  export type leadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leads.
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * lead findMany
   */
  export type leadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * Filter, which leads to fetch.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leads.
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * lead create
   */
  export type leadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * The data needed to create a lead.
     */
    data: XOR<leadCreateInput, leadUncheckedCreateInput>
  }

  /**
   * lead createMany
   */
  export type leadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leads.
     */
    data: leadCreateManyInput | leadCreateManyInput[]
  }

  /**
   * lead createManyAndReturn
   */
  export type leadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * The data used to create many leads.
     */
    data: leadCreateManyInput | leadCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * lead update
   */
  export type leadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * The data needed to update a lead.
     */
    data: XOR<leadUpdateInput, leadUncheckedUpdateInput>
    /**
     * Choose, which lead to update.
     */
    where: leadWhereUniqueInput
  }

  /**
   * lead updateMany
   */
  export type leadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leads.
     */
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyInput>
    /**
     * Filter which leads to update
     */
    where?: leadWhereInput
    /**
     * Limit how many leads to update.
     */
    limit?: number
  }

  /**
   * lead updateManyAndReturn
   */
  export type leadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * The data used to update leads.
     */
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyInput>
    /**
     * Filter which leads to update
     */
    where?: leadWhereInput
    /**
     * Limit how many leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * lead upsert
   */
  export type leadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * The filter to search for the lead to update in case it exists.
     */
    where: leadWhereUniqueInput
    /**
     * In case the lead found by the `where` argument doesn't exist, create a new lead with this data.
     */
    create: XOR<leadCreateInput, leadUncheckedCreateInput>
    /**
     * In case the lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leadUpdateInput, leadUncheckedUpdateInput>
  }

  /**
   * lead delete
   */
  export type leadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    /**
     * Filter which lead to delete.
     */
    where: leadWhereUniqueInput
  }

  /**
   * lead deleteMany
   */
  export type leadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leads to delete
     */
    where?: leadWhereInput
    /**
     * Limit how many leads to delete.
     */
    limit?: number
  }

  /**
   * lead.upload
   */
  export type lead$uploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    where?: leadsUploadWhereInput
  }

  /**
   * lead.campaignDelivery
   */
  export type lead$campaignDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignDeliveries
     */
    select?: campaignDeliveriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignDeliveries
     */
    omit?: campaignDeliveriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignDeliveriesInclude<ExtArgs> | null
    where?: campaignDeliveriesWhereInput
  }

  /**
   * lead without action
   */
  export type leadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
  }


  /**
   * Model leadsUpload
   */

  export type AggregateLeadsUpload = {
    _count: LeadsUploadCountAggregateOutputType | null
    _avg: LeadsUploadAvgAggregateOutputType | null
    _sum: LeadsUploadSumAggregateOutputType | null
    _min: LeadsUploadMinAggregateOutputType | null
    _max: LeadsUploadMaxAggregateOutputType | null
  }

  export type LeadsUploadAvgAggregateOutputType = {
    id: number | null
    pacingId: number | null
    uploadedBy: number | null
  }

  export type LeadsUploadSumAggregateOutputType = {
    id: number | null
    pacingId: number | null
    uploadedBy: number | null
  }

  export type LeadsUploadMinAggregateOutputType = {
    id: number | null
    pacingId: number | null
    uploadedBy: number | null
    filename: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LeadsUploadMaxAggregateOutputType = {
    id: number | null
    pacingId: number | null
    uploadedBy: number | null
    filename: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LeadsUploadCountAggregateOutputType = {
    id: number
    pacingId: number
    uploadedBy: number
    filename: number
    created_at: number
    updated_at: number
    results: number
    _all: number
  }


  export type LeadsUploadAvgAggregateInputType = {
    id?: true
    pacingId?: true
    uploadedBy?: true
  }

  export type LeadsUploadSumAggregateInputType = {
    id?: true
    pacingId?: true
    uploadedBy?: true
  }

  export type LeadsUploadMinAggregateInputType = {
    id?: true
    pacingId?: true
    uploadedBy?: true
    filename?: true
    created_at?: true
    updated_at?: true
  }

  export type LeadsUploadMaxAggregateInputType = {
    id?: true
    pacingId?: true
    uploadedBy?: true
    filename?: true
    created_at?: true
    updated_at?: true
  }

  export type LeadsUploadCountAggregateInputType = {
    id?: true
    pacingId?: true
    uploadedBy?: true
    filename?: true
    created_at?: true
    updated_at?: true
    results?: true
    _all?: true
  }

  export type LeadsUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leadsUpload to aggregate.
     */
    where?: leadsUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leadsUploads to fetch.
     */
    orderBy?: leadsUploadOrderByWithRelationInput | leadsUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leadsUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leadsUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leadsUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leadsUploads
    **/
    _count?: true | LeadsUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadsUploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadsUploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadsUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadsUploadMaxAggregateInputType
  }

  export type GetLeadsUploadAggregateType<T extends LeadsUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadsUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadsUpload[P]>
      : GetScalarType<T[P], AggregateLeadsUpload[P]>
  }




  export type leadsUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leadsUploadWhereInput
    orderBy?: leadsUploadOrderByWithAggregationInput | leadsUploadOrderByWithAggregationInput[]
    by: LeadsUploadScalarFieldEnum[] | LeadsUploadScalarFieldEnum
    having?: leadsUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadsUploadCountAggregateInputType | true
    _avg?: LeadsUploadAvgAggregateInputType
    _sum?: LeadsUploadSumAggregateInputType
    _min?: LeadsUploadMinAggregateInputType
    _max?: LeadsUploadMaxAggregateInputType
  }

  export type LeadsUploadGroupByOutputType = {
    id: number
    pacingId: number
    uploadedBy: number | null
    filename: string | null
    created_at: Date
    updated_at: Date
    results: JsonValue
    _count: LeadsUploadCountAggregateOutputType | null
    _avg: LeadsUploadAvgAggregateOutputType | null
    _sum: LeadsUploadSumAggregateOutputType | null
    _min: LeadsUploadMinAggregateOutputType | null
    _max: LeadsUploadMaxAggregateOutputType | null
  }

  type GetLeadsUploadGroupByPayload<T extends leadsUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadsUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadsUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadsUploadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadsUploadGroupByOutputType[P]>
        }
      >
    >


  export type leadsUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pacingId?: boolean
    uploadedBy?: boolean
    filename?: boolean
    created_at?: boolean
    updated_at?: boolean
    results?: boolean
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    leads?: boolean | leadsUpload$leadsArgs<ExtArgs>
    uploader?: boolean | leadsUpload$uploaderArgs<ExtArgs>
    _count?: boolean | LeadsUploadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadsUpload"]>

  export type leadsUploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pacingId?: boolean
    uploadedBy?: boolean
    filename?: boolean
    created_at?: boolean
    updated_at?: boolean
    results?: boolean
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    uploader?: boolean | leadsUpload$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["leadsUpload"]>

  export type leadsUploadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pacingId?: boolean
    uploadedBy?: boolean
    filename?: boolean
    created_at?: boolean
    updated_at?: boolean
    results?: boolean
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    uploader?: boolean | leadsUpload$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["leadsUpload"]>

  export type leadsUploadSelectScalar = {
    id?: boolean
    pacingId?: boolean
    uploadedBy?: boolean
    filename?: boolean
    created_at?: boolean
    updated_at?: boolean
    results?: boolean
  }

  export type leadsUploadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pacingId" | "uploadedBy" | "filename" | "created_at" | "updated_at" | "results", ExtArgs["result"]["leadsUpload"]>
  export type leadsUploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    leads?: boolean | leadsUpload$leadsArgs<ExtArgs>
    uploader?: boolean | leadsUpload$uploaderArgs<ExtArgs>
    _count?: boolean | LeadsUploadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type leadsUploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    uploader?: boolean | leadsUpload$uploaderArgs<ExtArgs>
  }
  export type leadsUploadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacing?: boolean | pacingDefaultArgs<ExtArgs>
    uploader?: boolean | leadsUpload$uploaderArgs<ExtArgs>
  }

  export type $leadsUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "leadsUpload"
    objects: {
      pacing: Prisma.$pacingPayload<ExtArgs>
      leads: Prisma.$leadPayload<ExtArgs>[]
      uploader: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pacingId: number
      uploadedBy: number | null
      filename: string | null
      created_at: Date
      updated_at: Date
      results: Prisma.JsonValue
    }, ExtArgs["result"]["leadsUpload"]>
    composites: {}
  }

  type leadsUploadGetPayload<S extends boolean | null | undefined | leadsUploadDefaultArgs> = $Result.GetResult<Prisma.$leadsUploadPayload, S>

  type leadsUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<leadsUploadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadsUploadCountAggregateInputType | true
    }

  export interface leadsUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['leadsUpload'], meta: { name: 'leadsUpload' } }
    /**
     * Find zero or one LeadsUpload that matches the filter.
     * @param {leadsUploadFindUniqueArgs} args - Arguments to find a LeadsUpload
     * @example
     * // Get one LeadsUpload
     * const leadsUpload = await prisma.leadsUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends leadsUploadFindUniqueArgs>(args: SelectSubset<T, leadsUploadFindUniqueArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadsUpload that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {leadsUploadFindUniqueOrThrowArgs} args - Arguments to find a LeadsUpload
     * @example
     * // Get one LeadsUpload
     * const leadsUpload = await prisma.leadsUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends leadsUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, leadsUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadsUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadsUploadFindFirstArgs} args - Arguments to find a LeadsUpload
     * @example
     * // Get one LeadsUpload
     * const leadsUpload = await prisma.leadsUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends leadsUploadFindFirstArgs>(args?: SelectSubset<T, leadsUploadFindFirstArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadsUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadsUploadFindFirstOrThrowArgs} args - Arguments to find a LeadsUpload
     * @example
     * // Get one LeadsUpload
     * const leadsUpload = await prisma.leadsUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends leadsUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, leadsUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadsUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadsUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadsUploads
     * const leadsUploads = await prisma.leadsUpload.findMany()
     * 
     * // Get first 10 LeadsUploads
     * const leadsUploads = await prisma.leadsUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadsUploadWithIdOnly = await prisma.leadsUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends leadsUploadFindManyArgs>(args?: SelectSubset<T, leadsUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadsUpload.
     * @param {leadsUploadCreateArgs} args - Arguments to create a LeadsUpload.
     * @example
     * // Create one LeadsUpload
     * const LeadsUpload = await prisma.leadsUpload.create({
     *   data: {
     *     // ... data to create a LeadsUpload
     *   }
     * })
     * 
     */
    create<T extends leadsUploadCreateArgs>(args: SelectSubset<T, leadsUploadCreateArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadsUploads.
     * @param {leadsUploadCreateManyArgs} args - Arguments to create many LeadsUploads.
     * @example
     * // Create many LeadsUploads
     * const leadsUpload = await prisma.leadsUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends leadsUploadCreateManyArgs>(args?: SelectSubset<T, leadsUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadsUploads and returns the data saved in the database.
     * @param {leadsUploadCreateManyAndReturnArgs} args - Arguments to create many LeadsUploads.
     * @example
     * // Create many LeadsUploads
     * const leadsUpload = await prisma.leadsUpload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadsUploads and only return the `id`
     * const leadsUploadWithIdOnly = await prisma.leadsUpload.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends leadsUploadCreateManyAndReturnArgs>(args?: SelectSubset<T, leadsUploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadsUpload.
     * @param {leadsUploadDeleteArgs} args - Arguments to delete one LeadsUpload.
     * @example
     * // Delete one LeadsUpload
     * const LeadsUpload = await prisma.leadsUpload.delete({
     *   where: {
     *     // ... filter to delete one LeadsUpload
     *   }
     * })
     * 
     */
    delete<T extends leadsUploadDeleteArgs>(args: SelectSubset<T, leadsUploadDeleteArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadsUpload.
     * @param {leadsUploadUpdateArgs} args - Arguments to update one LeadsUpload.
     * @example
     * // Update one LeadsUpload
     * const leadsUpload = await prisma.leadsUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends leadsUploadUpdateArgs>(args: SelectSubset<T, leadsUploadUpdateArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadsUploads.
     * @param {leadsUploadDeleteManyArgs} args - Arguments to filter LeadsUploads to delete.
     * @example
     * // Delete a few LeadsUploads
     * const { count } = await prisma.leadsUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends leadsUploadDeleteManyArgs>(args?: SelectSubset<T, leadsUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadsUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadsUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadsUploads
     * const leadsUpload = await prisma.leadsUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends leadsUploadUpdateManyArgs>(args: SelectSubset<T, leadsUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadsUploads and returns the data updated in the database.
     * @param {leadsUploadUpdateManyAndReturnArgs} args - Arguments to update many LeadsUploads.
     * @example
     * // Update many LeadsUploads
     * const leadsUpload = await prisma.leadsUpload.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadsUploads and only return the `id`
     * const leadsUploadWithIdOnly = await prisma.leadsUpload.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends leadsUploadUpdateManyAndReturnArgs>(args: SelectSubset<T, leadsUploadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadsUpload.
     * @param {leadsUploadUpsertArgs} args - Arguments to update or create a LeadsUpload.
     * @example
     * // Update or create a LeadsUpload
     * const leadsUpload = await prisma.leadsUpload.upsert({
     *   create: {
     *     // ... data to create a LeadsUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadsUpload we want to update
     *   }
     * })
     */
    upsert<T extends leadsUploadUpsertArgs>(args: SelectSubset<T, leadsUploadUpsertArgs<ExtArgs>>): Prisma__leadsUploadClient<$Result.GetResult<Prisma.$leadsUploadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadsUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadsUploadCountArgs} args - Arguments to filter LeadsUploads to count.
     * @example
     * // Count the number of LeadsUploads
     * const count = await prisma.leadsUpload.count({
     *   where: {
     *     // ... the filter for the LeadsUploads we want to count
     *   }
     * })
    **/
    count<T extends leadsUploadCountArgs>(
      args?: Subset<T, leadsUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadsUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadsUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadsUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadsUploadAggregateArgs>(args: Subset<T, LeadsUploadAggregateArgs>): Prisma.PrismaPromise<GetLeadsUploadAggregateType<T>>

    /**
     * Group by LeadsUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadsUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leadsUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leadsUploadGroupByArgs['orderBy'] }
        : { orderBy?: leadsUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leadsUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadsUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the leadsUpload model
   */
  readonly fields: leadsUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for leadsUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__leadsUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pacing<T extends pacingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pacingDefaultArgs<ExtArgs>>): Prisma__pacingClient<$Result.GetResult<Prisma.$pacingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leads<T extends leadsUpload$leadsArgs<ExtArgs> = {}>(args?: Subset<T, leadsUpload$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploader<T extends leadsUpload$uploaderArgs<ExtArgs> = {}>(args?: Subset<T, leadsUpload$uploaderArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the leadsUpload model
   */
  interface leadsUploadFieldRefs {
    readonly id: FieldRef<"leadsUpload", 'Int'>
    readonly pacingId: FieldRef<"leadsUpload", 'Int'>
    readonly uploadedBy: FieldRef<"leadsUpload", 'Int'>
    readonly filename: FieldRef<"leadsUpload", 'String'>
    readonly created_at: FieldRef<"leadsUpload", 'DateTime'>
    readonly updated_at: FieldRef<"leadsUpload", 'DateTime'>
    readonly results: FieldRef<"leadsUpload", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * leadsUpload findUnique
   */
  export type leadsUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * Filter, which leadsUpload to fetch.
     */
    where: leadsUploadWhereUniqueInput
  }

  /**
   * leadsUpload findUniqueOrThrow
   */
  export type leadsUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * Filter, which leadsUpload to fetch.
     */
    where: leadsUploadWhereUniqueInput
  }

  /**
   * leadsUpload findFirst
   */
  export type leadsUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * Filter, which leadsUpload to fetch.
     */
    where?: leadsUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leadsUploads to fetch.
     */
    orderBy?: leadsUploadOrderByWithRelationInput | leadsUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leadsUploads.
     */
    cursor?: leadsUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leadsUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leadsUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leadsUploads.
     */
    distinct?: LeadsUploadScalarFieldEnum | LeadsUploadScalarFieldEnum[]
  }

  /**
   * leadsUpload findFirstOrThrow
   */
  export type leadsUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * Filter, which leadsUpload to fetch.
     */
    where?: leadsUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leadsUploads to fetch.
     */
    orderBy?: leadsUploadOrderByWithRelationInput | leadsUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leadsUploads.
     */
    cursor?: leadsUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leadsUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leadsUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leadsUploads.
     */
    distinct?: LeadsUploadScalarFieldEnum | LeadsUploadScalarFieldEnum[]
  }

  /**
   * leadsUpload findMany
   */
  export type leadsUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * Filter, which leadsUploads to fetch.
     */
    where?: leadsUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leadsUploads to fetch.
     */
    orderBy?: leadsUploadOrderByWithRelationInput | leadsUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leadsUploads.
     */
    cursor?: leadsUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leadsUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leadsUploads.
     */
    skip?: number
    distinct?: LeadsUploadScalarFieldEnum | LeadsUploadScalarFieldEnum[]
  }

  /**
   * leadsUpload create
   */
  export type leadsUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * The data needed to create a leadsUpload.
     */
    data: XOR<leadsUploadCreateInput, leadsUploadUncheckedCreateInput>
  }

  /**
   * leadsUpload createMany
   */
  export type leadsUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leadsUploads.
     */
    data: leadsUploadCreateManyInput | leadsUploadCreateManyInput[]
  }

  /**
   * leadsUpload createManyAndReturn
   */
  export type leadsUploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * The data used to create many leadsUploads.
     */
    data: leadsUploadCreateManyInput | leadsUploadCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * leadsUpload update
   */
  export type leadsUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * The data needed to update a leadsUpload.
     */
    data: XOR<leadsUploadUpdateInput, leadsUploadUncheckedUpdateInput>
    /**
     * Choose, which leadsUpload to update.
     */
    where: leadsUploadWhereUniqueInput
  }

  /**
   * leadsUpload updateMany
   */
  export type leadsUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leadsUploads.
     */
    data: XOR<leadsUploadUpdateManyMutationInput, leadsUploadUncheckedUpdateManyInput>
    /**
     * Filter which leadsUploads to update
     */
    where?: leadsUploadWhereInput
    /**
     * Limit how many leadsUploads to update.
     */
    limit?: number
  }

  /**
   * leadsUpload updateManyAndReturn
   */
  export type leadsUploadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * The data used to update leadsUploads.
     */
    data: XOR<leadsUploadUpdateManyMutationInput, leadsUploadUncheckedUpdateManyInput>
    /**
     * Filter which leadsUploads to update
     */
    where?: leadsUploadWhereInput
    /**
     * Limit how many leadsUploads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * leadsUpload upsert
   */
  export type leadsUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * The filter to search for the leadsUpload to update in case it exists.
     */
    where: leadsUploadWhereUniqueInput
    /**
     * In case the leadsUpload found by the `where` argument doesn't exist, create a new leadsUpload with this data.
     */
    create: XOR<leadsUploadCreateInput, leadsUploadUncheckedCreateInput>
    /**
     * In case the leadsUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leadsUploadUpdateInput, leadsUploadUncheckedUpdateInput>
  }

  /**
   * leadsUpload delete
   */
  export type leadsUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
    /**
     * Filter which leadsUpload to delete.
     */
    where: leadsUploadWhereUniqueInput
  }

  /**
   * leadsUpload deleteMany
   */
  export type leadsUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leadsUploads to delete
     */
    where?: leadsUploadWhereInput
    /**
     * Limit how many leadsUploads to delete.
     */
    limit?: number
  }

  /**
   * leadsUpload.leads
   */
  export type leadsUpload$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lead
     */
    omit?: leadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadInclude<ExtArgs> | null
    where?: leadWhereInput
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    cursor?: leadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * leadsUpload.uploader
   */
  export type leadsUpload$uploaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * leadsUpload without action
   */
  export type leadsUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leadsUpload
     */
    select?: leadsUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leadsUpload
     */
    omit?: leadsUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leadsUploadInclude<ExtArgs> | null
  }


  /**
   * Model pacingReport
   */

  export type AggregatePacingReport = {
    _count: PacingReportCountAggregateOutputType | null
    _avg: PacingReportAvgAggregateOutputType | null
    _sum: PacingReportSumAggregateOutputType | null
    _min: PacingReportMinAggregateOutputType | null
    _max: PacingReportMaxAggregateOutputType | null
  }

  export type PacingReportAvgAggregateOutputType = {
    id: number | null
  }

  export type PacingReportSumAggregateOutputType = {
    id: number | null
  }

  export type PacingReportMinAggregateOutputType = {
    id: number | null
    type: $Enums.reportType | null
    created_at: Date | null
    updated_at: Date | null
    generatedType: $Enums.generatedType | null
  }

  export type PacingReportMaxAggregateOutputType = {
    id: number | null
    type: $Enums.reportType | null
    created_at: Date | null
    updated_at: Date | null
    generatedType: $Enums.generatedType | null
  }

  export type PacingReportCountAggregateOutputType = {
    id: number
    type: number
    data: number
    created_at: number
    updated_at: number
    generatedType: number
    _all: number
  }


  export type PacingReportAvgAggregateInputType = {
    id?: true
  }

  export type PacingReportSumAggregateInputType = {
    id?: true
  }

  export type PacingReportMinAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
    updated_at?: true
    generatedType?: true
  }

  export type PacingReportMaxAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
    updated_at?: true
    generatedType?: true
  }

  export type PacingReportCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    created_at?: true
    updated_at?: true
    generatedType?: true
    _all?: true
  }

  export type PacingReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacingReport to aggregate.
     */
    where?: pacingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacingReports to fetch.
     */
    orderBy?: pacingReportOrderByWithRelationInput | pacingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pacingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pacingReports
    **/
    _count?: true | PacingReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacingReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacingReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacingReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacingReportMaxAggregateInputType
  }

  export type GetPacingReportAggregateType<T extends PacingReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePacingReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePacingReport[P]>
      : GetScalarType<T[P], AggregatePacingReport[P]>
  }




  export type pacingReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacingReportWhereInput
    orderBy?: pacingReportOrderByWithAggregationInput | pacingReportOrderByWithAggregationInput[]
    by: PacingReportScalarFieldEnum[] | PacingReportScalarFieldEnum
    having?: pacingReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacingReportCountAggregateInputType | true
    _avg?: PacingReportAvgAggregateInputType
    _sum?: PacingReportSumAggregateInputType
    _min?: PacingReportMinAggregateInputType
    _max?: PacingReportMaxAggregateInputType
  }

  export type PacingReportGroupByOutputType = {
    id: number
    type: $Enums.reportType
    data: JsonValue
    created_at: Date
    updated_at: Date
    generatedType: $Enums.generatedType
    _count: PacingReportCountAggregateOutputType | null
    _avg: PacingReportAvgAggregateOutputType | null
    _sum: PacingReportSumAggregateOutputType | null
    _min: PacingReportMinAggregateOutputType | null
    _max: PacingReportMaxAggregateOutputType | null
  }

  type GetPacingReportGroupByPayload<T extends pacingReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacingReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacingReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacingReportGroupByOutputType[P]>
            : GetScalarType<T[P], PacingReportGroupByOutputType[P]>
        }
      >
    >


  export type pacingReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }, ExtArgs["result"]["pacingReport"]>

  export type pacingReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }, ExtArgs["result"]["pacingReport"]>

  export type pacingReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }, ExtArgs["result"]["pacingReport"]>

  export type pacingReportSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }

  export type pacingReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "data" | "created_at" | "updated_at" | "generatedType", ExtArgs["result"]["pacingReport"]>

  export type $pacingReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pacingReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.reportType
      data: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      generatedType: $Enums.generatedType
    }, ExtArgs["result"]["pacingReport"]>
    composites: {}
  }

  type pacingReportGetPayload<S extends boolean | null | undefined | pacingReportDefaultArgs> = $Result.GetResult<Prisma.$pacingReportPayload, S>

  type pacingReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pacingReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PacingReportCountAggregateInputType | true
    }

  export interface pacingReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pacingReport'], meta: { name: 'pacingReport' } }
    /**
     * Find zero or one PacingReport that matches the filter.
     * @param {pacingReportFindUniqueArgs} args - Arguments to find a PacingReport
     * @example
     * // Get one PacingReport
     * const pacingReport = await prisma.pacingReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pacingReportFindUniqueArgs>(args: SelectSubset<T, pacingReportFindUniqueArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PacingReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pacingReportFindUniqueOrThrowArgs} args - Arguments to find a PacingReport
     * @example
     * // Get one PacingReport
     * const pacingReport = await prisma.pacingReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pacingReportFindUniqueOrThrowArgs>(args: SelectSubset<T, pacingReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PacingReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingReportFindFirstArgs} args - Arguments to find a PacingReport
     * @example
     * // Get one PacingReport
     * const pacingReport = await prisma.pacingReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pacingReportFindFirstArgs>(args?: SelectSubset<T, pacingReportFindFirstArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PacingReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingReportFindFirstOrThrowArgs} args - Arguments to find a PacingReport
     * @example
     * // Get one PacingReport
     * const pacingReport = await prisma.pacingReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pacingReportFindFirstOrThrowArgs>(args?: SelectSubset<T, pacingReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PacingReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PacingReports
     * const pacingReports = await prisma.pacingReport.findMany()
     * 
     * // Get first 10 PacingReports
     * const pacingReports = await prisma.pacingReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pacingReportWithIdOnly = await prisma.pacingReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pacingReportFindManyArgs>(args?: SelectSubset<T, pacingReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PacingReport.
     * @param {pacingReportCreateArgs} args - Arguments to create a PacingReport.
     * @example
     * // Create one PacingReport
     * const PacingReport = await prisma.pacingReport.create({
     *   data: {
     *     // ... data to create a PacingReport
     *   }
     * })
     * 
     */
    create<T extends pacingReportCreateArgs>(args: SelectSubset<T, pacingReportCreateArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PacingReports.
     * @param {pacingReportCreateManyArgs} args - Arguments to create many PacingReports.
     * @example
     * // Create many PacingReports
     * const pacingReport = await prisma.pacingReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pacingReportCreateManyArgs>(args?: SelectSubset<T, pacingReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PacingReports and returns the data saved in the database.
     * @param {pacingReportCreateManyAndReturnArgs} args - Arguments to create many PacingReports.
     * @example
     * // Create many PacingReports
     * const pacingReport = await prisma.pacingReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PacingReports and only return the `id`
     * const pacingReportWithIdOnly = await prisma.pacingReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pacingReportCreateManyAndReturnArgs>(args?: SelectSubset<T, pacingReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PacingReport.
     * @param {pacingReportDeleteArgs} args - Arguments to delete one PacingReport.
     * @example
     * // Delete one PacingReport
     * const PacingReport = await prisma.pacingReport.delete({
     *   where: {
     *     // ... filter to delete one PacingReport
     *   }
     * })
     * 
     */
    delete<T extends pacingReportDeleteArgs>(args: SelectSubset<T, pacingReportDeleteArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PacingReport.
     * @param {pacingReportUpdateArgs} args - Arguments to update one PacingReport.
     * @example
     * // Update one PacingReport
     * const pacingReport = await prisma.pacingReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pacingReportUpdateArgs>(args: SelectSubset<T, pacingReportUpdateArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PacingReports.
     * @param {pacingReportDeleteManyArgs} args - Arguments to filter PacingReports to delete.
     * @example
     * // Delete a few PacingReports
     * const { count } = await prisma.pacingReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pacingReportDeleteManyArgs>(args?: SelectSubset<T, pacingReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PacingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PacingReports
     * const pacingReport = await prisma.pacingReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pacingReportUpdateManyArgs>(args: SelectSubset<T, pacingReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PacingReports and returns the data updated in the database.
     * @param {pacingReportUpdateManyAndReturnArgs} args - Arguments to update many PacingReports.
     * @example
     * // Update many PacingReports
     * const pacingReport = await prisma.pacingReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PacingReports and only return the `id`
     * const pacingReportWithIdOnly = await prisma.pacingReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pacingReportUpdateManyAndReturnArgs>(args: SelectSubset<T, pacingReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PacingReport.
     * @param {pacingReportUpsertArgs} args - Arguments to update or create a PacingReport.
     * @example
     * // Update or create a PacingReport
     * const pacingReport = await prisma.pacingReport.upsert({
     *   create: {
     *     // ... data to create a PacingReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PacingReport we want to update
     *   }
     * })
     */
    upsert<T extends pacingReportUpsertArgs>(args: SelectSubset<T, pacingReportUpsertArgs<ExtArgs>>): Prisma__pacingReportClient<$Result.GetResult<Prisma.$pacingReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PacingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingReportCountArgs} args - Arguments to filter PacingReports to count.
     * @example
     * // Count the number of PacingReports
     * const count = await prisma.pacingReport.count({
     *   where: {
     *     // ... the filter for the PacingReports we want to count
     *   }
     * })
    **/
    count<T extends pacingReportCountArgs>(
      args?: Subset<T, pacingReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacingReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PacingReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacingReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacingReportAggregateArgs>(args: Subset<T, PacingReportAggregateArgs>): Prisma.PrismaPromise<GetPacingReportAggregateType<T>>

    /**
     * Group by PacingReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacingReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pacingReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pacingReportGroupByArgs['orderBy'] }
        : { orderBy?: pacingReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pacingReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacingReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pacingReport model
   */
  readonly fields: pacingReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pacingReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pacingReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pacingReport model
   */
  interface pacingReportFieldRefs {
    readonly id: FieldRef<"pacingReport", 'Int'>
    readonly type: FieldRef<"pacingReport", 'reportType'>
    readonly data: FieldRef<"pacingReport", 'Json'>
    readonly created_at: FieldRef<"pacingReport", 'DateTime'>
    readonly updated_at: FieldRef<"pacingReport", 'DateTime'>
    readonly generatedType: FieldRef<"pacingReport", 'generatedType'>
  }
    

  // Custom InputTypes
  /**
   * pacingReport findUnique
   */
  export type pacingReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * Filter, which pacingReport to fetch.
     */
    where: pacingReportWhereUniqueInput
  }

  /**
   * pacingReport findUniqueOrThrow
   */
  export type pacingReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * Filter, which pacingReport to fetch.
     */
    where: pacingReportWhereUniqueInput
  }

  /**
   * pacingReport findFirst
   */
  export type pacingReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * Filter, which pacingReport to fetch.
     */
    where?: pacingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacingReports to fetch.
     */
    orderBy?: pacingReportOrderByWithRelationInput | pacingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacingReports.
     */
    cursor?: pacingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacingReports.
     */
    distinct?: PacingReportScalarFieldEnum | PacingReportScalarFieldEnum[]
  }

  /**
   * pacingReport findFirstOrThrow
   */
  export type pacingReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * Filter, which pacingReport to fetch.
     */
    where?: pacingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacingReports to fetch.
     */
    orderBy?: pacingReportOrderByWithRelationInput | pacingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacingReports.
     */
    cursor?: pacingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacingReports.
     */
    distinct?: PacingReportScalarFieldEnum | PacingReportScalarFieldEnum[]
  }

  /**
   * pacingReport findMany
   */
  export type pacingReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * Filter, which pacingReports to fetch.
     */
    where?: pacingReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacingReports to fetch.
     */
    orderBy?: pacingReportOrderByWithRelationInput | pacingReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pacingReports.
     */
    cursor?: pacingReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacingReports.
     */
    skip?: number
    distinct?: PacingReportScalarFieldEnum | PacingReportScalarFieldEnum[]
  }

  /**
   * pacingReport create
   */
  export type pacingReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * The data needed to create a pacingReport.
     */
    data: XOR<pacingReportCreateInput, pacingReportUncheckedCreateInput>
  }

  /**
   * pacingReport createMany
   */
  export type pacingReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pacingReports.
     */
    data: pacingReportCreateManyInput | pacingReportCreateManyInput[]
  }

  /**
   * pacingReport createManyAndReturn
   */
  export type pacingReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * The data used to create many pacingReports.
     */
    data: pacingReportCreateManyInput | pacingReportCreateManyInput[]
  }

  /**
   * pacingReport update
   */
  export type pacingReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * The data needed to update a pacingReport.
     */
    data: XOR<pacingReportUpdateInput, pacingReportUncheckedUpdateInput>
    /**
     * Choose, which pacingReport to update.
     */
    where: pacingReportWhereUniqueInput
  }

  /**
   * pacingReport updateMany
   */
  export type pacingReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pacingReports.
     */
    data: XOR<pacingReportUpdateManyMutationInput, pacingReportUncheckedUpdateManyInput>
    /**
     * Filter which pacingReports to update
     */
    where?: pacingReportWhereInput
    /**
     * Limit how many pacingReports to update.
     */
    limit?: number
  }

  /**
   * pacingReport updateManyAndReturn
   */
  export type pacingReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * The data used to update pacingReports.
     */
    data: XOR<pacingReportUpdateManyMutationInput, pacingReportUncheckedUpdateManyInput>
    /**
     * Filter which pacingReports to update
     */
    where?: pacingReportWhereInput
    /**
     * Limit how many pacingReports to update.
     */
    limit?: number
  }

  /**
   * pacingReport upsert
   */
  export type pacingReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * The filter to search for the pacingReport to update in case it exists.
     */
    where: pacingReportWhereUniqueInput
    /**
     * In case the pacingReport found by the `where` argument doesn't exist, create a new pacingReport with this data.
     */
    create: XOR<pacingReportCreateInput, pacingReportUncheckedCreateInput>
    /**
     * In case the pacingReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pacingReportUpdateInput, pacingReportUncheckedUpdateInput>
  }

  /**
   * pacingReport delete
   */
  export type pacingReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
    /**
     * Filter which pacingReport to delete.
     */
    where: pacingReportWhereUniqueInput
  }

  /**
   * pacingReport deleteMany
   */
  export type pacingReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacingReports to delete
     */
    where?: pacingReportWhereInput
    /**
     * Limit how many pacingReports to delete.
     */
    limit?: number
  }

  /**
   * pacingReport without action
   */
  export type pacingReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacingReport
     */
    select?: pacingReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pacingReport
     */
    omit?: pacingReportOmit<ExtArgs> | null
  }


  /**
   * Model campaignReport
   */

  export type AggregateCampaignReport = {
    _count: CampaignReportCountAggregateOutputType | null
    _avg: CampaignReportAvgAggregateOutputType | null
    _sum: CampaignReportSumAggregateOutputType | null
    _min: CampaignReportMinAggregateOutputType | null
    _max: CampaignReportMaxAggregateOutputType | null
  }

  export type CampaignReportAvgAggregateOutputType = {
    id: number | null
  }

  export type CampaignReportSumAggregateOutputType = {
    id: number | null
  }

  export type CampaignReportMinAggregateOutputType = {
    id: number | null
    type: $Enums.reportType | null
    created_at: Date | null
    updated_at: Date | null
    generatedType: $Enums.generatedType | null
  }

  export type CampaignReportMaxAggregateOutputType = {
    id: number | null
    type: $Enums.reportType | null
    created_at: Date | null
    updated_at: Date | null
    generatedType: $Enums.generatedType | null
  }

  export type CampaignReportCountAggregateOutputType = {
    id: number
    type: number
    data: number
    created_at: number
    updated_at: number
    generatedType: number
    _all: number
  }


  export type CampaignReportAvgAggregateInputType = {
    id?: true
  }

  export type CampaignReportSumAggregateInputType = {
    id?: true
  }

  export type CampaignReportMinAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
    updated_at?: true
    generatedType?: true
  }

  export type CampaignReportMaxAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
    updated_at?: true
    generatedType?: true
  }

  export type CampaignReportCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    created_at?: true
    updated_at?: true
    generatedType?: true
    _all?: true
  }

  export type CampaignReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaignReport to aggregate.
     */
    where?: campaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignReports to fetch.
     */
    orderBy?: campaignReportOrderByWithRelationInput | campaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaignReports
    **/
    _count?: true | CampaignReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignReportMaxAggregateInputType
  }

  export type GetCampaignReportAggregateType<T extends CampaignReportAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignReport[P]>
      : GetScalarType<T[P], AggregateCampaignReport[P]>
  }




  export type campaignReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignReportWhereInput
    orderBy?: campaignReportOrderByWithAggregationInput | campaignReportOrderByWithAggregationInput[]
    by: CampaignReportScalarFieldEnum[] | CampaignReportScalarFieldEnum
    having?: campaignReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignReportCountAggregateInputType | true
    _avg?: CampaignReportAvgAggregateInputType
    _sum?: CampaignReportSumAggregateInputType
    _min?: CampaignReportMinAggregateInputType
    _max?: CampaignReportMaxAggregateInputType
  }

  export type CampaignReportGroupByOutputType = {
    id: number
    type: $Enums.reportType
    data: JsonValue
    created_at: Date
    updated_at: Date
    generatedType: $Enums.generatedType
    _count: CampaignReportCountAggregateOutputType | null
    _avg: CampaignReportAvgAggregateOutputType | null
    _sum: CampaignReportSumAggregateOutputType | null
    _min: CampaignReportMinAggregateOutputType | null
    _max: CampaignReportMaxAggregateOutputType | null
  }

  type GetCampaignReportGroupByPayload<T extends campaignReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignReportGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignReportGroupByOutputType[P]>
        }
      >
    >


  export type campaignReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }, ExtArgs["result"]["campaignReport"]>

  export type campaignReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }, ExtArgs["result"]["campaignReport"]>

  export type campaignReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }, ExtArgs["result"]["campaignReport"]>

  export type campaignReportSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    generatedType?: boolean
  }

  export type campaignReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "data" | "created_at" | "updated_at" | "generatedType", ExtArgs["result"]["campaignReport"]>

  export type $campaignReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaignReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.reportType
      data: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      generatedType: $Enums.generatedType
    }, ExtArgs["result"]["campaignReport"]>
    composites: {}
  }

  type campaignReportGetPayload<S extends boolean | null | undefined | campaignReportDefaultArgs> = $Result.GetResult<Prisma.$campaignReportPayload, S>

  type campaignReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<campaignReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignReportCountAggregateInputType | true
    }

  export interface campaignReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaignReport'], meta: { name: 'campaignReport' } }
    /**
     * Find zero or one CampaignReport that matches the filter.
     * @param {campaignReportFindUniqueArgs} args - Arguments to find a CampaignReport
     * @example
     * // Get one CampaignReport
     * const campaignReport = await prisma.campaignReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaignReportFindUniqueArgs>(args: SelectSubset<T, campaignReportFindUniqueArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {campaignReportFindUniqueOrThrowArgs} args - Arguments to find a CampaignReport
     * @example
     * // Get one CampaignReport
     * const campaignReport = await prisma.campaignReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaignReportFindUniqueOrThrowArgs>(args: SelectSubset<T, campaignReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignReportFindFirstArgs} args - Arguments to find a CampaignReport
     * @example
     * // Get one CampaignReport
     * const campaignReport = await prisma.campaignReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaignReportFindFirstArgs>(args?: SelectSubset<T, campaignReportFindFirstArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignReportFindFirstOrThrowArgs} args - Arguments to find a CampaignReport
     * @example
     * // Get one CampaignReport
     * const campaignReport = await prisma.campaignReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaignReportFindFirstOrThrowArgs>(args?: SelectSubset<T, campaignReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignReports
     * const campaignReports = await prisma.campaignReport.findMany()
     * 
     * // Get first 10 CampaignReports
     * const campaignReports = await prisma.campaignReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignReportWithIdOnly = await prisma.campaignReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaignReportFindManyArgs>(args?: SelectSubset<T, campaignReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignReport.
     * @param {campaignReportCreateArgs} args - Arguments to create a CampaignReport.
     * @example
     * // Create one CampaignReport
     * const CampaignReport = await prisma.campaignReport.create({
     *   data: {
     *     // ... data to create a CampaignReport
     *   }
     * })
     * 
     */
    create<T extends campaignReportCreateArgs>(args: SelectSubset<T, campaignReportCreateArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignReports.
     * @param {campaignReportCreateManyArgs} args - Arguments to create many CampaignReports.
     * @example
     * // Create many CampaignReports
     * const campaignReport = await prisma.campaignReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaignReportCreateManyArgs>(args?: SelectSubset<T, campaignReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignReports and returns the data saved in the database.
     * @param {campaignReportCreateManyAndReturnArgs} args - Arguments to create many CampaignReports.
     * @example
     * // Create many CampaignReports
     * const campaignReport = await prisma.campaignReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignReports and only return the `id`
     * const campaignReportWithIdOnly = await prisma.campaignReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaignReportCreateManyAndReturnArgs>(args?: SelectSubset<T, campaignReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignReport.
     * @param {campaignReportDeleteArgs} args - Arguments to delete one CampaignReport.
     * @example
     * // Delete one CampaignReport
     * const CampaignReport = await prisma.campaignReport.delete({
     *   where: {
     *     // ... filter to delete one CampaignReport
     *   }
     * })
     * 
     */
    delete<T extends campaignReportDeleteArgs>(args: SelectSubset<T, campaignReportDeleteArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignReport.
     * @param {campaignReportUpdateArgs} args - Arguments to update one CampaignReport.
     * @example
     * // Update one CampaignReport
     * const campaignReport = await prisma.campaignReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaignReportUpdateArgs>(args: SelectSubset<T, campaignReportUpdateArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignReports.
     * @param {campaignReportDeleteManyArgs} args - Arguments to filter CampaignReports to delete.
     * @example
     * // Delete a few CampaignReports
     * const { count } = await prisma.campaignReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaignReportDeleteManyArgs>(args?: SelectSubset<T, campaignReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignReports
     * const campaignReport = await prisma.campaignReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaignReportUpdateManyArgs>(args: SelectSubset<T, campaignReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignReports and returns the data updated in the database.
     * @param {campaignReportUpdateManyAndReturnArgs} args - Arguments to update many CampaignReports.
     * @example
     * // Update many CampaignReports
     * const campaignReport = await prisma.campaignReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignReports and only return the `id`
     * const campaignReportWithIdOnly = await prisma.campaignReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends campaignReportUpdateManyAndReturnArgs>(args: SelectSubset<T, campaignReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignReport.
     * @param {campaignReportUpsertArgs} args - Arguments to update or create a CampaignReport.
     * @example
     * // Update or create a CampaignReport
     * const campaignReport = await prisma.campaignReport.upsert({
     *   create: {
     *     // ... data to create a CampaignReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignReport we want to update
     *   }
     * })
     */
    upsert<T extends campaignReportUpsertArgs>(args: SelectSubset<T, campaignReportUpsertArgs<ExtArgs>>): Prisma__campaignReportClient<$Result.GetResult<Prisma.$campaignReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignReportCountArgs} args - Arguments to filter CampaignReports to count.
     * @example
     * // Count the number of CampaignReports
     * const count = await prisma.campaignReport.count({
     *   where: {
     *     // ... the filter for the CampaignReports we want to count
     *   }
     * })
    **/
    count<T extends campaignReportCountArgs>(
      args?: Subset<T, campaignReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignReportAggregateArgs>(args: Subset<T, CampaignReportAggregateArgs>): Prisma.PrismaPromise<GetCampaignReportAggregateType<T>>

    /**
     * Group by CampaignReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaignReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaignReportGroupByArgs['orderBy'] }
        : { orderBy?: campaignReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaignReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaignReport model
   */
  readonly fields: campaignReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaignReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaignReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaignReport model
   */
  interface campaignReportFieldRefs {
    readonly id: FieldRef<"campaignReport", 'Int'>
    readonly type: FieldRef<"campaignReport", 'reportType'>
    readonly data: FieldRef<"campaignReport", 'Json'>
    readonly created_at: FieldRef<"campaignReport", 'DateTime'>
    readonly updated_at: FieldRef<"campaignReport", 'DateTime'>
    readonly generatedType: FieldRef<"campaignReport", 'generatedType'>
  }
    

  // Custom InputTypes
  /**
   * campaignReport findUnique
   */
  export type campaignReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * Filter, which campaignReport to fetch.
     */
    where: campaignReportWhereUniqueInput
  }

  /**
   * campaignReport findUniqueOrThrow
   */
  export type campaignReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * Filter, which campaignReport to fetch.
     */
    where: campaignReportWhereUniqueInput
  }

  /**
   * campaignReport findFirst
   */
  export type campaignReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * Filter, which campaignReport to fetch.
     */
    where?: campaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignReports to fetch.
     */
    orderBy?: campaignReportOrderByWithRelationInput | campaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaignReports.
     */
    cursor?: campaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaignReports.
     */
    distinct?: CampaignReportScalarFieldEnum | CampaignReportScalarFieldEnum[]
  }

  /**
   * campaignReport findFirstOrThrow
   */
  export type campaignReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * Filter, which campaignReport to fetch.
     */
    where?: campaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignReports to fetch.
     */
    orderBy?: campaignReportOrderByWithRelationInput | campaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaignReports.
     */
    cursor?: campaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaignReports.
     */
    distinct?: CampaignReportScalarFieldEnum | CampaignReportScalarFieldEnum[]
  }

  /**
   * campaignReport findMany
   */
  export type campaignReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * Filter, which campaignReports to fetch.
     */
    where?: campaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaignReports to fetch.
     */
    orderBy?: campaignReportOrderByWithRelationInput | campaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaignReports.
     */
    cursor?: campaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaignReports.
     */
    skip?: number
    distinct?: CampaignReportScalarFieldEnum | CampaignReportScalarFieldEnum[]
  }

  /**
   * campaignReport create
   */
  export type campaignReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * The data needed to create a campaignReport.
     */
    data: XOR<campaignReportCreateInput, campaignReportUncheckedCreateInput>
  }

  /**
   * campaignReport createMany
   */
  export type campaignReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaignReports.
     */
    data: campaignReportCreateManyInput | campaignReportCreateManyInput[]
  }

  /**
   * campaignReport createManyAndReturn
   */
  export type campaignReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * The data used to create many campaignReports.
     */
    data: campaignReportCreateManyInput | campaignReportCreateManyInput[]
  }

  /**
   * campaignReport update
   */
  export type campaignReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * The data needed to update a campaignReport.
     */
    data: XOR<campaignReportUpdateInput, campaignReportUncheckedUpdateInput>
    /**
     * Choose, which campaignReport to update.
     */
    where: campaignReportWhereUniqueInput
  }

  /**
   * campaignReport updateMany
   */
  export type campaignReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaignReports.
     */
    data: XOR<campaignReportUpdateManyMutationInput, campaignReportUncheckedUpdateManyInput>
    /**
     * Filter which campaignReports to update
     */
    where?: campaignReportWhereInput
    /**
     * Limit how many campaignReports to update.
     */
    limit?: number
  }

  /**
   * campaignReport updateManyAndReturn
   */
  export type campaignReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * The data used to update campaignReports.
     */
    data: XOR<campaignReportUpdateManyMutationInput, campaignReportUncheckedUpdateManyInput>
    /**
     * Filter which campaignReports to update
     */
    where?: campaignReportWhereInput
    /**
     * Limit how many campaignReports to update.
     */
    limit?: number
  }

  /**
   * campaignReport upsert
   */
  export type campaignReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * The filter to search for the campaignReport to update in case it exists.
     */
    where: campaignReportWhereUniqueInput
    /**
     * In case the campaignReport found by the `where` argument doesn't exist, create a new campaignReport with this data.
     */
    create: XOR<campaignReportCreateInput, campaignReportUncheckedCreateInput>
    /**
     * In case the campaignReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaignReportUpdateInput, campaignReportUncheckedUpdateInput>
  }

  /**
   * campaignReport delete
   */
  export type campaignReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
    /**
     * Filter which campaignReport to delete.
     */
    where: campaignReportWhereUniqueInput
  }

  /**
   * campaignReport deleteMany
   */
  export type campaignReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaignReports to delete
     */
    where?: campaignReportWhereInput
    /**
     * Limit how many campaignReports to delete.
     */
    limit?: number
  }

  /**
   * campaignReport without action
   */
  export type campaignReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaignReport
     */
    select?: campaignReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the campaignReport
     */
    omit?: campaignReportOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    createdAt: 'createdAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const UserLeaveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    leaveType: 'leaveType',
    fromDate: 'fromDate',
    toDate: 'toDate',
    duration: 'duration',
    reason: 'reason',
    status: 'status',
    approvedById: 'approvedById',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserLeaveScalarFieldEnum = (typeof UserLeaveScalarFieldEnum)[keyof typeof UserLeaveScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    startTime: 'startTime',
    latestLogged: 'latestLogged',
    endTime: 'endTime',
    userId: 'userId',
    taskId: 'taskId',
    breakId: 'breakId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId',
    totalTime: 'totalTime',
    assignedById: 'assignedById'
  };

  export type UserTaskScalarFieldEnum = (typeof UserTaskScalarFieldEnum)[keyof typeof UserTaskScalarFieldEnum]


  export const UserBreakScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    breakId: 'breakId',
    totalTime: 'totalTime'
  };

  export type UserBreakScalarFieldEnum = (typeof UserBreakScalarFieldEnum)[keyof typeof UserBreakScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    typeId: 'typeId',
    status: 'status',
    level: 'level',
    remark: 'remark',
    reassigned: 'reassigned'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const BreakScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BreakScalarFieldEnum = (typeof BreakScalarFieldEnum)[keyof typeof BreakScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    body: 'body',
    senderId: 'senderId',
    recipientId: 'recipientId',
    created_at: 'created_at',
    read_at: 'read_at'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const GroupMessageScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    body: 'body',
    senderId: 'senderId',
    created_at: 'created_at',
    read_at: 'read_at'
  };

  export type GroupMessageScalarFieldEnum = (typeof GroupMessageScalarFieldEnum)[keyof typeof GroupMessageScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const UserGroupsScalarFieldEnum: {
    userId: 'userId',
    groupId: 'groupId',
    assignedAt: 'assignedAt'
  };

  export type UserGroupsScalarFieldEnum = (typeof UserGroupsScalarFieldEnum)[keyof typeof UserGroupsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    message: 'message',
    notificationPriorityId: 'notificationPriorityId',
    createdAt: 'createdAt',
    url: 'url',
    type: 'type'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPriorityScalarFieldEnum: {
    id: 'id',
    level: 'level'
  };

  export type NotificationPriorityScalarFieldEnum = (typeof NotificationPriorityScalarFieldEnum)[keyof typeof NotificationPriorityScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RoleNotificationScalarFieldEnum: {
    roleId: 'roleId',
    notificationId: 'notificationId'
  };

  export type RoleNotificationScalarFieldEnum = (typeof RoleNotificationScalarFieldEnum)[keyof typeof RoleNotificationScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    clientId: 'clientId',
    leadgoal: 'leadgoal',
    completed: 'completed',
    pending: 'pending',
    duedate: 'duedate',
    info: 'info',
    content: 'content',
    filesInfo: 'filesInfo',
    updates: 'updates',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignDeliveriesScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    date: 'date',
    fileName: 'fileName',
    submitted: 'submitted',
    accepted: 'accepted',
    errors: 'errors',
    rejections: 'rejections',
    uploaderId: 'uploaderId',
    data: 'data'
  };

  export type CampaignDeliveriesScalarFieldEnum = (typeof CampaignDeliveriesScalarFieldEnum)[keyof typeof CampaignDeliveriesScalarFieldEnum]


  export const CampaignTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    campaignId: 'campaignId'
  };

  export type CampaignTypeScalarFieldEnum = (typeof CampaignTypeScalarFieldEnum)[keyof typeof CampaignTypeScalarFieldEnum]


  export const VolumeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    campaignId: 'campaignId',
    leadGoal: 'leadGoal',
    completed: 'completed',
    pending: 'pending',
    status: 'status',
    validationProfile: 'validationProfile',
    headers: 'headers',
    leadTemplate: 'leadTemplate',
    externalRules: 'externalRules'
  };

  export type VolumeScalarFieldEnum = (typeof VolumeScalarFieldEnum)[keyof typeof VolumeScalarFieldEnum]


  export const BriefScalarFieldEnum: {
    id: 'id',
    name: 'name',
    arrivedOn: 'arrivedOn',
    arrivedOnTime: 'arrivedOnTime',
    dueTime: 'dueTime',
    due: 'due',
    status: 'status',
    leadDetails: 'leadDetails',
    leadDetailsSection: 'leadDetailsSection',
    type: 'type',
    quotes: 'quotes',
    campaignId: 'campaignId',
    remark: 'remark',
    briefHyperlink: 'briefHyperlink'
  };

  export type BriefScalarFieldEnum = (typeof BriefScalarFieldEnum)[keyof typeof BriefScalarFieldEnum]


  export const BriefUpdatesScalarFieldEnum: {
    id: 'id',
    briefId: 'briefId',
    arrivedOn: 'arrivedOn',
    due: 'due',
    status: 'status',
    leadDetails: 'leadDetails',
    type: 'type',
    quotes: 'quotes',
    campaignId: 'campaignId',
    remark: 'remark',
    briefHyperlink: 'briefHyperlink'
  };

  export type BriefUpdatesScalarFieldEnum = (typeof BriefUpdatesScalarFieldEnum)[keyof typeof BriefUpdatesScalarFieldEnum]


  export const PacingScalarFieldEnum: {
    id: 'id',
    volumeId: 'volumeId',
    scheduledFor: 'scheduledFor',
    leadGoal: 'leadGoal',
    status: 'status',
    actualLeads: 'actualLeads',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PacingScalarFieldEnum = (typeof PacingScalarFieldEnum)[keyof typeof PacingScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    data: 'data',
    email: 'email',
    campaignId: 'campaignId',
    pacingId: 'pacingId',
    volumeId: 'volumeId',
    uploadId: 'uploadId',
    uploadType: 'uploadType',
    created_at: 'created_at',
    updated_at: 'updated_at',
    phase1Validation: 'phase1Validation',
    leadTemplateValidation: 'leadTemplateValidation',
    campaignDeliveryId: 'campaignDeliveryId',
    accepted: 'accepted',
    pending: 'pending',
    rejected: 'rejected',
    rejectedReason: 'rejectedReason'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const LeadsUploadScalarFieldEnum: {
    id: 'id',
    pacingId: 'pacingId',
    uploadedBy: 'uploadedBy',
    filename: 'filename',
    created_at: 'created_at',
    updated_at: 'updated_at',
    results: 'results'
  };

  export type LeadsUploadScalarFieldEnum = (typeof LeadsUploadScalarFieldEnum)[keyof typeof LeadsUploadScalarFieldEnum]


  export const PacingReportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at',
    generatedType: 'generatedType'
  };

  export type PacingReportScalarFieldEnum = (typeof PacingReportScalarFieldEnum)[keyof typeof PacingReportScalarFieldEnum]


  export const CampaignReportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at',
    generatedType: 'generatedType'
  };

  export type CampaignReportScalarFieldEnum = (typeof CampaignReportScalarFieldEnum)[keyof typeof CampaignReportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveDuration'
   */
  export type EnumLeaveDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveDuration'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'SessionType'
   */
  export type EnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskLevel'
   */
  export type EnumTaskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskLevel'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'VolumeStatus'
   */
  export type EnumVolumeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolumeStatus'>
    


  /**
   * Reference to a field of type 'BriefStatus'
   */
  export type EnumBriefStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BriefStatus'>
    


  /**
   * Reference to a field of type 'BriefType'
   */
  export type EnumBriefTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BriefType'>
    


  /**
   * Reference to a field of type 'reportType'
   */
  export type EnumreportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reportType'>
    


  /**
   * Reference to a field of type 'generatedType'
   */
  export type EnumgeneratedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'generatedType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    name?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    uploads?: LeadsUploadListRelationFilter
    roles?: UserroleListRelationFilter
    leaves?: UserLeaveListRelationFilter
    approvedLeaves?: UserLeaveListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    groups?: UserGroupsListRelationFilter
    sentMessage?: GroupMessageListRelationFilter
    tasks?: UserTaskListRelationFilter
    breaks?: UserBreakListRelationFilter
    assignedTasks?: UserTaskListRelationFilter
    sessions?: SessionListRelationFilter
    deliveries?: CampaignDeliveriesListRelationFilter
    attendance?: AttendanceListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uploads?: leadsUploadOrderByRelationAggregateInput
    roles?: userroleOrderByRelationAggregateInput
    leaves?: UserLeaveOrderByRelationAggregateInput
    approvedLeaves?: UserLeaveOrderByRelationAggregateInput
    sentMessages?: messageOrderByRelationAggregateInput
    receivedMessages?: messageOrderByRelationAggregateInput
    groups?: userGroupsOrderByRelationAggregateInput
    sentMessage?: groupMessageOrderByRelationAggregateInput
    tasks?: UserTaskOrderByRelationAggregateInput
    breaks?: UserBreakOrderByRelationAggregateInput
    assignedTasks?: UserTaskOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    deliveries?: campaignDeliveriesOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    uploads?: LeadsUploadListRelationFilter
    roles?: UserroleListRelationFilter
    leaves?: UserLeaveListRelationFilter
    approvedLeaves?: UserLeaveListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    groups?: UserGroupsListRelationFilter
    sentMessage?: GroupMessageListRelationFilter
    tasks?: UserTaskListRelationFilter
    breaks?: UserBreakListRelationFilter
    assignedTasks?: UserTaskListRelationFilter
    sessions?: SessionListRelationFilter
    deliveries?: CampaignDeliveriesListRelationFilter
    attendance?: AttendanceListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    email?: StringWithAggregatesFilter<"user"> | string
    name?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringWithAggregatesFilter<"user"> | string
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: IntFilter<"Attendance"> | number
    userId?: IntFilter<"Attendance"> | number
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_date?: AttendanceUserIdDateCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    userId?: IntFilter<"Attendance"> | number
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "userId_date">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendance"> | number
    userId?: IntWithAggregatesFilter<"Attendance"> | number
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    checkIn?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type UserLeaveWhereInput = {
    AND?: UserLeaveWhereInput | UserLeaveWhereInput[]
    OR?: UserLeaveWhereInput[]
    NOT?: UserLeaveWhereInput | UserLeaveWhereInput[]
    id?: IntFilter<"UserLeave"> | number
    userId?: IntFilter<"UserLeave"> | number
    leaveType?: EnumLeaveTypeFilter<"UserLeave"> | $Enums.LeaveType
    fromDate?: DateTimeFilter<"UserLeave"> | Date | string
    toDate?: DateTimeFilter<"UserLeave"> | Date | string
    duration?: EnumLeaveDurationFilter<"UserLeave"> | $Enums.LeaveDuration
    reason?: StringFilter<"UserLeave"> | string
    status?: EnumLeaveStatusFilter<"UserLeave"> | $Enums.LeaveStatus
    approvedById?: IntNullableFilter<"UserLeave"> | number | null
    created_at?: DateTimeFilter<"UserLeave"> | Date | string
    updated_at?: DateTimeFilter<"UserLeave"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type UserLeaveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
    approvedBy?: userOrderByWithRelationInput
  }

  export type UserLeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserLeaveWhereInput | UserLeaveWhereInput[]
    OR?: UserLeaveWhereInput[]
    NOT?: UserLeaveWhereInput | UserLeaveWhereInput[]
    userId?: IntFilter<"UserLeave"> | number
    leaveType?: EnumLeaveTypeFilter<"UserLeave"> | $Enums.LeaveType
    fromDate?: DateTimeFilter<"UserLeave"> | Date | string
    toDate?: DateTimeFilter<"UserLeave"> | Date | string
    duration?: EnumLeaveDurationFilter<"UserLeave"> | $Enums.LeaveDuration
    reason?: StringFilter<"UserLeave"> | string
    status?: EnumLeaveStatusFilter<"UserLeave"> | $Enums.LeaveStatus
    approvedById?: IntNullableFilter<"UserLeave"> | number | null
    created_at?: DateTimeFilter<"UserLeave"> | Date | string
    updated_at?: DateTimeFilter<"UserLeave"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type UserLeaveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserLeaveCountOrderByAggregateInput
    _avg?: UserLeaveAvgOrderByAggregateInput
    _max?: UserLeaveMaxOrderByAggregateInput
    _min?: UserLeaveMinOrderByAggregateInput
    _sum?: UserLeaveSumOrderByAggregateInput
  }

  export type UserLeaveScalarWhereWithAggregatesInput = {
    AND?: UserLeaveScalarWhereWithAggregatesInput | UserLeaveScalarWhereWithAggregatesInput[]
    OR?: UserLeaveScalarWhereWithAggregatesInput[]
    NOT?: UserLeaveScalarWhereWithAggregatesInput | UserLeaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserLeave"> | number
    userId?: IntWithAggregatesFilter<"UserLeave"> | number
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"UserLeave"> | $Enums.LeaveType
    fromDate?: DateTimeWithAggregatesFilter<"UserLeave"> | Date | string
    toDate?: DateTimeWithAggregatesFilter<"UserLeave"> | Date | string
    duration?: EnumLeaveDurationWithAggregatesFilter<"UserLeave"> | $Enums.LeaveDuration
    reason?: StringWithAggregatesFilter<"UserLeave"> | string
    status?: EnumLeaveStatusWithAggregatesFilter<"UserLeave"> | $Enums.LeaveStatus
    approvedById?: IntNullableWithAggregatesFilter<"UserLeave"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"UserLeave"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UserLeave"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    type?: EnumSessionTypeFilter<"Session"> | $Enums.SessionType
    startTime?: DateTimeFilter<"Session"> | Date | string
    latestLogged?: DateTimeFilter<"Session"> | Date | string
    endTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    userId?: IntFilter<"Session"> | number
    taskId?: IntNullableFilter<"Session"> | number | null
    breakId?: IntNullableFilter<"Session"> | number | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    task?: XOR<UserTaskNullableScalarRelationFilter, UserTaskWhereInput> | null
    break?: XOR<UserBreakNullableScalarRelationFilter, UserBreakWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    latestLogged?: SortOrder
    endTime?: SortOrderInput | SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    breakId?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    task?: UserTaskOrderByWithRelationInput
    break?: UserBreakOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    type?: EnumSessionTypeFilter<"Session"> | $Enums.SessionType
    startTime?: DateTimeFilter<"Session"> | Date | string
    latestLogged?: DateTimeFilter<"Session"> | Date | string
    endTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    userId?: IntFilter<"Session"> | number
    taskId?: IntNullableFilter<"Session"> | number | null
    breakId?: IntNullableFilter<"Session"> | number | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    task?: XOR<UserTaskNullableScalarRelationFilter, UserTaskWhereInput> | null
    break?: XOR<UserBreakNullableScalarRelationFilter, UserBreakWhereInput> | null
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    latestLogged?: SortOrder
    endTime?: SortOrderInput | SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    breakId?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    type?: EnumSessionTypeWithAggregatesFilter<"Session"> | $Enums.SessionType
    startTime?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    latestLogged?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    userId?: IntWithAggregatesFilter<"Session"> | number
    taskId?: IntNullableWithAggregatesFilter<"Session"> | number | null
    breakId?: IntNullableWithAggregatesFilter<"Session"> | number | null
  }

  export type UserTaskWhereInput = {
    AND?: UserTaskWhereInput | UserTaskWhereInput[]
    OR?: UserTaskWhereInput[]
    NOT?: UserTaskWhereInput | UserTaskWhereInput[]
    id?: IntFilter<"UserTask"> | number
    userId?: IntFilter<"UserTask"> | number
    taskId?: IntFilter<"UserTask"> | number
    totalTime?: IntFilter<"UserTask"> | number
    assignedById?: IntFilter<"UserTask"> | number
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    sessions?: SessionListRelationFilter
    assignee?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type UserTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
    user?: userOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    assignee?: userOrderByWithRelationInput
  }

  export type UserTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserTaskWhereInput | UserTaskWhereInput[]
    OR?: UserTaskWhereInput[]
    NOT?: UserTaskWhereInput | UserTaskWhereInput[]
    userId?: IntFilter<"UserTask"> | number
    taskId?: IntFilter<"UserTask"> | number
    totalTime?: IntFilter<"UserTask"> | number
    assignedById?: IntFilter<"UserTask"> | number
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    sessions?: SessionListRelationFilter
    assignee?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type UserTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
    _count?: UserTaskCountOrderByAggregateInput
    _avg?: UserTaskAvgOrderByAggregateInput
    _max?: UserTaskMaxOrderByAggregateInput
    _min?: UserTaskMinOrderByAggregateInput
    _sum?: UserTaskSumOrderByAggregateInput
  }

  export type UserTaskScalarWhereWithAggregatesInput = {
    AND?: UserTaskScalarWhereWithAggregatesInput | UserTaskScalarWhereWithAggregatesInput[]
    OR?: UserTaskScalarWhereWithAggregatesInput[]
    NOT?: UserTaskScalarWhereWithAggregatesInput | UserTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTask"> | number
    userId?: IntWithAggregatesFilter<"UserTask"> | number
    taskId?: IntWithAggregatesFilter<"UserTask"> | number
    totalTime?: IntWithAggregatesFilter<"UserTask"> | number
    assignedById?: IntWithAggregatesFilter<"UserTask"> | number
  }

  export type UserBreakWhereInput = {
    AND?: UserBreakWhereInput | UserBreakWhereInput[]
    OR?: UserBreakWhereInput[]
    NOT?: UserBreakWhereInput | UserBreakWhereInput[]
    id?: IntFilter<"UserBreak"> | number
    userId?: IntFilter<"UserBreak"> | number
    breakId?: IntFilter<"UserBreak"> | number
    totalTime?: IntFilter<"UserBreak"> | number
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    break?: XOR<BreakScalarRelationFilter, BreakWhereInput>
    sessions?: SessionListRelationFilter
  }

  export type UserBreakOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
    user?: userOrderByWithRelationInput
    break?: BreakOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserBreakWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserBreakWhereInput | UserBreakWhereInput[]
    OR?: UserBreakWhereInput[]
    NOT?: UserBreakWhereInput | UserBreakWhereInput[]
    userId?: IntFilter<"UserBreak"> | number
    breakId?: IntFilter<"UserBreak"> | number
    totalTime?: IntFilter<"UserBreak"> | number
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    break?: XOR<BreakScalarRelationFilter, BreakWhereInput>
    sessions?: SessionListRelationFilter
  }, "id">

  export type UserBreakOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
    _count?: UserBreakCountOrderByAggregateInput
    _avg?: UserBreakAvgOrderByAggregateInput
    _max?: UserBreakMaxOrderByAggregateInput
    _min?: UserBreakMinOrderByAggregateInput
    _sum?: UserBreakSumOrderByAggregateInput
  }

  export type UserBreakScalarWhereWithAggregatesInput = {
    AND?: UserBreakScalarWhereWithAggregatesInput | UserBreakScalarWhereWithAggregatesInput[]
    OR?: UserBreakScalarWhereWithAggregatesInput[]
    NOT?: UserBreakScalarWhereWithAggregatesInput | UserBreakScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserBreak"> | number
    userId?: IntWithAggregatesFilter<"UserBreak"> | number
    breakId?: IntWithAggregatesFilter<"UserBreak"> | number
    totalTime?: IntWithAggregatesFilter<"UserBreak"> | number
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    name?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    typeId?: IntNullableFilter<"Task"> | number | null
    status?: StringFilter<"Task"> | string
    level?: EnumTaskLevelFilter<"Task"> | $Enums.TaskLevel
    remark?: StringFilter<"Task"> | string
    reassigned?: BoolFilter<"Task"> | boolean
    users?: UserTaskListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    typeId?: SortOrderInput | SortOrder
    status?: SortOrder
    level?: SortOrder
    remark?: SortOrder
    reassigned?: SortOrder
    users?: UserTaskOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    name?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    typeId?: IntNullableFilter<"Task"> | number | null
    status?: StringFilter<"Task"> | string
    level?: EnumTaskLevelFilter<"Task"> | $Enums.TaskLevel
    remark?: StringFilter<"Task"> | string
    reassigned?: BoolFilter<"Task"> | boolean
    users?: UserTaskListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    typeId?: SortOrderInput | SortOrder
    status?: SortOrder
    level?: SortOrder
    remark?: SortOrder
    reassigned?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    name?: StringWithAggregatesFilter<"Task"> | string
    type?: EnumTaskTypeWithAggregatesFilter<"Task"> | $Enums.TaskType
    typeId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    status?: StringWithAggregatesFilter<"Task"> | string
    level?: EnumTaskLevelWithAggregatesFilter<"Task"> | $Enums.TaskLevel
    remark?: StringWithAggregatesFilter<"Task"> | string
    reassigned?: BoolWithAggregatesFilter<"Task"> | boolean
  }

  export type BreakWhereInput = {
    AND?: BreakWhereInput | BreakWhereInput[]
    OR?: BreakWhereInput[]
    NOT?: BreakWhereInput | BreakWhereInput[]
    id?: IntFilter<"Break"> | number
    name?: StringFilter<"Break"> | string
    users?: UserBreakListRelationFilter
  }

  export type BreakOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserBreakOrderByRelationAggregateInput
  }

  export type BreakWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BreakWhereInput | BreakWhereInput[]
    OR?: BreakWhereInput[]
    NOT?: BreakWhereInput | BreakWhereInput[]
    name?: StringFilter<"Break"> | string
    users?: UserBreakListRelationFilter
  }, "id">

  export type BreakOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BreakCountOrderByAggregateInput
    _avg?: BreakAvgOrderByAggregateInput
    _max?: BreakMaxOrderByAggregateInput
    _min?: BreakMinOrderByAggregateInput
    _sum?: BreakSumOrderByAggregateInput
  }

  export type BreakScalarWhereWithAggregatesInput = {
    AND?: BreakScalarWhereWithAggregatesInput | BreakScalarWhereWithAggregatesInput[]
    OR?: BreakScalarWhereWithAggregatesInput[]
    NOT?: BreakScalarWhereWithAggregatesInput | BreakScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Break"> | number
    name?: StringWithAggregatesFilter<"Break"> | string
  }

  export type messageWhereInput = {
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    id?: IntFilter<"message"> | number
    body?: StringFilter<"message"> | string
    senderId?: IntFilter<"message"> | number
    recipientId?: IntFilter<"message"> | number
    created_at?: DateTimeFilter<"message"> | Date | string
    read_at?: DateTimeNullableFilter<"message"> | Date | string | null
    sender?: XOR<UserScalarRelationFilter, userWhereInput>
    recipient?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type messageOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    sender?: userOrderByWithRelationInput
    recipient?: userOrderByWithRelationInput
  }

  export type messageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    body?: StringFilter<"message"> | string
    senderId?: IntFilter<"message"> | number
    recipientId?: IntFilter<"message"> | number
    created_at?: DateTimeFilter<"message"> | Date | string
    read_at?: DateTimeNullableFilter<"message"> | Date | string | null
    sender?: XOR<UserScalarRelationFilter, userWhereInput>
    recipient?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type messageOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    _count?: messageCountOrderByAggregateInput
    _avg?: messageAvgOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
    _sum?: messageSumOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    OR?: messageScalarWhereWithAggregatesInput[]
    NOT?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"message"> | number
    body?: StringWithAggregatesFilter<"message"> | string
    senderId?: IntWithAggregatesFilter<"message"> | number
    recipientId?: IntWithAggregatesFilter<"message"> | number
    created_at?: DateTimeWithAggregatesFilter<"message"> | Date | string
    read_at?: DateTimeNullableWithAggregatesFilter<"message"> | Date | string | null
  }

  export type groupMessageWhereInput = {
    AND?: groupMessageWhereInput | groupMessageWhereInput[]
    OR?: groupMessageWhereInput[]
    NOT?: groupMessageWhereInput | groupMessageWhereInput[]
    id?: IntFilter<"groupMessage"> | number
    groupId?: IntFilter<"groupMessage"> | number
    body?: StringFilter<"groupMessage"> | string
    senderId?: IntFilter<"groupMessage"> | number
    created_at?: DateTimeFilter<"groupMessage"> | Date | string
    read_at?: DateTimeNullableFilter<"groupMessage"> | Date | string | null
    group?: XOR<GroupScalarRelationFilter, groupWhereInput>
    sender?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type groupMessageOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    group?: groupOrderByWithRelationInput
    sender?: userOrderByWithRelationInput
  }

  export type groupMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: groupMessageWhereInput | groupMessageWhereInput[]
    OR?: groupMessageWhereInput[]
    NOT?: groupMessageWhereInput | groupMessageWhereInput[]
    groupId?: IntFilter<"groupMessage"> | number
    body?: StringFilter<"groupMessage"> | string
    senderId?: IntFilter<"groupMessage"> | number
    created_at?: DateTimeFilter<"groupMessage"> | Date | string
    read_at?: DateTimeNullableFilter<"groupMessage"> | Date | string | null
    group?: XOR<GroupScalarRelationFilter, groupWhereInput>
    sender?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type groupMessageOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    _count?: groupMessageCountOrderByAggregateInput
    _avg?: groupMessageAvgOrderByAggregateInput
    _max?: groupMessageMaxOrderByAggregateInput
    _min?: groupMessageMinOrderByAggregateInput
    _sum?: groupMessageSumOrderByAggregateInput
  }

  export type groupMessageScalarWhereWithAggregatesInput = {
    AND?: groupMessageScalarWhereWithAggregatesInput | groupMessageScalarWhereWithAggregatesInput[]
    OR?: groupMessageScalarWhereWithAggregatesInput[]
    NOT?: groupMessageScalarWhereWithAggregatesInput | groupMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"groupMessage"> | number
    groupId?: IntWithAggregatesFilter<"groupMessage"> | number
    body?: StringWithAggregatesFilter<"groupMessage"> | string
    senderId?: IntWithAggregatesFilter<"groupMessage"> | number
    created_at?: DateTimeWithAggregatesFilter<"groupMessage"> | Date | string
    read_at?: DateTimeNullableWithAggregatesFilter<"groupMessage"> | Date | string | null
  }

  export type groupWhereInput = {
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    id?: IntFilter<"group"> | number
    name?: StringFilter<"group"> | string
    members?: UserGroupsListRelationFilter
    groupMessages?: GroupMessageListRelationFilter
  }

  export type groupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    members?: userGroupsOrderByRelationAggregateInput
    groupMessages?: groupMessageOrderByRelationAggregateInput
  }

  export type groupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    name?: StringFilter<"group"> | string
    members?: UserGroupsListRelationFilter
    groupMessages?: GroupMessageListRelationFilter
  }, "id">

  export type groupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: groupCountOrderByAggregateInput
    _avg?: groupAvgOrderByAggregateInput
    _max?: groupMaxOrderByAggregateInput
    _min?: groupMinOrderByAggregateInput
    _sum?: groupSumOrderByAggregateInput
  }

  export type groupScalarWhereWithAggregatesInput = {
    AND?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    OR?: groupScalarWhereWithAggregatesInput[]
    NOT?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"group"> | number
    name?: StringWithAggregatesFilter<"group"> | string
  }

  export type userGroupsWhereInput = {
    AND?: userGroupsWhereInput | userGroupsWhereInput[]
    OR?: userGroupsWhereInput[]
    NOT?: userGroupsWhereInput | userGroupsWhereInput[]
    userId?: IntFilter<"userGroups"> | number
    groupId?: IntFilter<"userGroups"> | number
    assignedAt?: DateTimeFilter<"userGroups"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    group?: XOR<GroupScalarRelationFilter, groupWhereInput>
  }

  export type userGroupsOrderByWithRelationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    user?: userOrderByWithRelationInput
    group?: groupOrderByWithRelationInput
  }

  export type userGroupsWhereUniqueInput = Prisma.AtLeast<{
    userId_groupId?: userGroupsUserIdGroupIdCompoundUniqueInput
    AND?: userGroupsWhereInput | userGroupsWhereInput[]
    OR?: userGroupsWhereInput[]
    NOT?: userGroupsWhereInput | userGroupsWhereInput[]
    userId?: IntFilter<"userGroups"> | number
    groupId?: IntFilter<"userGroups"> | number
    assignedAt?: DateTimeFilter<"userGroups"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    group?: XOR<GroupScalarRelationFilter, groupWhereInput>
  }, "userId_groupId">

  export type userGroupsOrderByWithAggregationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    _count?: userGroupsCountOrderByAggregateInput
    _avg?: userGroupsAvgOrderByAggregateInput
    _max?: userGroupsMaxOrderByAggregateInput
    _min?: userGroupsMinOrderByAggregateInput
    _sum?: userGroupsSumOrderByAggregateInput
  }

  export type userGroupsScalarWhereWithAggregatesInput = {
    AND?: userGroupsScalarWhereWithAggregatesInput | userGroupsScalarWhereWithAggregatesInput[]
    OR?: userGroupsScalarWhereWithAggregatesInput[]
    NOT?: userGroupsScalarWhereWithAggregatesInput | userGroupsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"userGroups"> | number
    groupId?: IntWithAggregatesFilter<"userGroups"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"userGroups"> | Date | string
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: IntFilter<"notification"> | number
    message?: StringFilter<"notification"> | string
    notificationPriorityId?: IntFilter<"notification"> | number
    createdAt?: DateTimeFilter<"notification"> | Date | string
    url?: StringFilter<"notification"> | string
    type?: StringFilter<"notification"> | string
    notificationPriority?: XOR<NotificationPriorityScalarRelationFilter, notificationPriorityWhereInput>
    roleNotifications?: RoleNotificationListRelationFilter
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    notificationPriorityId?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    type?: SortOrder
    notificationPriority?: notificationPriorityOrderByWithRelationInput
    roleNotifications?: roleNotificationOrderByRelationAggregateInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    message?: StringFilter<"notification"> | string
    notificationPriorityId?: IntFilter<"notification"> | number
    createdAt?: DateTimeFilter<"notification"> | Date | string
    url?: StringFilter<"notification"> | string
    type?: StringFilter<"notification"> | string
    notificationPriority?: XOR<NotificationPriorityScalarRelationFilter, notificationPriorityWhereInput>
    roleNotifications?: RoleNotificationListRelationFilter
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    notificationPriorityId?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    type?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notification"> | number
    message?: StringWithAggregatesFilter<"notification"> | string
    notificationPriorityId?: IntWithAggregatesFilter<"notification"> | number
    createdAt?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    url?: StringWithAggregatesFilter<"notification"> | string
    type?: StringWithAggregatesFilter<"notification"> | string
  }

  export type notificationPriorityWhereInput = {
    AND?: notificationPriorityWhereInput | notificationPriorityWhereInput[]
    OR?: notificationPriorityWhereInput[]
    NOT?: notificationPriorityWhereInput | notificationPriorityWhereInput[]
    id?: IntFilter<"notificationPriority"> | number
    level?: IntFilter<"notificationPriority"> | number
    notifications?: NotificationListRelationFilter
  }

  export type notificationPriorityOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    notifications?: notificationOrderByRelationAggregateInput
  }

  export type notificationPriorityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationPriorityWhereInput | notificationPriorityWhereInput[]
    OR?: notificationPriorityWhereInput[]
    NOT?: notificationPriorityWhereInput | notificationPriorityWhereInput[]
    level?: IntFilter<"notificationPriority"> | number
    notifications?: NotificationListRelationFilter
  }, "id">

  export type notificationPriorityOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    _count?: notificationPriorityCountOrderByAggregateInput
    _avg?: notificationPriorityAvgOrderByAggregateInput
    _max?: notificationPriorityMaxOrderByAggregateInput
    _min?: notificationPriorityMinOrderByAggregateInput
    _sum?: notificationPrioritySumOrderByAggregateInput
  }

  export type notificationPriorityScalarWhereWithAggregatesInput = {
    AND?: notificationPriorityScalarWhereWithAggregatesInput | notificationPriorityScalarWhereWithAggregatesInput[]
    OR?: notificationPriorityScalarWhereWithAggregatesInput[]
    NOT?: notificationPriorityScalarWhereWithAggregatesInput | notificationPriorityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notificationPriority"> | number
    level?: IntWithAggregatesFilter<"notificationPriority"> | number
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: IntFilter<"role"> | number
    name?: StringFilter<"role"> | string
    users?: UserroleListRelationFilter
    roleNotifications?: RoleNotificationListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: userroleOrderByRelationAggregateInput
    roleNotifications?: roleNotificationOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    users?: UserroleListRelationFilter
    roleNotifications?: RoleNotificationListRelationFilter
  }, "id" | "name">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"role"> | number
    name?: StringWithAggregatesFilter<"role"> | string
  }

  export type roleNotificationWhereInput = {
    AND?: roleNotificationWhereInput | roleNotificationWhereInput[]
    OR?: roleNotificationWhereInput[]
    NOT?: roleNotificationWhereInput | roleNotificationWhereInput[]
    roleId?: IntFilter<"roleNotification"> | number
    notificationId?: IntFilter<"roleNotification"> | number
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    notification?: XOR<NotificationScalarRelationFilter, notificationWhereInput>
  }

  export type roleNotificationOrderByWithRelationInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
    role?: roleOrderByWithRelationInput
    notification?: notificationOrderByWithRelationInput
  }

  export type roleNotificationWhereUniqueInput = Prisma.AtLeast<{
    roleId_notificationId?: roleNotificationRoleIdNotificationIdCompoundUniqueInput
    AND?: roleNotificationWhereInput | roleNotificationWhereInput[]
    OR?: roleNotificationWhereInput[]
    NOT?: roleNotificationWhereInput | roleNotificationWhereInput[]
    roleId?: IntFilter<"roleNotification"> | number
    notificationId?: IntFilter<"roleNotification"> | number
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    notification?: XOR<NotificationScalarRelationFilter, notificationWhereInput>
  }, "roleId_notificationId">

  export type roleNotificationOrderByWithAggregationInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
    _count?: roleNotificationCountOrderByAggregateInput
    _avg?: roleNotificationAvgOrderByAggregateInput
    _max?: roleNotificationMaxOrderByAggregateInput
    _min?: roleNotificationMinOrderByAggregateInput
    _sum?: roleNotificationSumOrderByAggregateInput
  }

  export type roleNotificationScalarWhereWithAggregatesInput = {
    AND?: roleNotificationScalarWhereWithAggregatesInput | roleNotificationScalarWhereWithAggregatesInput[]
    OR?: roleNotificationScalarWhereWithAggregatesInput[]
    NOT?: roleNotificationScalarWhereWithAggregatesInput | roleNotificationScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"roleNotification"> | number
    notificationId?: IntWithAggregatesFilter<"roleNotification"> | number
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    id?: IntFilter<"userrole"> | number
    userId?: IntFilter<"userrole"> | number
    roleId?: IntFilter<"userrole"> | number
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    role?: roleOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    userId?: IntFilter<"userrole"> | number
    roleId?: IntFilter<"userrole"> | number
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type userroleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userrole"> | number
    userId?: IntWithAggregatesFilter<"userrole"> | number
    roleId?: IntWithAggregatesFilter<"userrole"> | number
  }

  export type clientWhereInput = {
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    id?: IntFilter<"client"> | number
    name?: StringFilter<"client"> | string
    created_at?: DateTimeFilter<"client"> | Date | string
    updated_at?: DateTimeFilter<"client"> | Date | string
    campaigns?: CampaignListRelationFilter
  }

  export type clientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    campaigns?: campaignOrderByRelationAggregateInput
  }

  export type clientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    name?: StringFilter<"client"> | string
    created_at?: DateTimeFilter<"client"> | Date | string
    updated_at?: DateTimeFilter<"client"> | Date | string
    campaigns?: CampaignListRelationFilter
  }, "id">

  export type clientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: clientCountOrderByAggregateInput
    _avg?: clientAvgOrderByAggregateInput
    _max?: clientMaxOrderByAggregateInput
    _min?: clientMinOrderByAggregateInput
    _sum?: clientSumOrderByAggregateInput
  }

  export type clientScalarWhereWithAggregatesInput = {
    AND?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    OR?: clientScalarWhereWithAggregatesInput[]
    NOT?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"client"> | number
    name?: StringWithAggregatesFilter<"client"> | string
    created_at?: DateTimeWithAggregatesFilter<"client"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"client"> | Date | string
  }

  export type campaignWhereInput = {
    AND?: campaignWhereInput | campaignWhereInput[]
    OR?: campaignWhereInput[]
    NOT?: campaignWhereInput | campaignWhereInput[]
    id?: IntFilter<"campaign"> | number
    name?: StringFilter<"campaign"> | string
    code?: StringFilter<"campaign"> | string
    clientId?: IntFilter<"campaign"> | number
    leadgoal?: IntFilter<"campaign"> | number
    completed?: IntFilter<"campaign"> | number
    pending?: IntFilter<"campaign"> | number
    duedate?: DateTimeFilter<"campaign"> | Date | string
    info?: JsonFilter<"campaign">
    content?: JsonFilter<"campaign">
    filesInfo?: JsonFilter<"campaign">
    updates?: JsonFilter<"campaign">
    created_at?: DateTimeFilter<"campaign"> | Date | string
    updated_at?: DateTimeFilter<"campaign"> | Date | string
    status?: StringFilter<"campaign"> | string
    client?: XOR<ClientScalarRelationFilter, clientWhereInput>
    volumes?: VolumeListRelationFilter
    leads?: LeadListRelationFilter
    campaignDeliveries?: CampaignDeliveriesListRelationFilter
  }

  export type campaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    duedate?: SortOrder
    info?: SortOrder
    content?: SortOrder
    filesInfo?: SortOrder
    updates?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    client?: clientOrderByWithRelationInput
    volumes?: volumeOrderByRelationAggregateInput
    leads?: leadOrderByRelationAggregateInput
    campaignDeliveries?: campaignDeliveriesOrderByRelationAggregateInput
  }

  export type campaignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: campaignWhereInput | campaignWhereInput[]
    OR?: campaignWhereInput[]
    NOT?: campaignWhereInput | campaignWhereInput[]
    name?: StringFilter<"campaign"> | string
    code?: StringFilter<"campaign"> | string
    clientId?: IntFilter<"campaign"> | number
    leadgoal?: IntFilter<"campaign"> | number
    completed?: IntFilter<"campaign"> | number
    pending?: IntFilter<"campaign"> | number
    duedate?: DateTimeFilter<"campaign"> | Date | string
    info?: JsonFilter<"campaign">
    content?: JsonFilter<"campaign">
    filesInfo?: JsonFilter<"campaign">
    updates?: JsonFilter<"campaign">
    created_at?: DateTimeFilter<"campaign"> | Date | string
    updated_at?: DateTimeFilter<"campaign"> | Date | string
    status?: StringFilter<"campaign"> | string
    client?: XOR<ClientScalarRelationFilter, clientWhereInput>
    volumes?: VolumeListRelationFilter
    leads?: LeadListRelationFilter
    campaignDeliveries?: CampaignDeliveriesListRelationFilter
  }, "id">

  export type campaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    duedate?: SortOrder
    info?: SortOrder
    content?: SortOrder
    filesInfo?: SortOrder
    updates?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    _count?: campaignCountOrderByAggregateInput
    _avg?: campaignAvgOrderByAggregateInput
    _max?: campaignMaxOrderByAggregateInput
    _min?: campaignMinOrderByAggregateInput
    _sum?: campaignSumOrderByAggregateInput
  }

  export type campaignScalarWhereWithAggregatesInput = {
    AND?: campaignScalarWhereWithAggregatesInput | campaignScalarWhereWithAggregatesInput[]
    OR?: campaignScalarWhereWithAggregatesInput[]
    NOT?: campaignScalarWhereWithAggregatesInput | campaignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"campaign"> | number
    name?: StringWithAggregatesFilter<"campaign"> | string
    code?: StringWithAggregatesFilter<"campaign"> | string
    clientId?: IntWithAggregatesFilter<"campaign"> | number
    leadgoal?: IntWithAggregatesFilter<"campaign"> | number
    completed?: IntWithAggregatesFilter<"campaign"> | number
    pending?: IntWithAggregatesFilter<"campaign"> | number
    duedate?: DateTimeWithAggregatesFilter<"campaign"> | Date | string
    info?: JsonWithAggregatesFilter<"campaign">
    content?: JsonWithAggregatesFilter<"campaign">
    filesInfo?: JsonWithAggregatesFilter<"campaign">
    updates?: JsonWithAggregatesFilter<"campaign">
    created_at?: DateTimeWithAggregatesFilter<"campaign"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"campaign"> | Date | string
    status?: StringWithAggregatesFilter<"campaign"> | string
  }

  export type campaignDeliveriesWhereInput = {
    AND?: campaignDeliveriesWhereInput | campaignDeliveriesWhereInput[]
    OR?: campaignDeliveriesWhereInput[]
    NOT?: campaignDeliveriesWhereInput | campaignDeliveriesWhereInput[]
    id?: IntFilter<"campaignDeliveries"> | number
    campaignId?: IntFilter<"campaignDeliveries"> | number
    date?: DateTimeFilter<"campaignDeliveries"> | Date | string
    fileName?: StringFilter<"campaignDeliveries"> | string
    submitted?: IntFilter<"campaignDeliveries"> | number
    accepted?: IntFilter<"campaignDeliveries"> | number
    errors?: IntFilter<"campaignDeliveries"> | number
    rejections?: IntFilter<"campaignDeliveries"> | number
    uploaderId?: IntNullableFilter<"campaignDeliveries"> | number | null
    data?: StringFilter<"campaignDeliveries"> | string
    campaign?: XOR<CampaignScalarRelationFilter, campaignWhereInput>
    uploader?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    leads?: LeadListRelationFilter
  }

  export type campaignDeliveriesOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    fileName?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrderInput | SortOrder
    data?: SortOrder
    campaign?: campaignOrderByWithRelationInput
    uploader?: userOrderByWithRelationInput
    leads?: leadOrderByRelationAggregateInput
  }

  export type campaignDeliveriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: campaignDeliveriesWhereInput | campaignDeliveriesWhereInput[]
    OR?: campaignDeliveriesWhereInput[]
    NOT?: campaignDeliveriesWhereInput | campaignDeliveriesWhereInput[]
    campaignId?: IntFilter<"campaignDeliveries"> | number
    date?: DateTimeFilter<"campaignDeliveries"> | Date | string
    fileName?: StringFilter<"campaignDeliveries"> | string
    submitted?: IntFilter<"campaignDeliveries"> | number
    accepted?: IntFilter<"campaignDeliveries"> | number
    errors?: IntFilter<"campaignDeliveries"> | number
    rejections?: IntFilter<"campaignDeliveries"> | number
    uploaderId?: IntNullableFilter<"campaignDeliveries"> | number | null
    data?: StringFilter<"campaignDeliveries"> | string
    campaign?: XOR<CampaignScalarRelationFilter, campaignWhereInput>
    uploader?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    leads?: LeadListRelationFilter
  }, "id">

  export type campaignDeliveriesOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    fileName?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrderInput | SortOrder
    data?: SortOrder
    _count?: campaignDeliveriesCountOrderByAggregateInput
    _avg?: campaignDeliveriesAvgOrderByAggregateInput
    _max?: campaignDeliveriesMaxOrderByAggregateInput
    _min?: campaignDeliveriesMinOrderByAggregateInput
    _sum?: campaignDeliveriesSumOrderByAggregateInput
  }

  export type campaignDeliveriesScalarWhereWithAggregatesInput = {
    AND?: campaignDeliveriesScalarWhereWithAggregatesInput | campaignDeliveriesScalarWhereWithAggregatesInput[]
    OR?: campaignDeliveriesScalarWhereWithAggregatesInput[]
    NOT?: campaignDeliveriesScalarWhereWithAggregatesInput | campaignDeliveriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"campaignDeliveries"> | number
    campaignId?: IntWithAggregatesFilter<"campaignDeliveries"> | number
    date?: DateTimeWithAggregatesFilter<"campaignDeliveries"> | Date | string
    fileName?: StringWithAggregatesFilter<"campaignDeliveries"> | string
    submitted?: IntWithAggregatesFilter<"campaignDeliveries"> | number
    accepted?: IntWithAggregatesFilter<"campaignDeliveries"> | number
    errors?: IntWithAggregatesFilter<"campaignDeliveries"> | number
    rejections?: IntWithAggregatesFilter<"campaignDeliveries"> | number
    uploaderId?: IntNullableWithAggregatesFilter<"campaignDeliveries"> | number | null
    data?: StringWithAggregatesFilter<"campaignDeliveries"> | string
  }

  export type campaignTypeWhereInput = {
    AND?: campaignTypeWhereInput | campaignTypeWhereInput[]
    OR?: campaignTypeWhereInput[]
    NOT?: campaignTypeWhereInput | campaignTypeWhereInput[]
    id?: IntFilter<"campaignType"> | number
    name?: StringFilter<"campaignType"> | string
    campaignId?: IntFilter<"campaignType"> | number
  }

  export type campaignTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
  }

  export type campaignTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: campaignTypeWhereInput | campaignTypeWhereInput[]
    OR?: campaignTypeWhereInput[]
    NOT?: campaignTypeWhereInput | campaignTypeWhereInput[]
    name?: StringFilter<"campaignType"> | string
    campaignId?: IntFilter<"campaignType"> | number
  }, "id">

  export type campaignTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
    _count?: campaignTypeCountOrderByAggregateInput
    _avg?: campaignTypeAvgOrderByAggregateInput
    _max?: campaignTypeMaxOrderByAggregateInput
    _min?: campaignTypeMinOrderByAggregateInput
    _sum?: campaignTypeSumOrderByAggregateInput
  }

  export type campaignTypeScalarWhereWithAggregatesInput = {
    AND?: campaignTypeScalarWhereWithAggregatesInput | campaignTypeScalarWhereWithAggregatesInput[]
    OR?: campaignTypeScalarWhereWithAggregatesInput[]
    NOT?: campaignTypeScalarWhereWithAggregatesInput | campaignTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"campaignType"> | number
    name?: StringWithAggregatesFilter<"campaignType"> | string
    campaignId?: IntWithAggregatesFilter<"campaignType"> | number
  }

  export type volumeWhereInput = {
    AND?: volumeWhereInput | volumeWhereInput[]
    OR?: volumeWhereInput[]
    NOT?: volumeWhereInput | volumeWhereInput[]
    id?: IntFilter<"volume"> | number
    name?: StringFilter<"volume"> | string
    campaignId?: IntFilter<"volume"> | number
    leadGoal?: IntFilter<"volume"> | number
    completed?: IntFilter<"volume"> | number
    pending?: IntFilter<"volume"> | number
    status?: EnumVolumeStatusFilter<"volume"> | $Enums.VolumeStatus
    validationProfile?: JsonFilter<"volume">
    headers?: JsonFilter<"volume">
    leadTemplate?: StringFilter<"volume"> | string
    externalRules?: StringFilter<"volume"> | string
    campaign?: XOR<CampaignScalarRelationFilter, campaignWhereInput>
    pacings?: PacingListRelationFilter
    leads?: LeadListRelationFilter
  }

  export type volumeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    status?: SortOrder
    validationProfile?: SortOrder
    headers?: SortOrder
    leadTemplate?: SortOrder
    externalRules?: SortOrder
    campaign?: campaignOrderByWithRelationInput
    pacings?: pacingOrderByRelationAggregateInput
    leads?: leadOrderByRelationAggregateInput
  }

  export type volumeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: volumeWhereInput | volumeWhereInput[]
    OR?: volumeWhereInput[]
    NOT?: volumeWhereInput | volumeWhereInput[]
    name?: StringFilter<"volume"> | string
    campaignId?: IntFilter<"volume"> | number
    leadGoal?: IntFilter<"volume"> | number
    completed?: IntFilter<"volume"> | number
    pending?: IntFilter<"volume"> | number
    status?: EnumVolumeStatusFilter<"volume"> | $Enums.VolumeStatus
    validationProfile?: JsonFilter<"volume">
    headers?: JsonFilter<"volume">
    leadTemplate?: StringFilter<"volume"> | string
    externalRules?: StringFilter<"volume"> | string
    campaign?: XOR<CampaignScalarRelationFilter, campaignWhereInput>
    pacings?: PacingListRelationFilter
    leads?: LeadListRelationFilter
  }, "id">

  export type volumeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    status?: SortOrder
    validationProfile?: SortOrder
    headers?: SortOrder
    leadTemplate?: SortOrder
    externalRules?: SortOrder
    _count?: volumeCountOrderByAggregateInput
    _avg?: volumeAvgOrderByAggregateInput
    _max?: volumeMaxOrderByAggregateInput
    _min?: volumeMinOrderByAggregateInput
    _sum?: volumeSumOrderByAggregateInput
  }

  export type volumeScalarWhereWithAggregatesInput = {
    AND?: volumeScalarWhereWithAggregatesInput | volumeScalarWhereWithAggregatesInput[]
    OR?: volumeScalarWhereWithAggregatesInput[]
    NOT?: volumeScalarWhereWithAggregatesInput | volumeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"volume"> | number
    name?: StringWithAggregatesFilter<"volume"> | string
    campaignId?: IntWithAggregatesFilter<"volume"> | number
    leadGoal?: IntWithAggregatesFilter<"volume"> | number
    completed?: IntWithAggregatesFilter<"volume"> | number
    pending?: IntWithAggregatesFilter<"volume"> | number
    status?: EnumVolumeStatusWithAggregatesFilter<"volume"> | $Enums.VolumeStatus
    validationProfile?: JsonWithAggregatesFilter<"volume">
    headers?: JsonWithAggregatesFilter<"volume">
    leadTemplate?: StringWithAggregatesFilter<"volume"> | string
    externalRules?: StringWithAggregatesFilter<"volume"> | string
  }

  export type BriefWhereInput = {
    AND?: BriefWhereInput | BriefWhereInput[]
    OR?: BriefWhereInput[]
    NOT?: BriefWhereInput | BriefWhereInput[]
    id?: IntFilter<"Brief"> | number
    name?: StringFilter<"Brief"> | string
    arrivedOn?: DateTimeFilter<"Brief"> | Date | string
    arrivedOnTime?: StringFilter<"Brief"> | string
    dueTime?: StringFilter<"Brief"> | string
    due?: DateTimeFilter<"Brief"> | Date | string
    status?: EnumBriefStatusFilter<"Brief"> | $Enums.BriefStatus
    leadDetails?: JsonNullableFilter<"Brief">
    leadDetailsSection?: StringFilter<"Brief"> | string
    type?: EnumBriefTypeFilter<"Brief"> | $Enums.BriefType
    quotes?: JsonNullableFilter<"Brief">
    campaignId?: IntNullableFilter<"Brief"> | number | null
    remark?: StringNullableFilter<"Brief"> | string | null
    briefHyperlink?: StringNullableFilter<"Brief"> | string | null
    briefUpdates?: BriefUpdatesListRelationFilter
  }

  export type BriefOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    arrivedOn?: SortOrder
    arrivedOnTime?: SortOrder
    dueTime?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetails?: SortOrderInput | SortOrder
    leadDetailsSection?: SortOrder
    type?: SortOrder
    quotes?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    briefHyperlink?: SortOrderInput | SortOrder
    briefUpdates?: BriefUpdatesOrderByRelationAggregateInput
  }

  export type BriefWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BriefWhereInput | BriefWhereInput[]
    OR?: BriefWhereInput[]
    NOT?: BriefWhereInput | BriefWhereInput[]
    name?: StringFilter<"Brief"> | string
    arrivedOn?: DateTimeFilter<"Brief"> | Date | string
    arrivedOnTime?: StringFilter<"Brief"> | string
    dueTime?: StringFilter<"Brief"> | string
    due?: DateTimeFilter<"Brief"> | Date | string
    status?: EnumBriefStatusFilter<"Brief"> | $Enums.BriefStatus
    leadDetails?: JsonNullableFilter<"Brief">
    leadDetailsSection?: StringFilter<"Brief"> | string
    type?: EnumBriefTypeFilter<"Brief"> | $Enums.BriefType
    quotes?: JsonNullableFilter<"Brief">
    campaignId?: IntNullableFilter<"Brief"> | number | null
    remark?: StringNullableFilter<"Brief"> | string | null
    briefHyperlink?: StringNullableFilter<"Brief"> | string | null
    briefUpdates?: BriefUpdatesListRelationFilter
  }, "id">

  export type BriefOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    arrivedOn?: SortOrder
    arrivedOnTime?: SortOrder
    dueTime?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetails?: SortOrderInput | SortOrder
    leadDetailsSection?: SortOrder
    type?: SortOrder
    quotes?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    briefHyperlink?: SortOrderInput | SortOrder
    _count?: BriefCountOrderByAggregateInput
    _avg?: BriefAvgOrderByAggregateInput
    _max?: BriefMaxOrderByAggregateInput
    _min?: BriefMinOrderByAggregateInput
    _sum?: BriefSumOrderByAggregateInput
  }

  export type BriefScalarWhereWithAggregatesInput = {
    AND?: BriefScalarWhereWithAggregatesInput | BriefScalarWhereWithAggregatesInput[]
    OR?: BriefScalarWhereWithAggregatesInput[]
    NOT?: BriefScalarWhereWithAggregatesInput | BriefScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brief"> | number
    name?: StringWithAggregatesFilter<"Brief"> | string
    arrivedOn?: DateTimeWithAggregatesFilter<"Brief"> | Date | string
    arrivedOnTime?: StringWithAggregatesFilter<"Brief"> | string
    dueTime?: StringWithAggregatesFilter<"Brief"> | string
    due?: DateTimeWithAggregatesFilter<"Brief"> | Date | string
    status?: EnumBriefStatusWithAggregatesFilter<"Brief"> | $Enums.BriefStatus
    leadDetails?: JsonNullableWithAggregatesFilter<"Brief">
    leadDetailsSection?: StringWithAggregatesFilter<"Brief"> | string
    type?: EnumBriefTypeWithAggregatesFilter<"Brief"> | $Enums.BriefType
    quotes?: JsonNullableWithAggregatesFilter<"Brief">
    campaignId?: IntNullableWithAggregatesFilter<"Brief"> | number | null
    remark?: StringNullableWithAggregatesFilter<"Brief"> | string | null
    briefHyperlink?: StringNullableWithAggregatesFilter<"Brief"> | string | null
  }

  export type BriefUpdatesWhereInput = {
    AND?: BriefUpdatesWhereInput | BriefUpdatesWhereInput[]
    OR?: BriefUpdatesWhereInput[]
    NOT?: BriefUpdatesWhereInput | BriefUpdatesWhereInput[]
    id?: IntFilter<"BriefUpdates"> | number
    briefId?: IntFilter<"BriefUpdates"> | number
    arrivedOn?: DateTimeFilter<"BriefUpdates"> | Date | string
    due?: DateTimeFilter<"BriefUpdates"> | Date | string
    status?: EnumBriefStatusFilter<"BriefUpdates"> | $Enums.BriefStatus
    leadDetails?: JsonNullableFilter<"BriefUpdates">
    type?: EnumBriefTypeFilter<"BriefUpdates"> | $Enums.BriefType
    quotes?: JsonNullableFilter<"BriefUpdates">
    campaignId?: IntNullableFilter<"BriefUpdates"> | number | null
    remark?: StringNullableFilter<"BriefUpdates"> | string | null
    briefHyperlink?: StringNullableFilter<"BriefUpdates"> | string | null
    breif?: XOR<BriefScalarRelationFilter, BriefWhereInput>
  }

  export type BriefUpdatesOrderByWithRelationInput = {
    id?: SortOrder
    briefId?: SortOrder
    arrivedOn?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetails?: SortOrderInput | SortOrder
    type?: SortOrder
    quotes?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    briefHyperlink?: SortOrderInput | SortOrder
    breif?: BriefOrderByWithRelationInput
  }

  export type BriefUpdatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BriefUpdatesWhereInput | BriefUpdatesWhereInput[]
    OR?: BriefUpdatesWhereInput[]
    NOT?: BriefUpdatesWhereInput | BriefUpdatesWhereInput[]
    briefId?: IntFilter<"BriefUpdates"> | number
    arrivedOn?: DateTimeFilter<"BriefUpdates"> | Date | string
    due?: DateTimeFilter<"BriefUpdates"> | Date | string
    status?: EnumBriefStatusFilter<"BriefUpdates"> | $Enums.BriefStatus
    leadDetails?: JsonNullableFilter<"BriefUpdates">
    type?: EnumBriefTypeFilter<"BriefUpdates"> | $Enums.BriefType
    quotes?: JsonNullableFilter<"BriefUpdates">
    campaignId?: IntNullableFilter<"BriefUpdates"> | number | null
    remark?: StringNullableFilter<"BriefUpdates"> | string | null
    briefHyperlink?: StringNullableFilter<"BriefUpdates"> | string | null
    breif?: XOR<BriefScalarRelationFilter, BriefWhereInput>
  }, "id">

  export type BriefUpdatesOrderByWithAggregationInput = {
    id?: SortOrder
    briefId?: SortOrder
    arrivedOn?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetails?: SortOrderInput | SortOrder
    type?: SortOrder
    quotes?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    briefHyperlink?: SortOrderInput | SortOrder
    _count?: BriefUpdatesCountOrderByAggregateInput
    _avg?: BriefUpdatesAvgOrderByAggregateInput
    _max?: BriefUpdatesMaxOrderByAggregateInput
    _min?: BriefUpdatesMinOrderByAggregateInput
    _sum?: BriefUpdatesSumOrderByAggregateInput
  }

  export type BriefUpdatesScalarWhereWithAggregatesInput = {
    AND?: BriefUpdatesScalarWhereWithAggregatesInput | BriefUpdatesScalarWhereWithAggregatesInput[]
    OR?: BriefUpdatesScalarWhereWithAggregatesInput[]
    NOT?: BriefUpdatesScalarWhereWithAggregatesInput | BriefUpdatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BriefUpdates"> | number
    briefId?: IntWithAggregatesFilter<"BriefUpdates"> | number
    arrivedOn?: DateTimeWithAggregatesFilter<"BriefUpdates"> | Date | string
    due?: DateTimeWithAggregatesFilter<"BriefUpdates"> | Date | string
    status?: EnumBriefStatusWithAggregatesFilter<"BriefUpdates"> | $Enums.BriefStatus
    leadDetails?: JsonNullableWithAggregatesFilter<"BriefUpdates">
    type?: EnumBriefTypeWithAggregatesFilter<"BriefUpdates"> | $Enums.BriefType
    quotes?: JsonNullableWithAggregatesFilter<"BriefUpdates">
    campaignId?: IntNullableWithAggregatesFilter<"BriefUpdates"> | number | null
    remark?: StringNullableWithAggregatesFilter<"BriefUpdates"> | string | null
    briefHyperlink?: StringNullableWithAggregatesFilter<"BriefUpdates"> | string | null
  }

  export type pacingWhereInput = {
    AND?: pacingWhereInput | pacingWhereInput[]
    OR?: pacingWhereInput[]
    NOT?: pacingWhereInput | pacingWhereInput[]
    id?: IntFilter<"pacing"> | number
    volumeId?: IntFilter<"pacing"> | number
    scheduledFor?: DateTimeFilter<"pacing"> | Date | string
    leadGoal?: IntFilter<"pacing"> | number
    status?: StringFilter<"pacing"> | string
    actualLeads?: IntFilter<"pacing"> | number
    created_at?: DateTimeFilter<"pacing"> | Date | string
    updated_at?: DateTimeFilter<"pacing"> | Date | string
    volume?: XOR<VolumeScalarRelationFilter, volumeWhereInput>
    leads?: LeadListRelationFilter
    uploads?: LeadsUploadListRelationFilter
  }

  export type pacingOrderByWithRelationInput = {
    id?: SortOrder
    volumeId?: SortOrder
    scheduledFor?: SortOrder
    leadGoal?: SortOrder
    status?: SortOrder
    actualLeads?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    volume?: volumeOrderByWithRelationInput
    leads?: leadOrderByRelationAggregateInput
    uploads?: leadsUploadOrderByRelationAggregateInput
  }

  export type pacingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pacingWhereInput | pacingWhereInput[]
    OR?: pacingWhereInput[]
    NOT?: pacingWhereInput | pacingWhereInput[]
    volumeId?: IntFilter<"pacing"> | number
    scheduledFor?: DateTimeFilter<"pacing"> | Date | string
    leadGoal?: IntFilter<"pacing"> | number
    status?: StringFilter<"pacing"> | string
    actualLeads?: IntFilter<"pacing"> | number
    created_at?: DateTimeFilter<"pacing"> | Date | string
    updated_at?: DateTimeFilter<"pacing"> | Date | string
    volume?: XOR<VolumeScalarRelationFilter, volumeWhereInput>
    leads?: LeadListRelationFilter
    uploads?: LeadsUploadListRelationFilter
  }, "id">

  export type pacingOrderByWithAggregationInput = {
    id?: SortOrder
    volumeId?: SortOrder
    scheduledFor?: SortOrder
    leadGoal?: SortOrder
    status?: SortOrder
    actualLeads?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: pacingCountOrderByAggregateInput
    _avg?: pacingAvgOrderByAggregateInput
    _max?: pacingMaxOrderByAggregateInput
    _min?: pacingMinOrderByAggregateInput
    _sum?: pacingSumOrderByAggregateInput
  }

  export type pacingScalarWhereWithAggregatesInput = {
    AND?: pacingScalarWhereWithAggregatesInput | pacingScalarWhereWithAggregatesInput[]
    OR?: pacingScalarWhereWithAggregatesInput[]
    NOT?: pacingScalarWhereWithAggregatesInput | pacingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pacing"> | number
    volumeId?: IntWithAggregatesFilter<"pacing"> | number
    scheduledFor?: DateTimeWithAggregatesFilter<"pacing"> | Date | string
    leadGoal?: IntWithAggregatesFilter<"pacing"> | number
    status?: StringWithAggregatesFilter<"pacing"> | string
    actualLeads?: IntWithAggregatesFilter<"pacing"> | number
    created_at?: DateTimeWithAggregatesFilter<"pacing"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"pacing"> | Date | string
  }

  export type leadWhereInput = {
    AND?: leadWhereInput | leadWhereInput[]
    OR?: leadWhereInput[]
    NOT?: leadWhereInput | leadWhereInput[]
    id?: IntFilter<"lead"> | number
    data?: JsonFilter<"lead">
    email?: StringFilter<"lead"> | string
    campaignId?: IntFilter<"lead"> | number
    pacingId?: IntFilter<"lead"> | number
    volumeId?: IntFilter<"lead"> | number
    uploadId?: IntNullableFilter<"lead"> | number | null
    uploadType?: StringFilter<"lead"> | string
    created_at?: DateTimeFilter<"lead"> | Date | string
    updated_at?: DateTimeFilter<"lead"> | Date | string
    phase1Validation?: BoolFilter<"lead"> | boolean
    leadTemplateValidation?: BoolFilter<"lead"> | boolean
    campaignDeliveryId?: IntNullableFilter<"lead"> | number | null
    accepted?: BoolFilter<"lead"> | boolean
    pending?: BoolFilter<"lead"> | boolean
    rejected?: BoolFilter<"lead"> | boolean
    rejectedReason?: StringFilter<"lead"> | string
    campaign?: XOR<CampaignScalarRelationFilter, campaignWhereInput>
    pacing?: XOR<PacingScalarRelationFilter, pacingWhereInput>
    volume?: XOR<VolumeScalarRelationFilter, volumeWhereInput>
    upload?: XOR<LeadsUploadNullableScalarRelationFilter, leadsUploadWhereInput> | null
    campaignDelivery?: XOR<CampaignDeliveriesNullableScalarRelationFilter, campaignDeliveriesWhereInput> | null
  }

  export type leadOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    email?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrderInput | SortOrder
    uploadType?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phase1Validation?: SortOrder
    leadTemplateValidation?: SortOrder
    campaignDeliveryId?: SortOrderInput | SortOrder
    accepted?: SortOrder
    pending?: SortOrder
    rejected?: SortOrder
    rejectedReason?: SortOrder
    campaign?: campaignOrderByWithRelationInput
    pacing?: pacingOrderByWithRelationInput
    volume?: volumeOrderByWithRelationInput
    upload?: leadsUploadOrderByWithRelationInput
    campaignDelivery?: campaignDeliveriesOrderByWithRelationInput
  }

  export type leadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    campaignId_email?: leadCampaignIdEmailCompoundUniqueInput
    AND?: leadWhereInput | leadWhereInput[]
    OR?: leadWhereInput[]
    NOT?: leadWhereInput | leadWhereInput[]
    data?: JsonFilter<"lead">
    email?: StringFilter<"lead"> | string
    campaignId?: IntFilter<"lead"> | number
    pacingId?: IntFilter<"lead"> | number
    volumeId?: IntFilter<"lead"> | number
    uploadId?: IntNullableFilter<"lead"> | number | null
    uploadType?: StringFilter<"lead"> | string
    created_at?: DateTimeFilter<"lead"> | Date | string
    updated_at?: DateTimeFilter<"lead"> | Date | string
    phase1Validation?: BoolFilter<"lead"> | boolean
    leadTemplateValidation?: BoolFilter<"lead"> | boolean
    campaignDeliveryId?: IntNullableFilter<"lead"> | number | null
    accepted?: BoolFilter<"lead"> | boolean
    pending?: BoolFilter<"lead"> | boolean
    rejected?: BoolFilter<"lead"> | boolean
    rejectedReason?: StringFilter<"lead"> | string
    campaign?: XOR<CampaignScalarRelationFilter, campaignWhereInput>
    pacing?: XOR<PacingScalarRelationFilter, pacingWhereInput>
    volume?: XOR<VolumeScalarRelationFilter, volumeWhereInput>
    upload?: XOR<LeadsUploadNullableScalarRelationFilter, leadsUploadWhereInput> | null
    campaignDelivery?: XOR<CampaignDeliveriesNullableScalarRelationFilter, campaignDeliveriesWhereInput> | null
  }, "id" | "campaignId_email">

  export type leadOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    email?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrderInput | SortOrder
    uploadType?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phase1Validation?: SortOrder
    leadTemplateValidation?: SortOrder
    campaignDeliveryId?: SortOrderInput | SortOrder
    accepted?: SortOrder
    pending?: SortOrder
    rejected?: SortOrder
    rejectedReason?: SortOrder
    _count?: leadCountOrderByAggregateInput
    _avg?: leadAvgOrderByAggregateInput
    _max?: leadMaxOrderByAggregateInput
    _min?: leadMinOrderByAggregateInput
    _sum?: leadSumOrderByAggregateInput
  }

  export type leadScalarWhereWithAggregatesInput = {
    AND?: leadScalarWhereWithAggregatesInput | leadScalarWhereWithAggregatesInput[]
    OR?: leadScalarWhereWithAggregatesInput[]
    NOT?: leadScalarWhereWithAggregatesInput | leadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lead"> | number
    data?: JsonWithAggregatesFilter<"lead">
    email?: StringWithAggregatesFilter<"lead"> | string
    campaignId?: IntWithAggregatesFilter<"lead"> | number
    pacingId?: IntWithAggregatesFilter<"lead"> | number
    volumeId?: IntWithAggregatesFilter<"lead"> | number
    uploadId?: IntNullableWithAggregatesFilter<"lead"> | number | null
    uploadType?: StringWithAggregatesFilter<"lead"> | string
    created_at?: DateTimeWithAggregatesFilter<"lead"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"lead"> | Date | string
    phase1Validation?: BoolWithAggregatesFilter<"lead"> | boolean
    leadTemplateValidation?: BoolWithAggregatesFilter<"lead"> | boolean
    campaignDeliveryId?: IntNullableWithAggregatesFilter<"lead"> | number | null
    accepted?: BoolWithAggregatesFilter<"lead"> | boolean
    pending?: BoolWithAggregatesFilter<"lead"> | boolean
    rejected?: BoolWithAggregatesFilter<"lead"> | boolean
    rejectedReason?: StringWithAggregatesFilter<"lead"> | string
  }

  export type leadsUploadWhereInput = {
    AND?: leadsUploadWhereInput | leadsUploadWhereInput[]
    OR?: leadsUploadWhereInput[]
    NOT?: leadsUploadWhereInput | leadsUploadWhereInput[]
    id?: IntFilter<"leadsUpload"> | number
    pacingId?: IntFilter<"leadsUpload"> | number
    uploadedBy?: IntNullableFilter<"leadsUpload"> | number | null
    filename?: StringNullableFilter<"leadsUpload"> | string | null
    created_at?: DateTimeFilter<"leadsUpload"> | Date | string
    updated_at?: DateTimeFilter<"leadsUpload"> | Date | string
    results?: JsonFilter<"leadsUpload">
    pacing?: XOR<PacingScalarRelationFilter, pacingWhereInput>
    leads?: LeadListRelationFilter
    uploader?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type leadsUploadOrderByWithRelationInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    results?: SortOrder
    pacing?: pacingOrderByWithRelationInput
    leads?: leadOrderByRelationAggregateInput
    uploader?: userOrderByWithRelationInput
  }

  export type leadsUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: leadsUploadWhereInput | leadsUploadWhereInput[]
    OR?: leadsUploadWhereInput[]
    NOT?: leadsUploadWhereInput | leadsUploadWhereInput[]
    pacingId?: IntFilter<"leadsUpload"> | number
    uploadedBy?: IntNullableFilter<"leadsUpload"> | number | null
    filename?: StringNullableFilter<"leadsUpload"> | string | null
    created_at?: DateTimeFilter<"leadsUpload"> | Date | string
    updated_at?: DateTimeFilter<"leadsUpload"> | Date | string
    results?: JsonFilter<"leadsUpload">
    pacing?: XOR<PacingScalarRelationFilter, pacingWhereInput>
    leads?: LeadListRelationFilter
    uploader?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type leadsUploadOrderByWithAggregationInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    results?: SortOrder
    _count?: leadsUploadCountOrderByAggregateInput
    _avg?: leadsUploadAvgOrderByAggregateInput
    _max?: leadsUploadMaxOrderByAggregateInput
    _min?: leadsUploadMinOrderByAggregateInput
    _sum?: leadsUploadSumOrderByAggregateInput
  }

  export type leadsUploadScalarWhereWithAggregatesInput = {
    AND?: leadsUploadScalarWhereWithAggregatesInput | leadsUploadScalarWhereWithAggregatesInput[]
    OR?: leadsUploadScalarWhereWithAggregatesInput[]
    NOT?: leadsUploadScalarWhereWithAggregatesInput | leadsUploadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"leadsUpload"> | number
    pacingId?: IntWithAggregatesFilter<"leadsUpload"> | number
    uploadedBy?: IntNullableWithAggregatesFilter<"leadsUpload"> | number | null
    filename?: StringNullableWithAggregatesFilter<"leadsUpload"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"leadsUpload"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"leadsUpload"> | Date | string
    results?: JsonWithAggregatesFilter<"leadsUpload">
  }

  export type pacingReportWhereInput = {
    AND?: pacingReportWhereInput | pacingReportWhereInput[]
    OR?: pacingReportWhereInput[]
    NOT?: pacingReportWhereInput | pacingReportWhereInput[]
    id?: IntFilter<"pacingReport"> | number
    type?: EnumreportTypeFilter<"pacingReport"> | $Enums.reportType
    data?: JsonFilter<"pacingReport">
    created_at?: DateTimeFilter<"pacingReport"> | Date | string
    updated_at?: DateTimeFilter<"pacingReport"> | Date | string
    generatedType?: EnumgeneratedTypeFilter<"pacingReport"> | $Enums.generatedType
  }

  export type pacingReportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type pacingReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pacingReportWhereInput | pacingReportWhereInput[]
    OR?: pacingReportWhereInput[]
    NOT?: pacingReportWhereInput | pacingReportWhereInput[]
    type?: EnumreportTypeFilter<"pacingReport"> | $Enums.reportType
    data?: JsonFilter<"pacingReport">
    created_at?: DateTimeFilter<"pacingReport"> | Date | string
    updated_at?: DateTimeFilter<"pacingReport"> | Date | string
    generatedType?: EnumgeneratedTypeFilter<"pacingReport"> | $Enums.generatedType
  }, "id">

  export type pacingReportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
    _count?: pacingReportCountOrderByAggregateInput
    _avg?: pacingReportAvgOrderByAggregateInput
    _max?: pacingReportMaxOrderByAggregateInput
    _min?: pacingReportMinOrderByAggregateInput
    _sum?: pacingReportSumOrderByAggregateInput
  }

  export type pacingReportScalarWhereWithAggregatesInput = {
    AND?: pacingReportScalarWhereWithAggregatesInput | pacingReportScalarWhereWithAggregatesInput[]
    OR?: pacingReportScalarWhereWithAggregatesInput[]
    NOT?: pacingReportScalarWhereWithAggregatesInput | pacingReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pacingReport"> | number
    type?: EnumreportTypeWithAggregatesFilter<"pacingReport"> | $Enums.reportType
    data?: JsonWithAggregatesFilter<"pacingReport">
    created_at?: DateTimeWithAggregatesFilter<"pacingReport"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"pacingReport"> | Date | string
    generatedType?: EnumgeneratedTypeWithAggregatesFilter<"pacingReport"> | $Enums.generatedType
  }

  export type campaignReportWhereInput = {
    AND?: campaignReportWhereInput | campaignReportWhereInput[]
    OR?: campaignReportWhereInput[]
    NOT?: campaignReportWhereInput | campaignReportWhereInput[]
    id?: IntFilter<"campaignReport"> | number
    type?: EnumreportTypeFilter<"campaignReport"> | $Enums.reportType
    data?: JsonFilter<"campaignReport">
    created_at?: DateTimeFilter<"campaignReport"> | Date | string
    updated_at?: DateTimeFilter<"campaignReport"> | Date | string
    generatedType?: EnumgeneratedTypeFilter<"campaignReport"> | $Enums.generatedType
  }

  export type campaignReportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type campaignReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: campaignReportWhereInput | campaignReportWhereInput[]
    OR?: campaignReportWhereInput[]
    NOT?: campaignReportWhereInput | campaignReportWhereInput[]
    type?: EnumreportTypeFilter<"campaignReport"> | $Enums.reportType
    data?: JsonFilter<"campaignReport">
    created_at?: DateTimeFilter<"campaignReport"> | Date | string
    updated_at?: DateTimeFilter<"campaignReport"> | Date | string
    generatedType?: EnumgeneratedTypeFilter<"campaignReport"> | $Enums.generatedType
  }, "id">

  export type campaignReportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
    _count?: campaignReportCountOrderByAggregateInput
    _avg?: campaignReportAvgOrderByAggregateInput
    _max?: campaignReportMaxOrderByAggregateInput
    _min?: campaignReportMinOrderByAggregateInput
    _sum?: campaignReportSumOrderByAggregateInput
  }

  export type campaignReportScalarWhereWithAggregatesInput = {
    AND?: campaignReportScalarWhereWithAggregatesInput | campaignReportScalarWhereWithAggregatesInput[]
    OR?: campaignReportScalarWhereWithAggregatesInput[]
    NOT?: campaignReportScalarWhereWithAggregatesInput | campaignReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"campaignReport"> | number
    type?: EnumreportTypeWithAggregatesFilter<"campaignReport"> | $Enums.reportType
    data?: JsonWithAggregatesFilter<"campaignReport">
    created_at?: DateTimeWithAggregatesFilter<"campaignReport"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"campaignReport"> | Date | string
    generatedType?: EnumgeneratedTypeWithAggregatesFilter<"campaignReport"> | $Enums.generatedType
  }

  export type userCreateInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    date?: Date | string
    checkIn?: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
    user: userCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: number
    userId: number
    date?: Date | string
    checkIn?: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: number
    userId: number
    date?: Date | string
    checkIn?: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLeaveCreateInput = {
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutLeavesInput
    approvedBy?: userCreateNestedOneWithoutApprovedLeavesInput
  }

  export type UserLeaveUncheckedCreateInput = {
    id?: number
    userId: number
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserLeaveUpdateInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutLeavesNestedInput
    approvedBy?: userUpdateOneWithoutApprovedLeavesNestedInput
  }

  export type UserLeaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLeaveCreateManyInput = {
    id?: number
    userId: number
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserLeaveUpdateManyMutationInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLeaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    user: userCreateNestedOneWithoutSessionsInput
    task?: UserTaskCreateNestedOneWithoutSessionsInput
    break?: UserBreakCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    userId: number
    taskId?: number | null
    breakId?: number | null
  }

  export type SessionUpdateInput = {
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSessionsNestedInput
    task?: UserTaskUpdateOneWithoutSessionsNestedInput
    break?: UserBreakUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    breakId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateManyInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    userId: number
    taskId?: number | null
    breakId?: number | null
  }

  export type SessionUpdateManyMutationInput = {
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    breakId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserTaskCreateInput = {
    totalTime: number
    user: userCreateNestedOneWithoutTasksInput
    task: TaskCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutTaskInput
    assignee: userCreateNestedOneWithoutAssignedTasksInput
  }

  export type UserTaskUncheckedCreateInput = {
    id?: number
    userId: number
    taskId: number
    totalTime: number
    assignedById: number
    sessions?: SessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type UserTaskUpdateInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutTasksNestedInput
    task?: TaskUpdateOneRequiredWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutTaskNestedInput
    assignee?: userUpdateOneRequiredWithoutAssignedTasksNestedInput
  }

  export type UserTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserTaskCreateManyInput = {
    id?: number
    userId: number
    taskId: number
    totalTime: number
    assignedById: number
  }

  export type UserTaskUpdateManyMutationInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type UserTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakCreateInput = {
    totalTime: number
    user: userCreateNestedOneWithoutBreaksInput
    break: BreakCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutBreakInput
  }

  export type UserBreakUncheckedCreateInput = {
    id?: number
    userId: number
    breakId: number
    totalTime: number
    sessions?: SessionUncheckedCreateNestedManyWithoutBreakInput
  }

  export type UserBreakUpdateInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutBreaksNestedInput
    break?: BreakUpdateOneRequiredWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutBreakNestedInput
  }

  export type UserBreakUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    breakId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutBreakNestedInput
  }

  export type UserBreakCreateManyInput = {
    id?: number
    userId: number
    breakId: number
    totalTime: number
  }

  export type UserBreakUpdateManyMutationInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    breakId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type TaskCreateInput = {
    name: string
    type: $Enums.TaskType
    typeId?: number | null
    status: string
    level: $Enums.TaskLevel
    remark: string
    reassigned?: boolean
    users?: UserTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    name: string
    type: $Enums.TaskType
    typeId?: number | null
    status: string
    level: $Enums.TaskLevel
    remark: string
    reassigned?: boolean
    users?: UserTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    level?: EnumTaskLevelFieldUpdateOperationsInput | $Enums.TaskLevel
    remark?: StringFieldUpdateOperationsInput | string
    reassigned?: BoolFieldUpdateOperationsInput | boolean
    users?: UserTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    level?: EnumTaskLevelFieldUpdateOperationsInput | $Enums.TaskLevel
    remark?: StringFieldUpdateOperationsInput | string
    reassigned?: BoolFieldUpdateOperationsInput | boolean
    users?: UserTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    name: string
    type: $Enums.TaskType
    typeId?: number | null
    status: string
    level: $Enums.TaskLevel
    remark: string
    reassigned?: boolean
  }

  export type TaskUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    level?: EnumTaskLevelFieldUpdateOperationsInput | $Enums.TaskLevel
    remark?: StringFieldUpdateOperationsInput | string
    reassigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    level?: EnumTaskLevelFieldUpdateOperationsInput | $Enums.TaskLevel
    remark?: StringFieldUpdateOperationsInput | string
    reassigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BreakCreateInput = {
    name: string
    users?: UserBreakCreateNestedManyWithoutBreakInput
  }

  export type BreakUncheckedCreateInput = {
    id?: number
    name: string
    users?: UserBreakUncheckedCreateNestedManyWithoutBreakInput
  }

  export type BreakUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserBreakUpdateManyWithoutBreakNestedInput
  }

  export type BreakUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserBreakUncheckedUpdateManyWithoutBreakNestedInput
  }

  export type BreakCreateManyInput = {
    id?: number
    name: string
  }

  export type BreakUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BreakUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type messageCreateInput = {
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
    sender: userCreateNestedOneWithoutSentMessagesInput
    recipient: userCreateNestedOneWithoutReceivedMessagesInput
  }

  export type messageUncheckedCreateInput = {
    id?: number
    body: string
    senderId: number
    recipientId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type messageUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: userUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: userUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type messageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    recipientId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageCreateManyInput = {
    id?: number
    body: string
    senderId: number
    recipientId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type messageUpdateManyMutationInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    recipientId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupMessageCreateInput = {
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
    group: groupCreateNestedOneWithoutGroupMessagesInput
    sender: userCreateNestedOneWithoutSentMessageInput
  }

  export type groupMessageUncheckedCreateInput = {
    id?: number
    groupId: number
    body: string
    senderId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type groupMessageUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: groupUpdateOneRequiredWithoutGroupMessagesNestedInput
    sender?: userUpdateOneRequiredWithoutSentMessageNestedInput
  }

  export type groupMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupMessageCreateManyInput = {
    id?: number
    groupId: number
    body: string
    senderId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type groupMessageUpdateManyMutationInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupCreateInput = {
    name: string
    members?: userGroupsCreateNestedManyWithoutGroupInput
    groupMessages?: groupMessageCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateInput = {
    id?: number
    name: string
    members?: userGroupsUncheckedCreateNestedManyWithoutGroupInput
    groupMessages?: groupMessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    members?: userGroupsUpdateManyWithoutGroupNestedInput
    groupMessages?: groupMessageUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    members?: userGroupsUncheckedUpdateManyWithoutGroupNestedInput
    groupMessages?: groupMessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type groupCreateManyInput = {
    id?: number
    name: string
  }

  export type groupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type groupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type userGroupsCreateInput = {
    assignedAt?: Date | string
    user: userCreateNestedOneWithoutGroupsInput
    group: groupCreateNestedOneWithoutMembersInput
  }

  export type userGroupsUncheckedCreateInput = {
    userId: number
    groupId: number
    assignedAt?: Date | string
  }

  export type userGroupsUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutGroupsNestedInput
    group?: groupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type userGroupsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userGroupsCreateManyInput = {
    userId: number
    groupId: number
    assignedAt?: Date | string
  }

  export type userGroupsUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userGroupsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationCreateInput = {
    message: string
    createdAt?: Date | string
    url: string
    type: string
    notificationPriority: notificationPriorityCreateNestedOneWithoutNotificationsInput
    roleNotifications?: roleNotificationCreateNestedManyWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id?: number
    message: string
    notificationPriorityId: number
    createdAt?: Date | string
    url: string
    type: string
    roleNotifications?: roleNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type notificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    notificationPriority?: notificationPriorityUpdateOneRequiredWithoutNotificationsNestedInput
    roleNotifications?: roleNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    notificationPriorityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    roleNotifications?: roleNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type notificationCreateManyInput = {
    id?: number
    message: string
    notificationPriorityId: number
    createdAt?: Date | string
    url: string
    type: string
  }

  export type notificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    notificationPriorityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type notificationPriorityCreateInput = {
    level: number
    notifications?: notificationCreateNestedManyWithoutNotificationPriorityInput
  }

  export type notificationPriorityUncheckedCreateInput = {
    id?: number
    level: number
    notifications?: notificationUncheckedCreateNestedManyWithoutNotificationPriorityInput
  }

  export type notificationPriorityUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    notifications?: notificationUpdateManyWithoutNotificationPriorityNestedInput
  }

  export type notificationPriorityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    notifications?: notificationUncheckedUpdateManyWithoutNotificationPriorityNestedInput
  }

  export type notificationPriorityCreateManyInput = {
    id?: number
    level: number
  }

  export type notificationPriorityUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
  }

  export type notificationPriorityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type roleCreateInput = {
    name?: string
    users?: userroleCreateNestedManyWithoutRoleInput
    roleNotifications?: roleNotificationCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    id?: number
    name?: string
    users?: userroleUncheckedCreateNestedManyWithoutRoleInput
    roleNotifications?: roleNotificationUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: userroleUpdateManyWithoutRoleNestedInput
    roleNotifications?: roleNotificationUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: userroleUncheckedUpdateManyWithoutRoleNestedInput
    roleNotifications?: roleNotificationUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    id?: number
    name?: string
  }

  export type roleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roleNotificationCreateInput = {
    role: roleCreateNestedOneWithoutRoleNotificationsInput
    notification: notificationCreateNestedOneWithoutRoleNotificationsInput
  }

  export type roleNotificationUncheckedCreateInput = {
    roleId: number
    notificationId: number
  }

  export type roleNotificationUpdateInput = {
    role?: roleUpdateOneRequiredWithoutRoleNotificationsNestedInput
    notification?: notificationUpdateOneRequiredWithoutRoleNotificationsNestedInput
  }

  export type roleNotificationUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
  }

  export type roleNotificationCreateManyInput = {
    roleId: number
    notificationId: number
  }

  export type roleNotificationUpdateManyMutationInput = {

  }

  export type roleNotificationUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleCreateInput = {
    role?: roleCreateNestedOneWithoutUsersInput
    user: userCreateNestedOneWithoutRolesInput
  }

  export type userroleUncheckedCreateInput = {
    id?: number
    userId: number
    roleId?: number
  }

  export type userroleUpdateInput = {
    role?: roleUpdateOneRequiredWithoutUsersNestedInput
    user?: userUpdateOneRequiredWithoutRolesNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleCreateManyInput = {
    id?: number
    userId: number
    roleId?: number
  }

  export type userroleUpdateManyMutationInput = {

  }

  export type userroleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type clientCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    campaigns?: campaignCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    campaigns?: campaignUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: campaignUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: campaignUncheckedUpdateManyWithoutClientNestedInput
  }

  export type clientCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type clientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type campaignCreateInput = {
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    client: clientCreateNestedOneWithoutCampaignsInput
    volumes?: volumeCreateNestedManyWithoutCampaignInput
    leads?: leadCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesCreateNestedManyWithoutCampaignInput
  }

  export type campaignUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    clientId: number
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    volumes?: volumeUncheckedCreateNestedManyWithoutCampaignInput
    leads?: leadUncheckedCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type campaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateOneRequiredWithoutCampaignsNestedInput
    volumes?: volumeUpdateManyWithoutCampaignNestedInput
    leads?: leadUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUpdateManyWithoutCampaignNestedInput
  }

  export type campaignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    volumes?: volumeUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: leadUncheckedUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type campaignCreateManyInput = {
    id?: number
    name: string
    code: string
    clientId: number
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type campaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type campaignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type campaignDeliveriesCreateInput = {
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    data?: string
    campaign?: campaignCreateNestedOneWithoutCampaignDeliveriesInput
    uploader?: userCreateNestedOneWithoutDeliveriesInput
    leads?: leadCreateNestedManyWithoutCampaignDeliveryInput
  }

  export type campaignDeliveriesUncheckedCreateInput = {
    id?: number
    campaignId?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    uploaderId?: number | null
    data?: string
    leads?: leadUncheckedCreateNestedManyWithoutCampaignDeliveryInput
  }

  export type campaignDeliveriesUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutCampaignDeliveriesNestedInput
    uploader?: userUpdateOneWithoutDeliveriesNestedInput
    leads?: leadUpdateManyWithoutCampaignDeliveryNestedInput
  }

  export type campaignDeliveriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    uploaderId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: StringFieldUpdateOperationsInput | string
    leads?: leadUncheckedUpdateManyWithoutCampaignDeliveryNestedInput
  }

  export type campaignDeliveriesCreateManyInput = {
    id?: number
    campaignId?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    uploaderId?: number | null
    data?: string
  }

  export type campaignDeliveriesUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type campaignDeliveriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    uploaderId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: StringFieldUpdateOperationsInput | string
  }

  export type campaignTypeCreateInput = {
    name: string
    campaignId: number
  }

  export type campaignTypeUncheckedCreateInput = {
    id?: number
    name: string
    campaignId: number
  }

  export type campaignTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
  }

  export type campaignTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
  }

  export type campaignTypeCreateManyInput = {
    id?: number
    name: string
    campaignId: number
  }

  export type campaignTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
  }

  export type campaignTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
  }

  export type volumeCreateInput = {
    name: string
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    campaign: campaignCreateNestedOneWithoutVolumesInput
    pacings?: pacingCreateNestedManyWithoutVolumeInput
    leads?: leadCreateNestedManyWithoutVolumeInput
  }

  export type volumeUncheckedCreateInput = {
    id?: number
    name: string
    campaignId: number
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    pacings?: pacingUncheckedCreateNestedManyWithoutVolumeInput
    leads?: leadUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type volumeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutVolumesNestedInput
    pacings?: pacingUpdateManyWithoutVolumeNestedInput
    leads?: leadUpdateManyWithoutVolumeNestedInput
  }

  export type volumeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    pacings?: pacingUncheckedUpdateManyWithoutVolumeNestedInput
    leads?: leadUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type volumeCreateManyInput = {
    id?: number
    name: string
    campaignId: number
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
  }

  export type volumeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
  }

  export type volumeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
  }

  export type BriefCreateInput = {
    name: string
    arrivedOn: Date | string
    arrivedOnTime?: string
    dueTime?: string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: string
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
    briefUpdates?: BriefUpdatesCreateNestedManyWithoutBreifInput
  }

  export type BriefUncheckedCreateInput = {
    id?: number
    name: string
    arrivedOn: Date | string
    arrivedOnTime?: string
    dueTime?: string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: string
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
    briefUpdates?: BriefUpdatesUncheckedCreateNestedManyWithoutBreifInput
  }

  export type BriefUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivedOnTime?: StringFieldUpdateOperationsInput | string
    dueTime?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: StringFieldUpdateOperationsInput | string
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
    briefUpdates?: BriefUpdatesUpdateManyWithoutBreifNestedInput
  }

  export type BriefUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivedOnTime?: StringFieldUpdateOperationsInput | string
    dueTime?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: StringFieldUpdateOperationsInput | string
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
    briefUpdates?: BriefUpdatesUncheckedUpdateManyWithoutBreifNestedInput
  }

  export type BriefCreateManyInput = {
    id?: number
    name: string
    arrivedOn: Date | string
    arrivedOnTime?: string
    dueTime?: string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: string
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivedOnTime?: StringFieldUpdateOperationsInput | string
    dueTime?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: StringFieldUpdateOperationsInput | string
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivedOnTime?: StringFieldUpdateOperationsInput | string
    dueTime?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: StringFieldUpdateOperationsInput | string
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUpdatesCreateInput = {
    arrivedOn: Date | string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
    breif: BriefCreateNestedOneWithoutBriefUpdatesInput
  }

  export type BriefUpdatesUncheckedCreateInput = {
    id?: number
    briefId: number
    arrivedOn: Date | string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUpdatesUpdateInput = {
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
    breif?: BriefUpdateOneRequiredWithoutBriefUpdatesNestedInput
  }

  export type BriefUpdatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    briefId?: IntFieldUpdateOperationsInput | number
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUpdatesCreateManyInput = {
    id?: number
    briefId: number
    arrivedOn: Date | string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUpdatesUpdateManyMutationInput = {
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUpdatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    briefId?: IntFieldUpdateOperationsInput | number
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pacingCreateInput = {
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    volume: volumeCreateNestedOneWithoutPacingsInput
    leads?: leadCreateNestedManyWithoutPacingInput
    uploads?: leadsUploadCreateNestedManyWithoutPacingInput
  }

  export type pacingUncheckedCreateInput = {
    id?: number
    volumeId: number
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    leads?: leadUncheckedCreateNestedManyWithoutPacingInput
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutPacingInput
  }

  export type pacingUpdateInput = {
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: volumeUpdateOneRequiredWithoutPacingsNestedInput
    leads?: leadUpdateManyWithoutPacingNestedInput
    uploads?: leadsUploadUpdateManyWithoutPacingNestedInput
  }

  export type pacingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: leadUncheckedUpdateManyWithoutPacingNestedInput
    uploads?: leadsUploadUncheckedUpdateManyWithoutPacingNestedInput
  }

  export type pacingCreateManyInput = {
    id?: number
    volumeId: number
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type pacingUpdateManyMutationInput = {
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pacingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leadCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    email: string
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
    campaign: campaignCreateNestedOneWithoutLeadsInput
    pacing: pacingCreateNestedOneWithoutLeadsInput
    volume: volumeCreateNestedOneWithoutLeadsInput
    upload?: leadsUploadCreateNestedOneWithoutLeadsInput
    campaignDelivery?: campaignDeliveriesCreateNestedOneWithoutLeadsInput
  }

  export type leadUncheckedCreateInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutLeadsNestedInput
    pacing?: pacingUpdateOneRequiredWithoutLeadsNestedInput
    volume?: volumeUpdateOneRequiredWithoutLeadsNestedInput
    upload?: leadsUploadUpdateOneWithoutLeadsNestedInput
    campaignDelivery?: campaignDeliveriesUpdateOneWithoutLeadsNestedInput
  }

  export type leadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadCreateManyInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadsUploadCreateInput = {
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    pacing: pacingCreateNestedOneWithoutUploadsInput
    leads?: leadCreateNestedManyWithoutUploadInput
    uploader?: userCreateNestedOneWithoutUploadsInput
  }

  export type leadsUploadUncheckedCreateInput = {
    id?: number
    pacingId: number
    uploadedBy?: number | null
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    leads?: leadUncheckedCreateNestedManyWithoutUploadInput
  }

  export type leadsUploadUpdateInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    pacing?: pacingUpdateOneRequiredWithoutUploadsNestedInput
    leads?: leadUpdateManyWithoutUploadNestedInput
    uploader?: userUpdateOneWithoutUploadsNestedInput
  }

  export type leadsUploadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    leads?: leadUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type leadsUploadCreateManyInput = {
    id?: number
    pacingId: number
    uploadedBy?: number | null
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
  }

  export type leadsUploadUpdateManyMutationInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
  }

  export type leadsUploadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
  }

  export type pacingReportCreateInput = {
    type: $Enums.reportType
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    generatedType: $Enums.generatedType
  }

  export type pacingReportUncheckedCreateInput = {
    id?: number
    type: $Enums.reportType
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    generatedType: $Enums.generatedType
  }

  export type pacingReportUpdateInput = {
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type pacingReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type pacingReportCreateManyInput = {
    id?: number
    type: $Enums.reportType
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    generatedType: $Enums.generatedType
  }

  export type pacingReportUpdateManyMutationInput = {
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type pacingReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type campaignReportCreateInput = {
    type: $Enums.reportType
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    generatedType: $Enums.generatedType
  }

  export type campaignReportUncheckedCreateInput = {
    id?: number
    type: $Enums.reportType
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    generatedType: $Enums.generatedType
  }

  export type campaignReportUpdateInput = {
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type campaignReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type campaignReportCreateManyInput = {
    id?: number
    type: $Enums.reportType
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    generatedType: $Enums.generatedType
  }

  export type campaignReportUpdateManyMutationInput = {
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type campaignReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumreportTypeFieldUpdateOperationsInput | $Enums.reportType
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedType?: EnumgeneratedTypeFieldUpdateOperationsInput | $Enums.generatedType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LeadsUploadListRelationFilter = {
    every?: leadsUploadWhereInput
    some?: leadsUploadWhereInput
    none?: leadsUploadWhereInput
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type UserLeaveListRelationFilter = {
    every?: UserLeaveWhereInput
    some?: UserLeaveWhereInput
    none?: UserLeaveWhereInput
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type UserGroupsListRelationFilter = {
    every?: userGroupsWhereInput
    some?: userGroupsWhereInput
    none?: userGroupsWhereInput
  }

  export type GroupMessageListRelationFilter = {
    every?: groupMessageWhereInput
    some?: groupMessageWhereInput
    none?: groupMessageWhereInput
  }

  export type UserTaskListRelationFilter = {
    every?: UserTaskWhereInput
    some?: UserTaskWhereInput
    none?: UserTaskWhereInput
  }

  export type UserBreakListRelationFilter = {
    every?: UserBreakWhereInput
    some?: UserBreakWhereInput
    none?: UserBreakWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type CampaignDeliveriesListRelationFilter = {
    every?: campaignDeliveriesWhereInput
    some?: campaignDeliveriesWhereInput
    none?: campaignDeliveriesWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type leadsUploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBreakOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type campaignDeliveriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type AttendanceUserIdDateCompoundUniqueInput = {
    userId: number
    date: Date | string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type EnumLeaveDurationFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveDuration | EnumLeaveDurationFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveDuration[]
    notIn?: $Enums.LeaveDuration[]
    not?: NestedEnumLeaveDurationFilter<$PrismaModel> | $Enums.LeaveDuration
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type UserLeaveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserLeaveAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedById?: SortOrder
  }

  export type UserLeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserLeaveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserLeaveSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type EnumLeaveDurationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveDuration | EnumLeaveDurationFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveDuration[]
    notIn?: $Enums.LeaveDuration[]
    not?: NestedEnumLeaveDurationWithAggregatesFilter<$PrismaModel> | $Enums.LeaveDuration
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveDurationFilter<$PrismaModel>
    _max?: NestedEnumLeaveDurationFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[]
    notIn?: $Enums.SessionType[]
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type UserTaskNullableScalarRelationFilter = {
    is?: UserTaskWhereInput | null
    isNot?: UserTaskWhereInput | null
  }

  export type UserBreakNullableScalarRelationFilter = {
    is?: UserBreakWhereInput | null
    isNot?: UserBreakWhereInput | null
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    latestLogged?: SortOrder
    endTime?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    breakId?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    breakId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    latestLogged?: SortOrder
    endTime?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    breakId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    latestLogged?: SortOrder
    endTime?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    breakId?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    breakId?: SortOrder
  }

  export type EnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[]
    notIn?: $Enums.SessionType[]
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type UserTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
  }

  export type UserTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
  }

  export type UserTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
  }

  export type UserTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
  }

  export type UserTaskSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    totalTime?: SortOrder
    assignedById?: SortOrder
  }

  export type BreakScalarRelationFilter = {
    is?: BreakWhereInput
    isNot?: BreakWhereInput
  }

  export type UserBreakCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
  }

  export type UserBreakAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
  }

  export type UserBreakMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
  }

  export type UserBreakMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
  }

  export type UserBreakSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    breakId?: SortOrder
    totalTime?: SortOrder
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type EnumTaskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLevel | EnumTaskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLevel[]
    notIn?: $Enums.TaskLevel[]
    not?: NestedEnumTaskLevelFilter<$PrismaModel> | $Enums.TaskLevel
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    typeId?: SortOrder
    status?: SortOrder
    level?: SortOrder
    remark?: SortOrder
    reassigned?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    typeId?: SortOrder
    status?: SortOrder
    level?: SortOrder
    remark?: SortOrder
    reassigned?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    typeId?: SortOrder
    status?: SortOrder
    level?: SortOrder
    remark?: SortOrder
    reassigned?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type EnumTaskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLevel | EnumTaskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLevel[]
    notIn?: $Enums.TaskLevel[]
    not?: NestedEnumTaskLevelWithAggregatesFilter<$PrismaModel> | $Enums.TaskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskLevelFilter<$PrismaModel>
    _max?: NestedEnumTaskLevelFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BreakCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BreakAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BreakMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BreakMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BreakSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type messageCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
  }

  export type messageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
  }

  export type messageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: groupWhereInput
    isNot?: groupWhereInput
  }

  export type groupMessageCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
  }

  export type groupMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
  }

  export type groupMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
  }

  export type groupMessageMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    body?: SortOrder
    senderId?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
  }

  export type groupMessageSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
  }

  export type groupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type groupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type groupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type groupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type groupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userGroupsUserIdGroupIdCompoundUniqueInput = {
    userId: number
    groupId: number
  }

  export type userGroupsCountOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
  }

  export type userGroupsAvgOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type userGroupsMaxOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
  }

  export type userGroupsMinOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
  }

  export type userGroupsSumOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type NotificationPriorityScalarRelationFilter = {
    is?: notificationPriorityWhereInput
    isNot?: notificationPriorityWhereInput
  }

  export type RoleNotificationListRelationFilter = {
    every?: roleNotificationWhereInput
    some?: roleNotificationWhereInput
    none?: roleNotificationWhereInput
  }

  export type roleNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    notificationPriorityId?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    id?: SortOrder
    notificationPriorityId?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    notificationPriorityId?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    notificationPriorityId?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    id?: SortOrder
    notificationPriorityId?: SortOrder
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationPriorityCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type notificationPriorityAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type notificationPriorityMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type notificationPriorityMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type notificationPrioritySumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type NotificationScalarRelationFilter = {
    is?: notificationWhereInput
    isNot?: notificationWhereInput
  }

  export type roleNotificationRoleIdNotificationIdCompoundUniqueInput = {
    roleId: number
    notificationId: number
  }

  export type roleNotificationCountOrderByAggregateInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
  }

  export type roleNotificationAvgOrderByAggregateInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
  }

  export type roleNotificationMaxOrderByAggregateInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
  }

  export type roleNotificationMinOrderByAggregateInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
  }

  export type roleNotificationSumOrderByAggregateInput = {
    roleId?: SortOrder
    notificationId?: SortOrder
  }

  export type userroleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type CampaignListRelationFilter = {
    every?: campaignWhereInput
    some?: campaignWhereInput
    none?: campaignWhereInput
  }

  export type campaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type clientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClientScalarRelationFilter = {
    is?: clientWhereInput
    isNot?: clientWhereInput
  }

  export type VolumeListRelationFilter = {
    every?: volumeWhereInput
    some?: volumeWhereInput
    none?: volumeWhereInput
  }

  export type LeadListRelationFilter = {
    every?: leadWhereInput
    some?: leadWhereInput
    none?: leadWhereInput
  }

  export type volumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type leadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type campaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    duedate?: SortOrder
    info?: SortOrder
    content?: SortOrder
    filesInfo?: SortOrder
    updates?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
  }

  export type campaignAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
  }

  export type campaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    duedate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
  }

  export type campaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    duedate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
  }

  export type campaignSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    leadgoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CampaignScalarRelationFilter = {
    is?: campaignWhereInput
    isNot?: campaignWhereInput
  }

  export type campaignDeliveriesCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    fileName?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrder
    data?: SortOrder
  }

  export type campaignDeliveriesAvgOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrder
  }

  export type campaignDeliveriesMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    fileName?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrder
    data?: SortOrder
  }

  export type campaignDeliveriesMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    fileName?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrder
    data?: SortOrder
  }

  export type campaignDeliveriesSumOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    submitted?: SortOrder
    accepted?: SortOrder
    errors?: SortOrder
    rejections?: SortOrder
    uploaderId?: SortOrder
  }

  export type campaignTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
  }

  export type campaignTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
  }

  export type campaignTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
  }

  export type campaignTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
  }

  export type campaignTypeSumOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
  }

  export type EnumVolumeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VolumeStatus | EnumVolumeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolumeStatus[]
    notIn?: $Enums.VolumeStatus[]
    not?: NestedEnumVolumeStatusFilter<$PrismaModel> | $Enums.VolumeStatus
  }

  export type PacingListRelationFilter = {
    every?: pacingWhereInput
    some?: pacingWhereInput
    none?: pacingWhereInput
  }

  export type pacingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type volumeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    status?: SortOrder
    validationProfile?: SortOrder
    headers?: SortOrder
    leadTemplate?: SortOrder
    externalRules?: SortOrder
  }

  export type volumeAvgOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
  }

  export type volumeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    status?: SortOrder
    leadTemplate?: SortOrder
    externalRules?: SortOrder
  }

  export type volumeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
    status?: SortOrder
    leadTemplate?: SortOrder
    externalRules?: SortOrder
  }

  export type volumeSumOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadGoal?: SortOrder
    completed?: SortOrder
    pending?: SortOrder
  }

  export type EnumVolumeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VolumeStatus | EnumVolumeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolumeStatus[]
    notIn?: $Enums.VolumeStatus[]
    not?: NestedEnumVolumeStatusWithAggregatesFilter<$PrismaModel> | $Enums.VolumeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVolumeStatusFilter<$PrismaModel>
    _max?: NestedEnumVolumeStatusFilter<$PrismaModel>
  }

  export type EnumBriefStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefStatus | EnumBriefStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BriefStatus[]
    notIn?: $Enums.BriefStatus[]
    not?: NestedEnumBriefStatusFilter<$PrismaModel> | $Enums.BriefStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumBriefTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefType | EnumBriefTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BriefType[]
    notIn?: $Enums.BriefType[]
    not?: NestedEnumBriefTypeFilter<$PrismaModel> | $Enums.BriefType
  }

  export type BriefUpdatesListRelationFilter = {
    every?: BriefUpdatesWhereInput
    some?: BriefUpdatesWhereInput
    none?: BriefUpdatesWhereInput
  }

  export type BriefUpdatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BriefCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    arrivedOn?: SortOrder
    arrivedOnTime?: SortOrder
    dueTime?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetails?: SortOrder
    leadDetailsSection?: SortOrder
    type?: SortOrder
    quotes?: SortOrder
    campaignId?: SortOrder
    remark?: SortOrder
    briefHyperlink?: SortOrder
  }

  export type BriefAvgOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
  }

  export type BriefMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    arrivedOn?: SortOrder
    arrivedOnTime?: SortOrder
    dueTime?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetailsSection?: SortOrder
    type?: SortOrder
    campaignId?: SortOrder
    remark?: SortOrder
    briefHyperlink?: SortOrder
  }

  export type BriefMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    arrivedOn?: SortOrder
    arrivedOnTime?: SortOrder
    dueTime?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetailsSection?: SortOrder
    type?: SortOrder
    campaignId?: SortOrder
    remark?: SortOrder
    briefHyperlink?: SortOrder
  }

  export type BriefSumOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
  }

  export type EnumBriefStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefStatus | EnumBriefStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BriefStatus[]
    notIn?: $Enums.BriefStatus[]
    not?: NestedEnumBriefStatusWithAggregatesFilter<$PrismaModel> | $Enums.BriefStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBriefStatusFilter<$PrismaModel>
    _max?: NestedEnumBriefStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumBriefTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefType | EnumBriefTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BriefType[]
    notIn?: $Enums.BriefType[]
    not?: NestedEnumBriefTypeWithAggregatesFilter<$PrismaModel> | $Enums.BriefType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBriefTypeFilter<$PrismaModel>
    _max?: NestedEnumBriefTypeFilter<$PrismaModel>
  }

  export type BriefScalarRelationFilter = {
    is?: BriefWhereInput
    isNot?: BriefWhereInput
  }

  export type BriefUpdatesCountOrderByAggregateInput = {
    id?: SortOrder
    briefId?: SortOrder
    arrivedOn?: SortOrder
    due?: SortOrder
    status?: SortOrder
    leadDetails?: SortOrder
    type?: SortOrder
    quotes?: SortOrder
    campaignId?: SortOrder
    remark?: SortOrder
    briefHyperlink?: SortOrder
  }

  export type BriefUpdatesAvgOrderByAggregateInput = {
    id?: SortOrder
    briefId?: SortOrder
    campaignId?: SortOrder
  }

  export type BriefUpdatesMaxOrderByAggregateInput = {
    id?: SortOrder
    briefId?: SortOrder
    arrivedOn?: SortOrder
    due?: SortOrder
    status?: SortOrder
    type?: SortOrder
    campaignId?: SortOrder
    remark?: SortOrder
    briefHyperlink?: SortOrder
  }

  export type BriefUpdatesMinOrderByAggregateInput = {
    id?: SortOrder
    briefId?: SortOrder
    arrivedOn?: SortOrder
    due?: SortOrder
    status?: SortOrder
    type?: SortOrder
    campaignId?: SortOrder
    remark?: SortOrder
    briefHyperlink?: SortOrder
  }

  export type BriefUpdatesSumOrderByAggregateInput = {
    id?: SortOrder
    briefId?: SortOrder
    campaignId?: SortOrder
  }

  export type VolumeScalarRelationFilter = {
    is?: volumeWhereInput
    isNot?: volumeWhereInput
  }

  export type pacingCountOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    scheduledFor?: SortOrder
    leadGoal?: SortOrder
    status?: SortOrder
    actualLeads?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type pacingAvgOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    leadGoal?: SortOrder
    actualLeads?: SortOrder
  }

  export type pacingMaxOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    scheduledFor?: SortOrder
    leadGoal?: SortOrder
    status?: SortOrder
    actualLeads?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type pacingMinOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    scheduledFor?: SortOrder
    leadGoal?: SortOrder
    status?: SortOrder
    actualLeads?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type pacingSumOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    leadGoal?: SortOrder
    actualLeads?: SortOrder
  }

  export type PacingScalarRelationFilter = {
    is?: pacingWhereInput
    isNot?: pacingWhereInput
  }

  export type LeadsUploadNullableScalarRelationFilter = {
    is?: leadsUploadWhereInput | null
    isNot?: leadsUploadWhereInput | null
  }

  export type CampaignDeliveriesNullableScalarRelationFilter = {
    is?: campaignDeliveriesWhereInput | null
    isNot?: campaignDeliveriesWhereInput | null
  }

  export type leadCampaignIdEmailCompoundUniqueInput = {
    campaignId: number
    email: string
  }

  export type leadCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    email?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrder
    uploadType?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phase1Validation?: SortOrder
    leadTemplateValidation?: SortOrder
    campaignDeliveryId?: SortOrder
    accepted?: SortOrder
    pending?: SortOrder
    rejected?: SortOrder
    rejectedReason?: SortOrder
  }

  export type leadAvgOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrder
    campaignDeliveryId?: SortOrder
  }

  export type leadMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrder
    uploadType?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phase1Validation?: SortOrder
    leadTemplateValidation?: SortOrder
    campaignDeliveryId?: SortOrder
    accepted?: SortOrder
    pending?: SortOrder
    rejected?: SortOrder
    rejectedReason?: SortOrder
  }

  export type leadMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrder
    uploadType?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phase1Validation?: SortOrder
    leadTemplateValidation?: SortOrder
    campaignDeliveryId?: SortOrder
    accepted?: SortOrder
    pending?: SortOrder
    rejected?: SortOrder
    rejectedReason?: SortOrder
  }

  export type leadSumOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    pacingId?: SortOrder
    volumeId?: SortOrder
    uploadId?: SortOrder
    campaignDeliveryId?: SortOrder
  }

  export type leadsUploadCountOrderByAggregateInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrder
    filename?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    results?: SortOrder
  }

  export type leadsUploadAvgOrderByAggregateInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type leadsUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrder
    filename?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type leadsUploadMinOrderByAggregateInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrder
    filename?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type leadsUploadSumOrderByAggregateInput = {
    id?: SortOrder
    pacingId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type EnumreportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.reportType | EnumreportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.reportType[]
    notIn?: $Enums.reportType[]
    not?: NestedEnumreportTypeFilter<$PrismaModel> | $Enums.reportType
  }

  export type EnumgeneratedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedType | EnumgeneratedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedType[]
    notIn?: $Enums.generatedType[]
    not?: NestedEnumgeneratedTypeFilter<$PrismaModel> | $Enums.generatedType
  }

  export type pacingReportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type pacingReportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pacingReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type pacingReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type pacingReportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumreportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reportType | EnumreportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.reportType[]
    notIn?: $Enums.reportType[]
    not?: NestedEnumreportTypeWithAggregatesFilter<$PrismaModel> | $Enums.reportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreportTypeFilter<$PrismaModel>
    _max?: NestedEnumreportTypeFilter<$PrismaModel>
  }

  export type EnumgeneratedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedType | EnumgeneratedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedType[]
    notIn?: $Enums.generatedType[]
    not?: NestedEnumgeneratedTypeWithAggregatesFilter<$PrismaModel> | $Enums.generatedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgeneratedTypeFilter<$PrismaModel>
    _max?: NestedEnumgeneratedTypeFilter<$PrismaModel>
  }

  export type campaignReportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type campaignReportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type campaignReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type campaignReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    generatedType?: SortOrder
  }

  export type campaignReportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type leadsUploadCreateNestedManyWithoutUploaderInput = {
    create?: XOR<leadsUploadCreateWithoutUploaderInput, leadsUploadUncheckedCreateWithoutUploaderInput> | leadsUploadCreateWithoutUploaderInput[] | leadsUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutUploaderInput | leadsUploadCreateOrConnectWithoutUploaderInput[]
    createMany?: leadsUploadCreateManyUploaderInputEnvelope
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type UserLeaveCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLeaveCreateWithoutUserInput, UserLeaveUncheckedCreateWithoutUserInput> | UserLeaveCreateWithoutUserInput[] | UserLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutUserInput | UserLeaveCreateOrConnectWithoutUserInput[]
    createMany?: UserLeaveCreateManyUserInputEnvelope
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
  }

  export type UserLeaveCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<UserLeaveCreateWithoutApprovedByInput, UserLeaveUncheckedCreateWithoutApprovedByInput> | UserLeaveCreateWithoutApprovedByInput[] | UserLeaveUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutApprovedByInput | UserLeaveCreateOrConnectWithoutApprovedByInput[]
    createMany?: UserLeaveCreateManyApprovedByInputEnvelope
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutSenderInput = {
    create?: XOR<messageCreateWithoutSenderInput, messageUncheckedCreateWithoutSenderInput> | messageCreateWithoutSenderInput[] | messageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: messageCreateOrConnectWithoutSenderInput | messageCreateOrConnectWithoutSenderInput[]
    createMany?: messageCreateManySenderInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<messageCreateWithoutRecipientInput, messageUncheckedCreateWithoutRecipientInput> | messageCreateWithoutRecipientInput[] | messageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRecipientInput | messageCreateOrConnectWithoutRecipientInput[]
    createMany?: messageCreateManyRecipientInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type userGroupsCreateNestedManyWithoutUserInput = {
    create?: XOR<userGroupsCreateWithoutUserInput, userGroupsUncheckedCreateWithoutUserInput> | userGroupsCreateWithoutUserInput[] | userGroupsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutUserInput | userGroupsCreateOrConnectWithoutUserInput[]
    createMany?: userGroupsCreateManyUserInputEnvelope
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
  }

  export type groupMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<groupMessageCreateWithoutSenderInput, groupMessageUncheckedCreateWithoutSenderInput> | groupMessageCreateWithoutSenderInput[] | groupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutSenderInput | groupMessageCreateOrConnectWithoutSenderInput[]
    createMany?: groupMessageCreateManySenderInputEnvelope
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
  }

  export type UserTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTaskCreateWithoutUserInput, UserTaskUncheckedCreateWithoutUserInput> | UserTaskCreateWithoutUserInput[] | UserTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutUserInput | UserTaskCreateOrConnectWithoutUserInput[]
    createMany?: UserTaskCreateManyUserInputEnvelope
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
  }

  export type UserBreakCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBreakCreateWithoutUserInput, UserBreakUncheckedCreateWithoutUserInput> | UserBreakCreateWithoutUserInput[] | UserBreakUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutUserInput | UserBreakCreateOrConnectWithoutUserInput[]
    createMany?: UserBreakCreateManyUserInputEnvelope
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
  }

  export type UserTaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<UserTaskCreateWithoutAssigneeInput, UserTaskUncheckedCreateWithoutAssigneeInput> | UserTaskCreateWithoutAssigneeInput[] | UserTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutAssigneeInput | UserTaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: UserTaskCreateManyAssigneeInputEnvelope
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type campaignDeliveriesCreateNestedManyWithoutUploaderInput = {
    create?: XOR<campaignDeliveriesCreateWithoutUploaderInput, campaignDeliveriesUncheckedCreateWithoutUploaderInput> | campaignDeliveriesCreateWithoutUploaderInput[] | campaignDeliveriesUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutUploaderInput | campaignDeliveriesCreateOrConnectWithoutUploaderInput[]
    createMany?: campaignDeliveriesCreateManyUploaderInputEnvelope
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type leadsUploadUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<leadsUploadCreateWithoutUploaderInput, leadsUploadUncheckedCreateWithoutUploaderInput> | leadsUploadCreateWithoutUploaderInput[] | leadsUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutUploaderInput | leadsUploadCreateOrConnectWithoutUploaderInput[]
    createMany?: leadsUploadCreateManyUploaderInputEnvelope
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type UserLeaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLeaveCreateWithoutUserInput, UserLeaveUncheckedCreateWithoutUserInput> | UserLeaveCreateWithoutUserInput[] | UserLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutUserInput | UserLeaveCreateOrConnectWithoutUserInput[]
    createMany?: UserLeaveCreateManyUserInputEnvelope
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
  }

  export type UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<UserLeaveCreateWithoutApprovedByInput, UserLeaveUncheckedCreateWithoutApprovedByInput> | UserLeaveCreateWithoutApprovedByInput[] | UserLeaveUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutApprovedByInput | UserLeaveCreateOrConnectWithoutApprovedByInput[]
    createMany?: UserLeaveCreateManyApprovedByInputEnvelope
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<messageCreateWithoutSenderInput, messageUncheckedCreateWithoutSenderInput> | messageCreateWithoutSenderInput[] | messageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: messageCreateOrConnectWithoutSenderInput | messageCreateOrConnectWithoutSenderInput[]
    createMany?: messageCreateManySenderInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<messageCreateWithoutRecipientInput, messageUncheckedCreateWithoutRecipientInput> | messageCreateWithoutRecipientInput[] | messageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRecipientInput | messageCreateOrConnectWithoutRecipientInput[]
    createMany?: messageCreateManyRecipientInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type userGroupsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userGroupsCreateWithoutUserInput, userGroupsUncheckedCreateWithoutUserInput> | userGroupsCreateWithoutUserInput[] | userGroupsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutUserInput | userGroupsCreateOrConnectWithoutUserInput[]
    createMany?: userGroupsCreateManyUserInputEnvelope
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
  }

  export type groupMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<groupMessageCreateWithoutSenderInput, groupMessageUncheckedCreateWithoutSenderInput> | groupMessageCreateWithoutSenderInput[] | groupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutSenderInput | groupMessageCreateOrConnectWithoutSenderInput[]
    createMany?: groupMessageCreateManySenderInputEnvelope
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
  }

  export type UserTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTaskCreateWithoutUserInput, UserTaskUncheckedCreateWithoutUserInput> | UserTaskCreateWithoutUserInput[] | UserTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutUserInput | UserTaskCreateOrConnectWithoutUserInput[]
    createMany?: UserTaskCreateManyUserInputEnvelope
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
  }

  export type UserBreakUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBreakCreateWithoutUserInput, UserBreakUncheckedCreateWithoutUserInput> | UserBreakCreateWithoutUserInput[] | UserBreakUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutUserInput | UserBreakCreateOrConnectWithoutUserInput[]
    createMany?: UserBreakCreateManyUserInputEnvelope
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
  }

  export type UserTaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<UserTaskCreateWithoutAssigneeInput, UserTaskUncheckedCreateWithoutAssigneeInput> | UserTaskCreateWithoutAssigneeInput[] | UserTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutAssigneeInput | UserTaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: UserTaskCreateManyAssigneeInputEnvelope
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<campaignDeliveriesCreateWithoutUploaderInput, campaignDeliveriesUncheckedCreateWithoutUploaderInput> | campaignDeliveriesCreateWithoutUploaderInput[] | campaignDeliveriesUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutUploaderInput | campaignDeliveriesCreateOrConnectWithoutUploaderInput[]
    createMany?: campaignDeliveriesCreateManyUploaderInputEnvelope
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type leadsUploadUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<leadsUploadCreateWithoutUploaderInput, leadsUploadUncheckedCreateWithoutUploaderInput> | leadsUploadCreateWithoutUploaderInput[] | leadsUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutUploaderInput | leadsUploadCreateOrConnectWithoutUploaderInput[]
    upsert?: leadsUploadUpsertWithWhereUniqueWithoutUploaderInput | leadsUploadUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: leadsUploadCreateManyUploaderInputEnvelope
    set?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    disconnect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    delete?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    update?: leadsUploadUpdateWithWhereUniqueWithoutUploaderInput | leadsUploadUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: leadsUploadUpdateManyWithWhereWithoutUploaderInput | leadsUploadUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: leadsUploadScalarWhereInput | leadsUploadScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type UserLeaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLeaveCreateWithoutUserInput, UserLeaveUncheckedCreateWithoutUserInput> | UserLeaveCreateWithoutUserInput[] | UserLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutUserInput | UserLeaveCreateOrConnectWithoutUserInput[]
    upsert?: UserLeaveUpsertWithWhereUniqueWithoutUserInput | UserLeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLeaveCreateManyUserInputEnvelope
    set?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    disconnect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    delete?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    update?: UserLeaveUpdateWithWhereUniqueWithoutUserInput | UserLeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLeaveUpdateManyWithWhereWithoutUserInput | UserLeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLeaveScalarWhereInput | UserLeaveScalarWhereInput[]
  }

  export type UserLeaveUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<UserLeaveCreateWithoutApprovedByInput, UserLeaveUncheckedCreateWithoutApprovedByInput> | UserLeaveCreateWithoutApprovedByInput[] | UserLeaveUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutApprovedByInput | UserLeaveCreateOrConnectWithoutApprovedByInput[]
    upsert?: UserLeaveUpsertWithWhereUniqueWithoutApprovedByInput | UserLeaveUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: UserLeaveCreateManyApprovedByInputEnvelope
    set?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    disconnect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    delete?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    update?: UserLeaveUpdateWithWhereUniqueWithoutApprovedByInput | UserLeaveUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: UserLeaveUpdateManyWithWhereWithoutApprovedByInput | UserLeaveUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: UserLeaveScalarWhereInput | UserLeaveScalarWhereInput[]
  }

  export type messageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<messageCreateWithoutSenderInput, messageUncheckedCreateWithoutSenderInput> | messageCreateWithoutSenderInput[] | messageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: messageCreateOrConnectWithoutSenderInput | messageCreateOrConnectWithoutSenderInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutSenderInput | messageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: messageCreateManySenderInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutSenderInput | messageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: messageUpdateManyWithWhereWithoutSenderInput | messageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type messageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<messageCreateWithoutRecipientInput, messageUncheckedCreateWithoutRecipientInput> | messageCreateWithoutRecipientInput[] | messageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRecipientInput | messageCreateOrConnectWithoutRecipientInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutRecipientInput | messageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: messageCreateManyRecipientInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutRecipientInput | messageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: messageUpdateManyWithWhereWithoutRecipientInput | messageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type userGroupsUpdateManyWithoutUserNestedInput = {
    create?: XOR<userGroupsCreateWithoutUserInput, userGroupsUncheckedCreateWithoutUserInput> | userGroupsCreateWithoutUserInput[] | userGroupsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutUserInput | userGroupsCreateOrConnectWithoutUserInput[]
    upsert?: userGroupsUpsertWithWhereUniqueWithoutUserInput | userGroupsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userGroupsCreateManyUserInputEnvelope
    set?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    disconnect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    delete?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    update?: userGroupsUpdateWithWhereUniqueWithoutUserInput | userGroupsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userGroupsUpdateManyWithWhereWithoutUserInput | userGroupsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userGroupsScalarWhereInput | userGroupsScalarWhereInput[]
  }

  export type groupMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<groupMessageCreateWithoutSenderInput, groupMessageUncheckedCreateWithoutSenderInput> | groupMessageCreateWithoutSenderInput[] | groupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutSenderInput | groupMessageCreateOrConnectWithoutSenderInput[]
    upsert?: groupMessageUpsertWithWhereUniqueWithoutSenderInput | groupMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: groupMessageCreateManySenderInputEnvelope
    set?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    disconnect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    delete?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    update?: groupMessageUpdateWithWhereUniqueWithoutSenderInput | groupMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: groupMessageUpdateManyWithWhereWithoutSenderInput | groupMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: groupMessageScalarWhereInput | groupMessageScalarWhereInput[]
  }

  export type UserTaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTaskCreateWithoutUserInput, UserTaskUncheckedCreateWithoutUserInput> | UserTaskCreateWithoutUserInput[] | UserTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutUserInput | UserTaskCreateOrConnectWithoutUserInput[]
    upsert?: UserTaskUpsertWithWhereUniqueWithoutUserInput | UserTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTaskCreateManyUserInputEnvelope
    set?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    disconnect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    delete?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    update?: UserTaskUpdateWithWhereUniqueWithoutUserInput | UserTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTaskUpdateManyWithWhereWithoutUserInput | UserTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
  }

  export type UserBreakUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBreakCreateWithoutUserInput, UserBreakUncheckedCreateWithoutUserInput> | UserBreakCreateWithoutUserInput[] | UserBreakUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutUserInput | UserBreakCreateOrConnectWithoutUserInput[]
    upsert?: UserBreakUpsertWithWhereUniqueWithoutUserInput | UserBreakUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBreakCreateManyUserInputEnvelope
    set?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    disconnect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    delete?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    update?: UserBreakUpdateWithWhereUniqueWithoutUserInput | UserBreakUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBreakUpdateManyWithWhereWithoutUserInput | UserBreakUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBreakScalarWhereInput | UserBreakScalarWhereInput[]
  }

  export type UserTaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<UserTaskCreateWithoutAssigneeInput, UserTaskUncheckedCreateWithoutAssigneeInput> | UserTaskCreateWithoutAssigneeInput[] | UserTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutAssigneeInput | UserTaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: UserTaskUpsertWithWhereUniqueWithoutAssigneeInput | UserTaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: UserTaskCreateManyAssigneeInputEnvelope
    set?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    disconnect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    delete?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    update?: UserTaskUpdateWithWhereUniqueWithoutAssigneeInput | UserTaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: UserTaskUpdateManyWithWhereWithoutAssigneeInput | UserTaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type campaignDeliveriesUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<campaignDeliveriesCreateWithoutUploaderInput, campaignDeliveriesUncheckedCreateWithoutUploaderInput> | campaignDeliveriesCreateWithoutUploaderInput[] | campaignDeliveriesUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutUploaderInput | campaignDeliveriesCreateOrConnectWithoutUploaderInput[]
    upsert?: campaignDeliveriesUpsertWithWhereUniqueWithoutUploaderInput | campaignDeliveriesUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: campaignDeliveriesCreateManyUploaderInputEnvelope
    set?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    disconnect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    delete?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    update?: campaignDeliveriesUpdateWithWhereUniqueWithoutUploaderInput | campaignDeliveriesUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: campaignDeliveriesUpdateManyWithWhereWithoutUploaderInput | campaignDeliveriesUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: campaignDeliveriesScalarWhereInput | campaignDeliveriesScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<leadsUploadCreateWithoutUploaderInput, leadsUploadUncheckedCreateWithoutUploaderInput> | leadsUploadCreateWithoutUploaderInput[] | leadsUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutUploaderInput | leadsUploadCreateOrConnectWithoutUploaderInput[]
    upsert?: leadsUploadUpsertWithWhereUniqueWithoutUploaderInput | leadsUploadUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: leadsUploadCreateManyUploaderInputEnvelope
    set?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    disconnect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    delete?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    update?: leadsUploadUpdateWithWhereUniqueWithoutUploaderInput | leadsUploadUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: leadsUploadUpdateManyWithWhereWithoutUploaderInput | leadsUploadUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: leadsUploadScalarWhereInput | leadsUploadScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type UserLeaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLeaveCreateWithoutUserInput, UserLeaveUncheckedCreateWithoutUserInput> | UserLeaveCreateWithoutUserInput[] | UserLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutUserInput | UserLeaveCreateOrConnectWithoutUserInput[]
    upsert?: UserLeaveUpsertWithWhereUniqueWithoutUserInput | UserLeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLeaveCreateManyUserInputEnvelope
    set?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    disconnect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    delete?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    update?: UserLeaveUpdateWithWhereUniqueWithoutUserInput | UserLeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLeaveUpdateManyWithWhereWithoutUserInput | UserLeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLeaveScalarWhereInput | UserLeaveScalarWhereInput[]
  }

  export type UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<UserLeaveCreateWithoutApprovedByInput, UserLeaveUncheckedCreateWithoutApprovedByInput> | UserLeaveCreateWithoutApprovedByInput[] | UserLeaveUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: UserLeaveCreateOrConnectWithoutApprovedByInput | UserLeaveCreateOrConnectWithoutApprovedByInput[]
    upsert?: UserLeaveUpsertWithWhereUniqueWithoutApprovedByInput | UserLeaveUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: UserLeaveCreateManyApprovedByInputEnvelope
    set?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    disconnect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    delete?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    connect?: UserLeaveWhereUniqueInput | UserLeaveWhereUniqueInput[]
    update?: UserLeaveUpdateWithWhereUniqueWithoutApprovedByInput | UserLeaveUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: UserLeaveUpdateManyWithWhereWithoutApprovedByInput | UserLeaveUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: UserLeaveScalarWhereInput | UserLeaveScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<messageCreateWithoutSenderInput, messageUncheckedCreateWithoutSenderInput> | messageCreateWithoutSenderInput[] | messageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: messageCreateOrConnectWithoutSenderInput | messageCreateOrConnectWithoutSenderInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutSenderInput | messageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: messageCreateManySenderInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutSenderInput | messageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: messageUpdateManyWithWhereWithoutSenderInput | messageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<messageCreateWithoutRecipientInput, messageUncheckedCreateWithoutRecipientInput> | messageCreateWithoutRecipientInput[] | messageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: messageCreateOrConnectWithoutRecipientInput | messageCreateOrConnectWithoutRecipientInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutRecipientInput | messageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: messageCreateManyRecipientInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutRecipientInput | messageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: messageUpdateManyWithWhereWithoutRecipientInput | messageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type userGroupsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userGroupsCreateWithoutUserInput, userGroupsUncheckedCreateWithoutUserInput> | userGroupsCreateWithoutUserInput[] | userGroupsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutUserInput | userGroupsCreateOrConnectWithoutUserInput[]
    upsert?: userGroupsUpsertWithWhereUniqueWithoutUserInput | userGroupsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userGroupsCreateManyUserInputEnvelope
    set?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    disconnect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    delete?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    update?: userGroupsUpdateWithWhereUniqueWithoutUserInput | userGroupsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userGroupsUpdateManyWithWhereWithoutUserInput | userGroupsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userGroupsScalarWhereInput | userGroupsScalarWhereInput[]
  }

  export type groupMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<groupMessageCreateWithoutSenderInput, groupMessageUncheckedCreateWithoutSenderInput> | groupMessageCreateWithoutSenderInput[] | groupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutSenderInput | groupMessageCreateOrConnectWithoutSenderInput[]
    upsert?: groupMessageUpsertWithWhereUniqueWithoutSenderInput | groupMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: groupMessageCreateManySenderInputEnvelope
    set?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    disconnect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    delete?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    update?: groupMessageUpdateWithWhereUniqueWithoutSenderInput | groupMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: groupMessageUpdateManyWithWhereWithoutSenderInput | groupMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: groupMessageScalarWhereInput | groupMessageScalarWhereInput[]
  }

  export type UserTaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTaskCreateWithoutUserInput, UserTaskUncheckedCreateWithoutUserInput> | UserTaskCreateWithoutUserInput[] | UserTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutUserInput | UserTaskCreateOrConnectWithoutUserInput[]
    upsert?: UserTaskUpsertWithWhereUniqueWithoutUserInput | UserTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTaskCreateManyUserInputEnvelope
    set?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    disconnect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    delete?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    update?: UserTaskUpdateWithWhereUniqueWithoutUserInput | UserTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTaskUpdateManyWithWhereWithoutUserInput | UserTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
  }

  export type UserBreakUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBreakCreateWithoutUserInput, UserBreakUncheckedCreateWithoutUserInput> | UserBreakCreateWithoutUserInput[] | UserBreakUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutUserInput | UserBreakCreateOrConnectWithoutUserInput[]
    upsert?: UserBreakUpsertWithWhereUniqueWithoutUserInput | UserBreakUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBreakCreateManyUserInputEnvelope
    set?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    disconnect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    delete?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    update?: UserBreakUpdateWithWhereUniqueWithoutUserInput | UserBreakUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBreakUpdateManyWithWhereWithoutUserInput | UserBreakUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBreakScalarWhereInput | UserBreakScalarWhereInput[]
  }

  export type UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<UserTaskCreateWithoutAssigneeInput, UserTaskUncheckedCreateWithoutAssigneeInput> | UserTaskCreateWithoutAssigneeInput[] | UserTaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutAssigneeInput | UserTaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: UserTaskUpsertWithWhereUniqueWithoutAssigneeInput | UserTaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: UserTaskCreateManyAssigneeInputEnvelope
    set?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    disconnect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    delete?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    update?: UserTaskUpdateWithWhereUniqueWithoutAssigneeInput | UserTaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: UserTaskUpdateManyWithWhereWithoutAssigneeInput | UserTaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<campaignDeliveriesCreateWithoutUploaderInput, campaignDeliveriesUncheckedCreateWithoutUploaderInput> | campaignDeliveriesCreateWithoutUploaderInput[] | campaignDeliveriesUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutUploaderInput | campaignDeliveriesCreateOrConnectWithoutUploaderInput[]
    upsert?: campaignDeliveriesUpsertWithWhereUniqueWithoutUploaderInput | campaignDeliveriesUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: campaignDeliveriesCreateManyUploaderInputEnvelope
    set?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    disconnect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    delete?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    update?: campaignDeliveriesUpdateWithWhereUniqueWithoutUploaderInput | campaignDeliveriesUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: campaignDeliveriesUpdateManyWithWhereWithoutUploaderInput | campaignDeliveriesUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: campaignDeliveriesScalarWhereInput | campaignDeliveriesScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: userCreateOrConnectWithoutAttendanceInput
    connect?: userWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: userCreateOrConnectWithoutAttendanceInput
    upsert?: userUpsertWithoutAttendanceInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAttendanceInput, userUpdateWithoutAttendanceInput>, userUncheckedUpdateWithoutAttendanceInput>
  }

  export type userCreateNestedOneWithoutLeavesInput = {
    create?: XOR<userCreateWithoutLeavesInput, userUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: userCreateOrConnectWithoutLeavesInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutApprovedLeavesInput = {
    create?: XOR<userCreateWithoutApprovedLeavesInput, userUncheckedCreateWithoutApprovedLeavesInput>
    connectOrCreate?: userCreateOrConnectWithoutApprovedLeavesInput
    connect?: userWhereUniqueInput
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type EnumLeaveDurationFieldUpdateOperationsInput = {
    set?: $Enums.LeaveDuration
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type userUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<userCreateWithoutLeavesInput, userUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: userCreateOrConnectWithoutLeavesInput
    upsert?: userUpsertWithoutLeavesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutLeavesInput, userUpdateWithoutLeavesInput>, userUncheckedUpdateWithoutLeavesInput>
  }

  export type userUpdateOneWithoutApprovedLeavesNestedInput = {
    create?: XOR<userCreateWithoutApprovedLeavesInput, userUncheckedCreateWithoutApprovedLeavesInput>
    connectOrCreate?: userCreateOrConnectWithoutApprovedLeavesInput
    upsert?: userUpsertWithoutApprovedLeavesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutApprovedLeavesInput, userUpdateWithoutApprovedLeavesInput>, userUncheckedUpdateWithoutApprovedLeavesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutSessionsInput = {
    create?: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionsInput
    connect?: userWhereUniqueInput
  }

  export type UserTaskCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserTaskCreateWithoutSessionsInput, UserTaskUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserTaskCreateOrConnectWithoutSessionsInput
    connect?: UserTaskWhereUniqueInput
  }

  export type UserBreakCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserBreakCreateWithoutSessionsInput, UserBreakUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserBreakCreateOrConnectWithoutSessionsInput
    connect?: UserBreakWhereUniqueInput
  }

  export type EnumSessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SessionType
  }

  export type userUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionsInput
    upsert?: userUpsertWithoutSessionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSessionsInput, userUpdateWithoutSessionsInput>, userUncheckedUpdateWithoutSessionsInput>
  }

  export type UserTaskUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserTaskCreateWithoutSessionsInput, UserTaskUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserTaskCreateOrConnectWithoutSessionsInput
    upsert?: UserTaskUpsertWithoutSessionsInput
    disconnect?: UserTaskWhereInput | boolean
    delete?: UserTaskWhereInput | boolean
    connect?: UserTaskWhereUniqueInput
    update?: XOR<XOR<UserTaskUpdateToOneWithWhereWithoutSessionsInput, UserTaskUpdateWithoutSessionsInput>, UserTaskUncheckedUpdateWithoutSessionsInput>
  }

  export type UserBreakUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserBreakCreateWithoutSessionsInput, UserBreakUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserBreakCreateOrConnectWithoutSessionsInput
    upsert?: UserBreakUpsertWithoutSessionsInput
    disconnect?: UserBreakWhereInput | boolean
    delete?: UserBreakWhereInput | boolean
    connect?: UserBreakWhereUniqueInput
    update?: XOR<XOR<UserBreakUpdateToOneWithWhereWithoutSessionsInput, UserBreakUpdateWithoutSessionsInput>, UserBreakUncheckedUpdateWithoutSessionsInput>
  }

  export type userCreateNestedOneWithoutTasksInput = {
    create?: XOR<userCreateWithoutTasksInput, userUncheckedCreateWithoutTasksInput>
    connectOrCreate?: userCreateOrConnectWithoutTasksInput
    connect?: userWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutUsersInput = {
    create?: XOR<TaskCreateWithoutUsersInput, TaskUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TaskCreateOrConnectWithoutUsersInput
    connect?: TaskWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutTaskInput = {
    create?: XOR<SessionCreateWithoutTaskInput, SessionUncheckedCreateWithoutTaskInput> | SessionCreateWithoutTaskInput[] | SessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTaskInput | SessionCreateOrConnectWithoutTaskInput[]
    createMany?: SessionCreateManyTaskInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<userCreateWithoutAssignedTasksInput, userUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: userCreateOrConnectWithoutAssignedTasksInput
    connect?: userWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<SessionCreateWithoutTaskInput, SessionUncheckedCreateWithoutTaskInput> | SessionCreateWithoutTaskInput[] | SessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTaskInput | SessionCreateOrConnectWithoutTaskInput[]
    createMany?: SessionCreateManyTaskInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<userCreateWithoutTasksInput, userUncheckedCreateWithoutTasksInput>
    connectOrCreate?: userCreateOrConnectWithoutTasksInput
    upsert?: userUpsertWithoutTasksInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTasksInput, userUpdateWithoutTasksInput>, userUncheckedUpdateWithoutTasksInput>
  }

  export type TaskUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TaskCreateWithoutUsersInput, TaskUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TaskCreateOrConnectWithoutUsersInput
    upsert?: TaskUpsertWithoutUsersInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutUsersInput, TaskUpdateWithoutUsersInput>, TaskUncheckedUpdateWithoutUsersInput>
  }

  export type SessionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<SessionCreateWithoutTaskInput, SessionUncheckedCreateWithoutTaskInput> | SessionCreateWithoutTaskInput[] | SessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTaskInput | SessionCreateOrConnectWithoutTaskInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTaskInput | SessionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: SessionCreateManyTaskInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTaskInput | SessionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTaskInput | SessionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutAssignedTasksNestedInput = {
    create?: XOR<userCreateWithoutAssignedTasksInput, userUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: userCreateOrConnectWithoutAssignedTasksInput
    upsert?: userUpsertWithoutAssignedTasksInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAssignedTasksInput, userUpdateWithoutAssignedTasksInput>, userUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type SessionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<SessionCreateWithoutTaskInput, SessionUncheckedCreateWithoutTaskInput> | SessionCreateWithoutTaskInput[] | SessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTaskInput | SessionCreateOrConnectWithoutTaskInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTaskInput | SessionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: SessionCreateManyTaskInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTaskInput | SessionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTaskInput | SessionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutBreaksInput = {
    create?: XOR<userCreateWithoutBreaksInput, userUncheckedCreateWithoutBreaksInput>
    connectOrCreate?: userCreateOrConnectWithoutBreaksInput
    connect?: userWhereUniqueInput
  }

  export type BreakCreateNestedOneWithoutUsersInput = {
    create?: XOR<BreakCreateWithoutUsersInput, BreakUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BreakCreateOrConnectWithoutUsersInput
    connect?: BreakWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutBreakInput = {
    create?: XOR<SessionCreateWithoutBreakInput, SessionUncheckedCreateWithoutBreakInput> | SessionCreateWithoutBreakInput[] | SessionUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutBreakInput | SessionCreateOrConnectWithoutBreakInput[]
    createMany?: SessionCreateManyBreakInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutBreakInput = {
    create?: XOR<SessionCreateWithoutBreakInput, SessionUncheckedCreateWithoutBreakInput> | SessionCreateWithoutBreakInput[] | SessionUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutBreakInput | SessionCreateOrConnectWithoutBreakInput[]
    createMany?: SessionCreateManyBreakInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutBreaksNestedInput = {
    create?: XOR<userCreateWithoutBreaksInput, userUncheckedCreateWithoutBreaksInput>
    connectOrCreate?: userCreateOrConnectWithoutBreaksInput
    upsert?: userUpsertWithoutBreaksInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBreaksInput, userUpdateWithoutBreaksInput>, userUncheckedUpdateWithoutBreaksInput>
  }

  export type BreakUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BreakCreateWithoutUsersInput, BreakUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BreakCreateOrConnectWithoutUsersInput
    upsert?: BreakUpsertWithoutUsersInput
    connect?: BreakWhereUniqueInput
    update?: XOR<XOR<BreakUpdateToOneWithWhereWithoutUsersInput, BreakUpdateWithoutUsersInput>, BreakUncheckedUpdateWithoutUsersInput>
  }

  export type SessionUpdateManyWithoutBreakNestedInput = {
    create?: XOR<SessionCreateWithoutBreakInput, SessionUncheckedCreateWithoutBreakInput> | SessionCreateWithoutBreakInput[] | SessionUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutBreakInput | SessionCreateOrConnectWithoutBreakInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutBreakInput | SessionUpsertWithWhereUniqueWithoutBreakInput[]
    createMany?: SessionCreateManyBreakInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutBreakInput | SessionUpdateWithWhereUniqueWithoutBreakInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutBreakInput | SessionUpdateManyWithWhereWithoutBreakInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutBreakNestedInput = {
    create?: XOR<SessionCreateWithoutBreakInput, SessionUncheckedCreateWithoutBreakInput> | SessionCreateWithoutBreakInput[] | SessionUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutBreakInput | SessionCreateOrConnectWithoutBreakInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutBreakInput | SessionUpsertWithWhereUniqueWithoutBreakInput[]
    createMany?: SessionCreateManyBreakInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutBreakInput | SessionUpdateWithWhereUniqueWithoutBreakInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutBreakInput | SessionUpdateManyWithWhereWithoutBreakInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserTaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<UserTaskCreateWithoutTaskInput, UserTaskUncheckedCreateWithoutTaskInput> | UserTaskCreateWithoutTaskInput[] | UserTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutTaskInput | UserTaskCreateOrConnectWithoutTaskInput[]
    createMany?: UserTaskCreateManyTaskInputEnvelope
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
  }

  export type UserTaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<UserTaskCreateWithoutTaskInput, UserTaskUncheckedCreateWithoutTaskInput> | UserTaskCreateWithoutTaskInput[] | UserTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutTaskInput | UserTaskCreateOrConnectWithoutTaskInput[]
    createMany?: UserTaskCreateManyTaskInputEnvelope
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type EnumTaskLevelFieldUpdateOperationsInput = {
    set?: $Enums.TaskLevel
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserTaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<UserTaskCreateWithoutTaskInput, UserTaskUncheckedCreateWithoutTaskInput> | UserTaskCreateWithoutTaskInput[] | UserTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutTaskInput | UserTaskCreateOrConnectWithoutTaskInput[]
    upsert?: UserTaskUpsertWithWhereUniqueWithoutTaskInput | UserTaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: UserTaskCreateManyTaskInputEnvelope
    set?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    disconnect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    delete?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    update?: UserTaskUpdateWithWhereUniqueWithoutTaskInput | UserTaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: UserTaskUpdateManyWithWhereWithoutTaskInput | UserTaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
  }

  export type UserTaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<UserTaskCreateWithoutTaskInput, UserTaskUncheckedCreateWithoutTaskInput> | UserTaskCreateWithoutTaskInput[] | UserTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCreateOrConnectWithoutTaskInput | UserTaskCreateOrConnectWithoutTaskInput[]
    upsert?: UserTaskUpsertWithWhereUniqueWithoutTaskInput | UserTaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: UserTaskCreateManyTaskInputEnvelope
    set?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    disconnect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    delete?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    connect?: UserTaskWhereUniqueInput | UserTaskWhereUniqueInput[]
    update?: UserTaskUpdateWithWhereUniqueWithoutTaskInput | UserTaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: UserTaskUpdateManyWithWhereWithoutTaskInput | UserTaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
  }

  export type UserBreakCreateNestedManyWithoutBreakInput = {
    create?: XOR<UserBreakCreateWithoutBreakInput, UserBreakUncheckedCreateWithoutBreakInput> | UserBreakCreateWithoutBreakInput[] | UserBreakUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutBreakInput | UserBreakCreateOrConnectWithoutBreakInput[]
    createMany?: UserBreakCreateManyBreakInputEnvelope
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
  }

  export type UserBreakUncheckedCreateNestedManyWithoutBreakInput = {
    create?: XOR<UserBreakCreateWithoutBreakInput, UserBreakUncheckedCreateWithoutBreakInput> | UserBreakCreateWithoutBreakInput[] | UserBreakUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutBreakInput | UserBreakCreateOrConnectWithoutBreakInput[]
    createMany?: UserBreakCreateManyBreakInputEnvelope
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
  }

  export type UserBreakUpdateManyWithoutBreakNestedInput = {
    create?: XOR<UserBreakCreateWithoutBreakInput, UserBreakUncheckedCreateWithoutBreakInput> | UserBreakCreateWithoutBreakInput[] | UserBreakUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutBreakInput | UserBreakCreateOrConnectWithoutBreakInput[]
    upsert?: UserBreakUpsertWithWhereUniqueWithoutBreakInput | UserBreakUpsertWithWhereUniqueWithoutBreakInput[]
    createMany?: UserBreakCreateManyBreakInputEnvelope
    set?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    disconnect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    delete?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    update?: UserBreakUpdateWithWhereUniqueWithoutBreakInput | UserBreakUpdateWithWhereUniqueWithoutBreakInput[]
    updateMany?: UserBreakUpdateManyWithWhereWithoutBreakInput | UserBreakUpdateManyWithWhereWithoutBreakInput[]
    deleteMany?: UserBreakScalarWhereInput | UserBreakScalarWhereInput[]
  }

  export type UserBreakUncheckedUpdateManyWithoutBreakNestedInput = {
    create?: XOR<UserBreakCreateWithoutBreakInput, UserBreakUncheckedCreateWithoutBreakInput> | UserBreakCreateWithoutBreakInput[] | UserBreakUncheckedCreateWithoutBreakInput[]
    connectOrCreate?: UserBreakCreateOrConnectWithoutBreakInput | UserBreakCreateOrConnectWithoutBreakInput[]
    upsert?: UserBreakUpsertWithWhereUniqueWithoutBreakInput | UserBreakUpsertWithWhereUniqueWithoutBreakInput[]
    createMany?: UserBreakCreateManyBreakInputEnvelope
    set?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    disconnect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    delete?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    connect?: UserBreakWhereUniqueInput | UserBreakWhereUniqueInput[]
    update?: UserBreakUpdateWithWhereUniqueWithoutBreakInput | UserBreakUpdateWithWhereUniqueWithoutBreakInput[]
    updateMany?: UserBreakUpdateManyWithWhereWithoutBreakInput | UserBreakUpdateManyWithWhereWithoutBreakInput[]
    deleteMany?: UserBreakScalarWhereInput | UserBreakScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<userCreateWithoutSentMessagesInput, userUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: userCreateOrConnectWithoutSentMessagesInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<userCreateWithoutReceivedMessagesInput, userUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: userCreateOrConnectWithoutReceivedMessagesInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<userCreateWithoutSentMessagesInput, userUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: userCreateOrConnectWithoutSentMessagesInput
    upsert?: userUpsertWithoutSentMessagesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSentMessagesInput, userUpdateWithoutSentMessagesInput>, userUncheckedUpdateWithoutSentMessagesInput>
  }

  export type userUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<userCreateWithoutReceivedMessagesInput, userUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: userCreateOrConnectWithoutReceivedMessagesInput
    upsert?: userUpsertWithoutReceivedMessagesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReceivedMessagesInput, userUpdateWithoutReceivedMessagesInput>, userUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type groupCreateNestedOneWithoutGroupMessagesInput = {
    create?: XOR<groupCreateWithoutGroupMessagesInput, groupUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroupMessagesInput
    connect?: groupWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSentMessageInput = {
    create?: XOR<userCreateWithoutSentMessageInput, userUncheckedCreateWithoutSentMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutSentMessageInput
    connect?: userWhereUniqueInput
  }

  export type groupUpdateOneRequiredWithoutGroupMessagesNestedInput = {
    create?: XOR<groupCreateWithoutGroupMessagesInput, groupUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroupMessagesInput
    upsert?: groupUpsertWithoutGroupMessagesInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutGroupMessagesInput, groupUpdateWithoutGroupMessagesInput>, groupUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type userUpdateOneRequiredWithoutSentMessageNestedInput = {
    create?: XOR<userCreateWithoutSentMessageInput, userUncheckedCreateWithoutSentMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutSentMessageInput
    upsert?: userUpsertWithoutSentMessageInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSentMessageInput, userUpdateWithoutSentMessageInput>, userUncheckedUpdateWithoutSentMessageInput>
  }

  export type userGroupsCreateNestedManyWithoutGroupInput = {
    create?: XOR<userGroupsCreateWithoutGroupInput, userGroupsUncheckedCreateWithoutGroupInput> | userGroupsCreateWithoutGroupInput[] | userGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutGroupInput | userGroupsCreateOrConnectWithoutGroupInput[]
    createMany?: userGroupsCreateManyGroupInputEnvelope
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
  }

  export type groupMessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<groupMessageCreateWithoutGroupInput, groupMessageUncheckedCreateWithoutGroupInput> | groupMessageCreateWithoutGroupInput[] | groupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutGroupInput | groupMessageCreateOrConnectWithoutGroupInput[]
    createMany?: groupMessageCreateManyGroupInputEnvelope
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
  }

  export type userGroupsUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<userGroupsCreateWithoutGroupInput, userGroupsUncheckedCreateWithoutGroupInput> | userGroupsCreateWithoutGroupInput[] | userGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutGroupInput | userGroupsCreateOrConnectWithoutGroupInput[]
    createMany?: userGroupsCreateManyGroupInputEnvelope
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
  }

  export type groupMessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<groupMessageCreateWithoutGroupInput, groupMessageUncheckedCreateWithoutGroupInput> | groupMessageCreateWithoutGroupInput[] | groupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutGroupInput | groupMessageCreateOrConnectWithoutGroupInput[]
    createMany?: groupMessageCreateManyGroupInputEnvelope
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
  }

  export type userGroupsUpdateManyWithoutGroupNestedInput = {
    create?: XOR<userGroupsCreateWithoutGroupInput, userGroupsUncheckedCreateWithoutGroupInput> | userGroupsCreateWithoutGroupInput[] | userGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutGroupInput | userGroupsCreateOrConnectWithoutGroupInput[]
    upsert?: userGroupsUpsertWithWhereUniqueWithoutGroupInput | userGroupsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: userGroupsCreateManyGroupInputEnvelope
    set?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    disconnect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    delete?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    update?: userGroupsUpdateWithWhereUniqueWithoutGroupInput | userGroupsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: userGroupsUpdateManyWithWhereWithoutGroupInput | userGroupsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: userGroupsScalarWhereInput | userGroupsScalarWhereInput[]
  }

  export type groupMessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<groupMessageCreateWithoutGroupInput, groupMessageUncheckedCreateWithoutGroupInput> | groupMessageCreateWithoutGroupInput[] | groupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutGroupInput | groupMessageCreateOrConnectWithoutGroupInput[]
    upsert?: groupMessageUpsertWithWhereUniqueWithoutGroupInput | groupMessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: groupMessageCreateManyGroupInputEnvelope
    set?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    disconnect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    delete?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    update?: groupMessageUpdateWithWhereUniqueWithoutGroupInput | groupMessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: groupMessageUpdateManyWithWhereWithoutGroupInput | groupMessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: groupMessageScalarWhereInput | groupMessageScalarWhereInput[]
  }

  export type userGroupsUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<userGroupsCreateWithoutGroupInput, userGroupsUncheckedCreateWithoutGroupInput> | userGroupsCreateWithoutGroupInput[] | userGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userGroupsCreateOrConnectWithoutGroupInput | userGroupsCreateOrConnectWithoutGroupInput[]
    upsert?: userGroupsUpsertWithWhereUniqueWithoutGroupInput | userGroupsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: userGroupsCreateManyGroupInputEnvelope
    set?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    disconnect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    delete?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    connect?: userGroupsWhereUniqueInput | userGroupsWhereUniqueInput[]
    update?: userGroupsUpdateWithWhereUniqueWithoutGroupInput | userGroupsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: userGroupsUpdateManyWithWhereWithoutGroupInput | userGroupsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: userGroupsScalarWhereInput | userGroupsScalarWhereInput[]
  }

  export type groupMessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<groupMessageCreateWithoutGroupInput, groupMessageUncheckedCreateWithoutGroupInput> | groupMessageCreateWithoutGroupInput[] | groupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupMessageCreateOrConnectWithoutGroupInput | groupMessageCreateOrConnectWithoutGroupInput[]
    upsert?: groupMessageUpsertWithWhereUniqueWithoutGroupInput | groupMessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: groupMessageCreateManyGroupInputEnvelope
    set?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    disconnect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    delete?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    connect?: groupMessageWhereUniqueInput | groupMessageWhereUniqueInput[]
    update?: groupMessageUpdateWithWhereUniqueWithoutGroupInput | groupMessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: groupMessageUpdateManyWithWhereWithoutGroupInput | groupMessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: groupMessageScalarWhereInput | groupMessageScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutGroupsInput = {
    create?: XOR<userCreateWithoutGroupsInput, userUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: userCreateOrConnectWithoutGroupsInput
    connect?: userWhereUniqueInput
  }

  export type groupCreateNestedOneWithoutMembersInput = {
    create?: XOR<groupCreateWithoutMembersInput, groupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: groupCreateOrConnectWithoutMembersInput
    connect?: groupWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<userCreateWithoutGroupsInput, userUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: userCreateOrConnectWithoutGroupsInput
    upsert?: userUpsertWithoutGroupsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGroupsInput, userUpdateWithoutGroupsInput>, userUncheckedUpdateWithoutGroupsInput>
  }

  export type groupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<groupCreateWithoutMembersInput, groupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: groupCreateOrConnectWithoutMembersInput
    upsert?: groupUpsertWithoutMembersInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutMembersInput, groupUpdateWithoutMembersInput>, groupUncheckedUpdateWithoutMembersInput>
  }

  export type notificationPriorityCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<notificationPriorityCreateWithoutNotificationsInput, notificationPriorityUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: notificationPriorityCreateOrConnectWithoutNotificationsInput
    connect?: notificationPriorityWhereUniqueInput
  }

  export type roleNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<roleNotificationCreateWithoutNotificationInput, roleNotificationUncheckedCreateWithoutNotificationInput> | roleNotificationCreateWithoutNotificationInput[] | roleNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutNotificationInput | roleNotificationCreateOrConnectWithoutNotificationInput[]
    createMany?: roleNotificationCreateManyNotificationInputEnvelope
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
  }

  export type roleNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<roleNotificationCreateWithoutNotificationInput, roleNotificationUncheckedCreateWithoutNotificationInput> | roleNotificationCreateWithoutNotificationInput[] | roleNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutNotificationInput | roleNotificationCreateOrConnectWithoutNotificationInput[]
    createMany?: roleNotificationCreateManyNotificationInputEnvelope
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
  }

  export type notificationPriorityUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<notificationPriorityCreateWithoutNotificationsInput, notificationPriorityUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: notificationPriorityCreateOrConnectWithoutNotificationsInput
    upsert?: notificationPriorityUpsertWithoutNotificationsInput
    connect?: notificationPriorityWhereUniqueInput
    update?: XOR<XOR<notificationPriorityUpdateToOneWithWhereWithoutNotificationsInput, notificationPriorityUpdateWithoutNotificationsInput>, notificationPriorityUncheckedUpdateWithoutNotificationsInput>
  }

  export type roleNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<roleNotificationCreateWithoutNotificationInput, roleNotificationUncheckedCreateWithoutNotificationInput> | roleNotificationCreateWithoutNotificationInput[] | roleNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutNotificationInput | roleNotificationCreateOrConnectWithoutNotificationInput[]
    upsert?: roleNotificationUpsertWithWhereUniqueWithoutNotificationInput | roleNotificationUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: roleNotificationCreateManyNotificationInputEnvelope
    set?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    disconnect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    delete?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    update?: roleNotificationUpdateWithWhereUniqueWithoutNotificationInput | roleNotificationUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: roleNotificationUpdateManyWithWhereWithoutNotificationInput | roleNotificationUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: roleNotificationScalarWhereInput | roleNotificationScalarWhereInput[]
  }

  export type roleNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<roleNotificationCreateWithoutNotificationInput, roleNotificationUncheckedCreateWithoutNotificationInput> | roleNotificationCreateWithoutNotificationInput[] | roleNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutNotificationInput | roleNotificationCreateOrConnectWithoutNotificationInput[]
    upsert?: roleNotificationUpsertWithWhereUniqueWithoutNotificationInput | roleNotificationUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: roleNotificationCreateManyNotificationInputEnvelope
    set?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    disconnect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    delete?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    update?: roleNotificationUpdateWithWhereUniqueWithoutNotificationInput | roleNotificationUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: roleNotificationUpdateManyWithWhereWithoutNotificationInput | roleNotificationUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: roleNotificationScalarWhereInput | roleNotificationScalarWhereInput[]
  }

  export type notificationCreateNestedManyWithoutNotificationPriorityInput = {
    create?: XOR<notificationCreateWithoutNotificationPriorityInput, notificationUncheckedCreateWithoutNotificationPriorityInput> | notificationCreateWithoutNotificationPriorityInput[] | notificationUncheckedCreateWithoutNotificationPriorityInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutNotificationPriorityInput | notificationCreateOrConnectWithoutNotificationPriorityInput[]
    createMany?: notificationCreateManyNotificationPriorityInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutNotificationPriorityInput = {
    create?: XOR<notificationCreateWithoutNotificationPriorityInput, notificationUncheckedCreateWithoutNotificationPriorityInput> | notificationCreateWithoutNotificationPriorityInput[] | notificationUncheckedCreateWithoutNotificationPriorityInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutNotificationPriorityInput | notificationCreateOrConnectWithoutNotificationPriorityInput[]
    createMany?: notificationCreateManyNotificationPriorityInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type notificationUpdateManyWithoutNotificationPriorityNestedInput = {
    create?: XOR<notificationCreateWithoutNotificationPriorityInput, notificationUncheckedCreateWithoutNotificationPriorityInput> | notificationCreateWithoutNotificationPriorityInput[] | notificationUncheckedCreateWithoutNotificationPriorityInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutNotificationPriorityInput | notificationCreateOrConnectWithoutNotificationPriorityInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutNotificationPriorityInput | notificationUpsertWithWhereUniqueWithoutNotificationPriorityInput[]
    createMany?: notificationCreateManyNotificationPriorityInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutNotificationPriorityInput | notificationUpdateWithWhereUniqueWithoutNotificationPriorityInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutNotificationPriorityInput | notificationUpdateManyWithWhereWithoutNotificationPriorityInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutNotificationPriorityNestedInput = {
    create?: XOR<notificationCreateWithoutNotificationPriorityInput, notificationUncheckedCreateWithoutNotificationPriorityInput> | notificationCreateWithoutNotificationPriorityInput[] | notificationUncheckedCreateWithoutNotificationPriorityInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutNotificationPriorityInput | notificationCreateOrConnectWithoutNotificationPriorityInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutNotificationPriorityInput | notificationUpsertWithWhereUniqueWithoutNotificationPriorityInput[]
    createMany?: notificationCreateManyNotificationPriorityInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutNotificationPriorityInput | notificationUpdateWithWhereUniqueWithoutNotificationPriorityInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutNotificationPriorityInput | notificationUpdateManyWithWhereWithoutNotificationPriorityInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type userroleCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type roleNotificationCreateNestedManyWithoutRoleInput = {
    create?: XOR<roleNotificationCreateWithoutRoleInput, roleNotificationUncheckedCreateWithoutRoleInput> | roleNotificationCreateWithoutRoleInput[] | roleNotificationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutRoleInput | roleNotificationCreateOrConnectWithoutRoleInput[]
    createMany?: roleNotificationCreateManyRoleInputEnvelope
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type roleNotificationUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<roleNotificationCreateWithoutRoleInput, roleNotificationUncheckedCreateWithoutRoleInput> | roleNotificationCreateWithoutRoleInput[] | roleNotificationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutRoleInput | roleNotificationCreateOrConnectWithoutRoleInput[]
    createMany?: roleNotificationCreateManyRoleInputEnvelope
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
  }

  export type userroleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type roleNotificationUpdateManyWithoutRoleNestedInput = {
    create?: XOR<roleNotificationCreateWithoutRoleInput, roleNotificationUncheckedCreateWithoutRoleInput> | roleNotificationCreateWithoutRoleInput[] | roleNotificationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutRoleInput | roleNotificationCreateOrConnectWithoutRoleInput[]
    upsert?: roleNotificationUpsertWithWhereUniqueWithoutRoleInput | roleNotificationUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: roleNotificationCreateManyRoleInputEnvelope
    set?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    disconnect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    delete?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    update?: roleNotificationUpdateWithWhereUniqueWithoutRoleInput | roleNotificationUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: roleNotificationUpdateManyWithWhereWithoutRoleInput | roleNotificationUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: roleNotificationScalarWhereInput | roleNotificationScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type roleNotificationUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<roleNotificationCreateWithoutRoleInput, roleNotificationUncheckedCreateWithoutRoleInput> | roleNotificationCreateWithoutRoleInput[] | roleNotificationUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: roleNotificationCreateOrConnectWithoutRoleInput | roleNotificationCreateOrConnectWithoutRoleInput[]
    upsert?: roleNotificationUpsertWithWhereUniqueWithoutRoleInput | roleNotificationUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: roleNotificationCreateManyRoleInputEnvelope
    set?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    disconnect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    delete?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    connect?: roleNotificationWhereUniqueInput | roleNotificationWhereUniqueInput[]
    update?: roleNotificationUpdateWithWhereUniqueWithoutRoleInput | roleNotificationUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: roleNotificationUpdateManyWithWhereWithoutRoleInput | roleNotificationUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: roleNotificationScalarWhereInput | roleNotificationScalarWhereInput[]
  }

  export type roleCreateNestedOneWithoutRoleNotificationsInput = {
    create?: XOR<roleCreateWithoutRoleNotificationsInput, roleUncheckedCreateWithoutRoleNotificationsInput>
    connectOrCreate?: roleCreateOrConnectWithoutRoleNotificationsInput
    connect?: roleWhereUniqueInput
  }

  export type notificationCreateNestedOneWithoutRoleNotificationsInput = {
    create?: XOR<notificationCreateWithoutRoleNotificationsInput, notificationUncheckedCreateWithoutRoleNotificationsInput>
    connectOrCreate?: notificationCreateOrConnectWithoutRoleNotificationsInput
    connect?: notificationWhereUniqueInput
  }

  export type roleUpdateOneRequiredWithoutRoleNotificationsNestedInput = {
    create?: XOR<roleCreateWithoutRoleNotificationsInput, roleUncheckedCreateWithoutRoleNotificationsInput>
    connectOrCreate?: roleCreateOrConnectWithoutRoleNotificationsInput
    upsert?: roleUpsertWithoutRoleNotificationsInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutRoleNotificationsInput, roleUpdateWithoutRoleNotificationsInput>, roleUncheckedUpdateWithoutRoleNotificationsInput>
  }

  export type notificationUpdateOneRequiredWithoutRoleNotificationsNestedInput = {
    create?: XOR<notificationCreateWithoutRoleNotificationsInput, notificationUncheckedCreateWithoutRoleNotificationsInput>
    connectOrCreate?: notificationCreateOrConnectWithoutRoleNotificationsInput
    upsert?: notificationUpsertWithoutRoleNotificationsInput
    connect?: notificationWhereUniqueInput
    update?: XOR<XOR<notificationUpdateToOneWithWhereWithoutRoleNotificationsInput, notificationUpdateWithoutRoleNotificationsInput>, notificationUncheckedUpdateWithoutRoleNotificationsInput>
  }

  export type roleCreateNestedOneWithoutUsersInput = {
    create?: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: roleCreateOrConnectWithoutUsersInput
    connect?: roleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRolesInput = {
    create?: XOR<userCreateWithoutRolesInput, userUncheckedCreateWithoutRolesInput>
    connectOrCreate?: userCreateOrConnectWithoutRolesInput
    connect?: userWhereUniqueInput
  }

  export type roleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: roleCreateOrConnectWithoutUsersInput
    upsert?: roleUpsertWithoutUsersInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUsersInput, roleUpdateWithoutUsersInput>, roleUncheckedUpdateWithoutUsersInput>
  }

  export type userUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<userCreateWithoutRolesInput, userUncheckedCreateWithoutRolesInput>
    connectOrCreate?: userCreateOrConnectWithoutRolesInput
    upsert?: userUpsertWithoutRolesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRolesInput, userUpdateWithoutRolesInput>, userUncheckedUpdateWithoutRolesInput>
  }

  export type campaignCreateNestedManyWithoutClientInput = {
    create?: XOR<campaignCreateWithoutClientInput, campaignUncheckedCreateWithoutClientInput> | campaignCreateWithoutClientInput[] | campaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: campaignCreateOrConnectWithoutClientInput | campaignCreateOrConnectWithoutClientInput[]
    createMany?: campaignCreateManyClientInputEnvelope
    connect?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
  }

  export type campaignUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<campaignCreateWithoutClientInput, campaignUncheckedCreateWithoutClientInput> | campaignCreateWithoutClientInput[] | campaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: campaignCreateOrConnectWithoutClientInput | campaignCreateOrConnectWithoutClientInput[]
    createMany?: campaignCreateManyClientInputEnvelope
    connect?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
  }

  export type campaignUpdateManyWithoutClientNestedInput = {
    create?: XOR<campaignCreateWithoutClientInput, campaignUncheckedCreateWithoutClientInput> | campaignCreateWithoutClientInput[] | campaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: campaignCreateOrConnectWithoutClientInput | campaignCreateOrConnectWithoutClientInput[]
    upsert?: campaignUpsertWithWhereUniqueWithoutClientInput | campaignUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: campaignCreateManyClientInputEnvelope
    set?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    disconnect?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    delete?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    connect?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    update?: campaignUpdateWithWhereUniqueWithoutClientInput | campaignUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: campaignUpdateManyWithWhereWithoutClientInput | campaignUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: campaignScalarWhereInput | campaignScalarWhereInput[]
  }

  export type campaignUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<campaignCreateWithoutClientInput, campaignUncheckedCreateWithoutClientInput> | campaignCreateWithoutClientInput[] | campaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: campaignCreateOrConnectWithoutClientInput | campaignCreateOrConnectWithoutClientInput[]
    upsert?: campaignUpsertWithWhereUniqueWithoutClientInput | campaignUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: campaignCreateManyClientInputEnvelope
    set?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    disconnect?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    delete?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    connect?: campaignWhereUniqueInput | campaignWhereUniqueInput[]
    update?: campaignUpdateWithWhereUniqueWithoutClientInput | campaignUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: campaignUpdateManyWithWhereWithoutClientInput | campaignUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: campaignScalarWhereInput | campaignScalarWhereInput[]
  }

  export type clientCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<clientCreateWithoutCampaignsInput, clientUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: clientCreateOrConnectWithoutCampaignsInput
    connect?: clientWhereUniqueInput
  }

  export type volumeCreateNestedManyWithoutCampaignInput = {
    create?: XOR<volumeCreateWithoutCampaignInput, volumeUncheckedCreateWithoutCampaignInput> | volumeCreateWithoutCampaignInput[] | volumeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: volumeCreateOrConnectWithoutCampaignInput | volumeCreateOrConnectWithoutCampaignInput[]
    createMany?: volumeCreateManyCampaignInputEnvelope
    connect?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
  }

  export type leadCreateNestedManyWithoutCampaignInput = {
    create?: XOR<leadCreateWithoutCampaignInput, leadUncheckedCreateWithoutCampaignInput> | leadCreateWithoutCampaignInput[] | leadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignInput | leadCreateOrConnectWithoutCampaignInput[]
    createMany?: leadCreateManyCampaignInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type campaignDeliveriesCreateNestedManyWithoutCampaignInput = {
    create?: XOR<campaignDeliveriesCreateWithoutCampaignInput, campaignDeliveriesUncheckedCreateWithoutCampaignInput> | campaignDeliveriesCreateWithoutCampaignInput[] | campaignDeliveriesUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutCampaignInput | campaignDeliveriesCreateOrConnectWithoutCampaignInput[]
    createMany?: campaignDeliveriesCreateManyCampaignInputEnvelope
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
  }

  export type volumeUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<volumeCreateWithoutCampaignInput, volumeUncheckedCreateWithoutCampaignInput> | volumeCreateWithoutCampaignInput[] | volumeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: volumeCreateOrConnectWithoutCampaignInput | volumeCreateOrConnectWithoutCampaignInput[]
    createMany?: volumeCreateManyCampaignInputEnvelope
    connect?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
  }

  export type leadUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<leadCreateWithoutCampaignInput, leadUncheckedCreateWithoutCampaignInput> | leadCreateWithoutCampaignInput[] | leadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignInput | leadCreateOrConnectWithoutCampaignInput[]
    createMany?: leadCreateManyCampaignInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type campaignDeliveriesUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<campaignDeliveriesCreateWithoutCampaignInput, campaignDeliveriesUncheckedCreateWithoutCampaignInput> | campaignDeliveriesCreateWithoutCampaignInput[] | campaignDeliveriesUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutCampaignInput | campaignDeliveriesCreateOrConnectWithoutCampaignInput[]
    createMany?: campaignDeliveriesCreateManyCampaignInputEnvelope
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
  }

  export type clientUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<clientCreateWithoutCampaignsInput, clientUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: clientCreateOrConnectWithoutCampaignsInput
    upsert?: clientUpsertWithoutCampaignsInput
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutCampaignsInput, clientUpdateWithoutCampaignsInput>, clientUncheckedUpdateWithoutCampaignsInput>
  }

  export type volumeUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<volumeCreateWithoutCampaignInput, volumeUncheckedCreateWithoutCampaignInput> | volumeCreateWithoutCampaignInput[] | volumeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: volumeCreateOrConnectWithoutCampaignInput | volumeCreateOrConnectWithoutCampaignInput[]
    upsert?: volumeUpsertWithWhereUniqueWithoutCampaignInput | volumeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: volumeCreateManyCampaignInputEnvelope
    set?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    disconnect?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    delete?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    connect?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    update?: volumeUpdateWithWhereUniqueWithoutCampaignInput | volumeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: volumeUpdateManyWithWhereWithoutCampaignInput | volumeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: volumeScalarWhereInput | volumeScalarWhereInput[]
  }

  export type leadUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<leadCreateWithoutCampaignInput, leadUncheckedCreateWithoutCampaignInput> | leadCreateWithoutCampaignInput[] | leadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignInput | leadCreateOrConnectWithoutCampaignInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutCampaignInput | leadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: leadCreateManyCampaignInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutCampaignInput | leadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: leadUpdateManyWithWhereWithoutCampaignInput | leadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type campaignDeliveriesUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<campaignDeliveriesCreateWithoutCampaignInput, campaignDeliveriesUncheckedCreateWithoutCampaignInput> | campaignDeliveriesCreateWithoutCampaignInput[] | campaignDeliveriesUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutCampaignInput | campaignDeliveriesCreateOrConnectWithoutCampaignInput[]
    upsert?: campaignDeliveriesUpsertWithWhereUniqueWithoutCampaignInput | campaignDeliveriesUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: campaignDeliveriesCreateManyCampaignInputEnvelope
    set?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    disconnect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    delete?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    update?: campaignDeliveriesUpdateWithWhereUniqueWithoutCampaignInput | campaignDeliveriesUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: campaignDeliveriesUpdateManyWithWhereWithoutCampaignInput | campaignDeliveriesUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: campaignDeliveriesScalarWhereInput | campaignDeliveriesScalarWhereInput[]
  }

  export type volumeUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<volumeCreateWithoutCampaignInput, volumeUncheckedCreateWithoutCampaignInput> | volumeCreateWithoutCampaignInput[] | volumeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: volumeCreateOrConnectWithoutCampaignInput | volumeCreateOrConnectWithoutCampaignInput[]
    upsert?: volumeUpsertWithWhereUniqueWithoutCampaignInput | volumeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: volumeCreateManyCampaignInputEnvelope
    set?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    disconnect?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    delete?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    connect?: volumeWhereUniqueInput | volumeWhereUniqueInput[]
    update?: volumeUpdateWithWhereUniqueWithoutCampaignInput | volumeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: volumeUpdateManyWithWhereWithoutCampaignInput | volumeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: volumeScalarWhereInput | volumeScalarWhereInput[]
  }

  export type leadUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<leadCreateWithoutCampaignInput, leadUncheckedCreateWithoutCampaignInput> | leadCreateWithoutCampaignInput[] | leadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignInput | leadCreateOrConnectWithoutCampaignInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutCampaignInput | leadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: leadCreateManyCampaignInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutCampaignInput | leadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: leadUpdateManyWithWhereWithoutCampaignInput | leadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type campaignDeliveriesUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<campaignDeliveriesCreateWithoutCampaignInput, campaignDeliveriesUncheckedCreateWithoutCampaignInput> | campaignDeliveriesCreateWithoutCampaignInput[] | campaignDeliveriesUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutCampaignInput | campaignDeliveriesCreateOrConnectWithoutCampaignInput[]
    upsert?: campaignDeliveriesUpsertWithWhereUniqueWithoutCampaignInput | campaignDeliveriesUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: campaignDeliveriesCreateManyCampaignInputEnvelope
    set?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    disconnect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    delete?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    connect?: campaignDeliveriesWhereUniqueInput | campaignDeliveriesWhereUniqueInput[]
    update?: campaignDeliveriesUpdateWithWhereUniqueWithoutCampaignInput | campaignDeliveriesUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: campaignDeliveriesUpdateManyWithWhereWithoutCampaignInput | campaignDeliveriesUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: campaignDeliveriesScalarWhereInput | campaignDeliveriesScalarWhereInput[]
  }

  export type campaignCreateNestedOneWithoutCampaignDeliveriesInput = {
    create?: XOR<campaignCreateWithoutCampaignDeliveriesInput, campaignUncheckedCreateWithoutCampaignDeliveriesInput>
    connectOrCreate?: campaignCreateOrConnectWithoutCampaignDeliveriesInput
    connect?: campaignWhereUniqueInput
  }

  export type userCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<userCreateWithoutDeliveriesInput, userUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: userCreateOrConnectWithoutDeliveriesInput
    connect?: userWhereUniqueInput
  }

  export type leadCreateNestedManyWithoutCampaignDeliveryInput = {
    create?: XOR<leadCreateWithoutCampaignDeliveryInput, leadUncheckedCreateWithoutCampaignDeliveryInput> | leadCreateWithoutCampaignDeliveryInput[] | leadUncheckedCreateWithoutCampaignDeliveryInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignDeliveryInput | leadCreateOrConnectWithoutCampaignDeliveryInput[]
    createMany?: leadCreateManyCampaignDeliveryInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type leadUncheckedCreateNestedManyWithoutCampaignDeliveryInput = {
    create?: XOR<leadCreateWithoutCampaignDeliveryInput, leadUncheckedCreateWithoutCampaignDeliveryInput> | leadCreateWithoutCampaignDeliveryInput[] | leadUncheckedCreateWithoutCampaignDeliveryInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignDeliveryInput | leadCreateOrConnectWithoutCampaignDeliveryInput[]
    createMany?: leadCreateManyCampaignDeliveryInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type campaignUpdateOneRequiredWithoutCampaignDeliveriesNestedInput = {
    create?: XOR<campaignCreateWithoutCampaignDeliveriesInput, campaignUncheckedCreateWithoutCampaignDeliveriesInput>
    connectOrCreate?: campaignCreateOrConnectWithoutCampaignDeliveriesInput
    upsert?: campaignUpsertWithoutCampaignDeliveriesInput
    connect?: campaignWhereUniqueInput
    update?: XOR<XOR<campaignUpdateToOneWithWhereWithoutCampaignDeliveriesInput, campaignUpdateWithoutCampaignDeliveriesInput>, campaignUncheckedUpdateWithoutCampaignDeliveriesInput>
  }

  export type userUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<userCreateWithoutDeliveriesInput, userUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: userCreateOrConnectWithoutDeliveriesInput
    upsert?: userUpsertWithoutDeliveriesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutDeliveriesInput, userUpdateWithoutDeliveriesInput>, userUncheckedUpdateWithoutDeliveriesInput>
  }

  export type leadUpdateManyWithoutCampaignDeliveryNestedInput = {
    create?: XOR<leadCreateWithoutCampaignDeliveryInput, leadUncheckedCreateWithoutCampaignDeliveryInput> | leadCreateWithoutCampaignDeliveryInput[] | leadUncheckedCreateWithoutCampaignDeliveryInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignDeliveryInput | leadCreateOrConnectWithoutCampaignDeliveryInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutCampaignDeliveryInput | leadUpsertWithWhereUniqueWithoutCampaignDeliveryInput[]
    createMany?: leadCreateManyCampaignDeliveryInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutCampaignDeliveryInput | leadUpdateWithWhereUniqueWithoutCampaignDeliveryInput[]
    updateMany?: leadUpdateManyWithWhereWithoutCampaignDeliveryInput | leadUpdateManyWithWhereWithoutCampaignDeliveryInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type leadUncheckedUpdateManyWithoutCampaignDeliveryNestedInput = {
    create?: XOR<leadCreateWithoutCampaignDeliveryInput, leadUncheckedCreateWithoutCampaignDeliveryInput> | leadCreateWithoutCampaignDeliveryInput[] | leadUncheckedCreateWithoutCampaignDeliveryInput[]
    connectOrCreate?: leadCreateOrConnectWithoutCampaignDeliveryInput | leadCreateOrConnectWithoutCampaignDeliveryInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutCampaignDeliveryInput | leadUpsertWithWhereUniqueWithoutCampaignDeliveryInput[]
    createMany?: leadCreateManyCampaignDeliveryInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutCampaignDeliveryInput | leadUpdateWithWhereUniqueWithoutCampaignDeliveryInput[]
    updateMany?: leadUpdateManyWithWhereWithoutCampaignDeliveryInput | leadUpdateManyWithWhereWithoutCampaignDeliveryInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type campaignCreateNestedOneWithoutVolumesInput = {
    create?: XOR<campaignCreateWithoutVolumesInput, campaignUncheckedCreateWithoutVolumesInput>
    connectOrCreate?: campaignCreateOrConnectWithoutVolumesInput
    connect?: campaignWhereUniqueInput
  }

  export type pacingCreateNestedManyWithoutVolumeInput = {
    create?: XOR<pacingCreateWithoutVolumeInput, pacingUncheckedCreateWithoutVolumeInput> | pacingCreateWithoutVolumeInput[] | pacingUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: pacingCreateOrConnectWithoutVolumeInput | pacingCreateOrConnectWithoutVolumeInput[]
    createMany?: pacingCreateManyVolumeInputEnvelope
    connect?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
  }

  export type leadCreateNestedManyWithoutVolumeInput = {
    create?: XOR<leadCreateWithoutVolumeInput, leadUncheckedCreateWithoutVolumeInput> | leadCreateWithoutVolumeInput[] | leadUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: leadCreateOrConnectWithoutVolumeInput | leadCreateOrConnectWithoutVolumeInput[]
    createMany?: leadCreateManyVolumeInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type pacingUncheckedCreateNestedManyWithoutVolumeInput = {
    create?: XOR<pacingCreateWithoutVolumeInput, pacingUncheckedCreateWithoutVolumeInput> | pacingCreateWithoutVolumeInput[] | pacingUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: pacingCreateOrConnectWithoutVolumeInput | pacingCreateOrConnectWithoutVolumeInput[]
    createMany?: pacingCreateManyVolumeInputEnvelope
    connect?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
  }

  export type leadUncheckedCreateNestedManyWithoutVolumeInput = {
    create?: XOR<leadCreateWithoutVolumeInput, leadUncheckedCreateWithoutVolumeInput> | leadCreateWithoutVolumeInput[] | leadUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: leadCreateOrConnectWithoutVolumeInput | leadCreateOrConnectWithoutVolumeInput[]
    createMany?: leadCreateManyVolumeInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type EnumVolumeStatusFieldUpdateOperationsInput = {
    set?: $Enums.VolumeStatus
  }

  export type campaignUpdateOneRequiredWithoutVolumesNestedInput = {
    create?: XOR<campaignCreateWithoutVolumesInput, campaignUncheckedCreateWithoutVolumesInput>
    connectOrCreate?: campaignCreateOrConnectWithoutVolumesInput
    upsert?: campaignUpsertWithoutVolumesInput
    connect?: campaignWhereUniqueInput
    update?: XOR<XOR<campaignUpdateToOneWithWhereWithoutVolumesInput, campaignUpdateWithoutVolumesInput>, campaignUncheckedUpdateWithoutVolumesInput>
  }

  export type pacingUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<pacingCreateWithoutVolumeInput, pacingUncheckedCreateWithoutVolumeInput> | pacingCreateWithoutVolumeInput[] | pacingUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: pacingCreateOrConnectWithoutVolumeInput | pacingCreateOrConnectWithoutVolumeInput[]
    upsert?: pacingUpsertWithWhereUniqueWithoutVolumeInput | pacingUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: pacingCreateManyVolumeInputEnvelope
    set?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    disconnect?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    delete?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    connect?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    update?: pacingUpdateWithWhereUniqueWithoutVolumeInput | pacingUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: pacingUpdateManyWithWhereWithoutVolumeInput | pacingUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: pacingScalarWhereInput | pacingScalarWhereInput[]
  }

  export type leadUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<leadCreateWithoutVolumeInput, leadUncheckedCreateWithoutVolumeInput> | leadCreateWithoutVolumeInput[] | leadUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: leadCreateOrConnectWithoutVolumeInput | leadCreateOrConnectWithoutVolumeInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutVolumeInput | leadUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: leadCreateManyVolumeInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutVolumeInput | leadUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: leadUpdateManyWithWhereWithoutVolumeInput | leadUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type pacingUncheckedUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<pacingCreateWithoutVolumeInput, pacingUncheckedCreateWithoutVolumeInput> | pacingCreateWithoutVolumeInput[] | pacingUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: pacingCreateOrConnectWithoutVolumeInput | pacingCreateOrConnectWithoutVolumeInput[]
    upsert?: pacingUpsertWithWhereUniqueWithoutVolumeInput | pacingUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: pacingCreateManyVolumeInputEnvelope
    set?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    disconnect?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    delete?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    connect?: pacingWhereUniqueInput | pacingWhereUniqueInput[]
    update?: pacingUpdateWithWhereUniqueWithoutVolumeInput | pacingUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: pacingUpdateManyWithWhereWithoutVolumeInput | pacingUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: pacingScalarWhereInput | pacingScalarWhereInput[]
  }

  export type leadUncheckedUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<leadCreateWithoutVolumeInput, leadUncheckedCreateWithoutVolumeInput> | leadCreateWithoutVolumeInput[] | leadUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: leadCreateOrConnectWithoutVolumeInput | leadCreateOrConnectWithoutVolumeInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutVolumeInput | leadUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: leadCreateManyVolumeInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutVolumeInput | leadUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: leadUpdateManyWithWhereWithoutVolumeInput | leadUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type BriefUpdatesCreateNestedManyWithoutBreifInput = {
    create?: XOR<BriefUpdatesCreateWithoutBreifInput, BriefUpdatesUncheckedCreateWithoutBreifInput> | BriefUpdatesCreateWithoutBreifInput[] | BriefUpdatesUncheckedCreateWithoutBreifInput[]
    connectOrCreate?: BriefUpdatesCreateOrConnectWithoutBreifInput | BriefUpdatesCreateOrConnectWithoutBreifInput[]
    createMany?: BriefUpdatesCreateManyBreifInputEnvelope
    connect?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
  }

  export type BriefUpdatesUncheckedCreateNestedManyWithoutBreifInput = {
    create?: XOR<BriefUpdatesCreateWithoutBreifInput, BriefUpdatesUncheckedCreateWithoutBreifInput> | BriefUpdatesCreateWithoutBreifInput[] | BriefUpdatesUncheckedCreateWithoutBreifInput[]
    connectOrCreate?: BriefUpdatesCreateOrConnectWithoutBreifInput | BriefUpdatesCreateOrConnectWithoutBreifInput[]
    createMany?: BriefUpdatesCreateManyBreifInputEnvelope
    connect?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
  }

  export type EnumBriefStatusFieldUpdateOperationsInput = {
    set?: $Enums.BriefStatus
  }

  export type EnumBriefTypeFieldUpdateOperationsInput = {
    set?: $Enums.BriefType
  }

  export type BriefUpdatesUpdateManyWithoutBreifNestedInput = {
    create?: XOR<BriefUpdatesCreateWithoutBreifInput, BriefUpdatesUncheckedCreateWithoutBreifInput> | BriefUpdatesCreateWithoutBreifInput[] | BriefUpdatesUncheckedCreateWithoutBreifInput[]
    connectOrCreate?: BriefUpdatesCreateOrConnectWithoutBreifInput | BriefUpdatesCreateOrConnectWithoutBreifInput[]
    upsert?: BriefUpdatesUpsertWithWhereUniqueWithoutBreifInput | BriefUpdatesUpsertWithWhereUniqueWithoutBreifInput[]
    createMany?: BriefUpdatesCreateManyBreifInputEnvelope
    set?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    disconnect?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    delete?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    connect?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    update?: BriefUpdatesUpdateWithWhereUniqueWithoutBreifInput | BriefUpdatesUpdateWithWhereUniqueWithoutBreifInput[]
    updateMany?: BriefUpdatesUpdateManyWithWhereWithoutBreifInput | BriefUpdatesUpdateManyWithWhereWithoutBreifInput[]
    deleteMany?: BriefUpdatesScalarWhereInput | BriefUpdatesScalarWhereInput[]
  }

  export type BriefUpdatesUncheckedUpdateManyWithoutBreifNestedInput = {
    create?: XOR<BriefUpdatesCreateWithoutBreifInput, BriefUpdatesUncheckedCreateWithoutBreifInput> | BriefUpdatesCreateWithoutBreifInput[] | BriefUpdatesUncheckedCreateWithoutBreifInput[]
    connectOrCreate?: BriefUpdatesCreateOrConnectWithoutBreifInput | BriefUpdatesCreateOrConnectWithoutBreifInput[]
    upsert?: BriefUpdatesUpsertWithWhereUniqueWithoutBreifInput | BriefUpdatesUpsertWithWhereUniqueWithoutBreifInput[]
    createMany?: BriefUpdatesCreateManyBreifInputEnvelope
    set?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    disconnect?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    delete?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    connect?: BriefUpdatesWhereUniqueInput | BriefUpdatesWhereUniqueInput[]
    update?: BriefUpdatesUpdateWithWhereUniqueWithoutBreifInput | BriefUpdatesUpdateWithWhereUniqueWithoutBreifInput[]
    updateMany?: BriefUpdatesUpdateManyWithWhereWithoutBreifInput | BriefUpdatesUpdateManyWithWhereWithoutBreifInput[]
    deleteMany?: BriefUpdatesScalarWhereInput | BriefUpdatesScalarWhereInput[]
  }

  export type BriefCreateNestedOneWithoutBriefUpdatesInput = {
    create?: XOR<BriefCreateWithoutBriefUpdatesInput, BriefUncheckedCreateWithoutBriefUpdatesInput>
    connectOrCreate?: BriefCreateOrConnectWithoutBriefUpdatesInput
    connect?: BriefWhereUniqueInput
  }

  export type BriefUpdateOneRequiredWithoutBriefUpdatesNestedInput = {
    create?: XOR<BriefCreateWithoutBriefUpdatesInput, BriefUncheckedCreateWithoutBriefUpdatesInput>
    connectOrCreate?: BriefCreateOrConnectWithoutBriefUpdatesInput
    upsert?: BriefUpsertWithoutBriefUpdatesInput
    connect?: BriefWhereUniqueInput
    update?: XOR<XOR<BriefUpdateToOneWithWhereWithoutBriefUpdatesInput, BriefUpdateWithoutBriefUpdatesInput>, BriefUncheckedUpdateWithoutBriefUpdatesInput>
  }

  export type volumeCreateNestedOneWithoutPacingsInput = {
    create?: XOR<volumeCreateWithoutPacingsInput, volumeUncheckedCreateWithoutPacingsInput>
    connectOrCreate?: volumeCreateOrConnectWithoutPacingsInput
    connect?: volumeWhereUniqueInput
  }

  export type leadCreateNestedManyWithoutPacingInput = {
    create?: XOR<leadCreateWithoutPacingInput, leadUncheckedCreateWithoutPacingInput> | leadCreateWithoutPacingInput[] | leadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadCreateOrConnectWithoutPacingInput | leadCreateOrConnectWithoutPacingInput[]
    createMany?: leadCreateManyPacingInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type leadsUploadCreateNestedManyWithoutPacingInput = {
    create?: XOR<leadsUploadCreateWithoutPacingInput, leadsUploadUncheckedCreateWithoutPacingInput> | leadsUploadCreateWithoutPacingInput[] | leadsUploadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutPacingInput | leadsUploadCreateOrConnectWithoutPacingInput[]
    createMany?: leadsUploadCreateManyPacingInputEnvelope
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
  }

  export type leadUncheckedCreateNestedManyWithoutPacingInput = {
    create?: XOR<leadCreateWithoutPacingInput, leadUncheckedCreateWithoutPacingInput> | leadCreateWithoutPacingInput[] | leadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadCreateOrConnectWithoutPacingInput | leadCreateOrConnectWithoutPacingInput[]
    createMany?: leadCreateManyPacingInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type leadsUploadUncheckedCreateNestedManyWithoutPacingInput = {
    create?: XOR<leadsUploadCreateWithoutPacingInput, leadsUploadUncheckedCreateWithoutPacingInput> | leadsUploadCreateWithoutPacingInput[] | leadsUploadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutPacingInput | leadsUploadCreateOrConnectWithoutPacingInput[]
    createMany?: leadsUploadCreateManyPacingInputEnvelope
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
  }

  export type volumeUpdateOneRequiredWithoutPacingsNestedInput = {
    create?: XOR<volumeCreateWithoutPacingsInput, volumeUncheckedCreateWithoutPacingsInput>
    connectOrCreate?: volumeCreateOrConnectWithoutPacingsInput
    upsert?: volumeUpsertWithoutPacingsInput
    connect?: volumeWhereUniqueInput
    update?: XOR<XOR<volumeUpdateToOneWithWhereWithoutPacingsInput, volumeUpdateWithoutPacingsInput>, volumeUncheckedUpdateWithoutPacingsInput>
  }

  export type leadUpdateManyWithoutPacingNestedInput = {
    create?: XOR<leadCreateWithoutPacingInput, leadUncheckedCreateWithoutPacingInput> | leadCreateWithoutPacingInput[] | leadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadCreateOrConnectWithoutPacingInput | leadCreateOrConnectWithoutPacingInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutPacingInput | leadUpsertWithWhereUniqueWithoutPacingInput[]
    createMany?: leadCreateManyPacingInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutPacingInput | leadUpdateWithWhereUniqueWithoutPacingInput[]
    updateMany?: leadUpdateManyWithWhereWithoutPacingInput | leadUpdateManyWithWhereWithoutPacingInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type leadsUploadUpdateManyWithoutPacingNestedInput = {
    create?: XOR<leadsUploadCreateWithoutPacingInput, leadsUploadUncheckedCreateWithoutPacingInput> | leadsUploadCreateWithoutPacingInput[] | leadsUploadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutPacingInput | leadsUploadCreateOrConnectWithoutPacingInput[]
    upsert?: leadsUploadUpsertWithWhereUniqueWithoutPacingInput | leadsUploadUpsertWithWhereUniqueWithoutPacingInput[]
    createMany?: leadsUploadCreateManyPacingInputEnvelope
    set?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    disconnect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    delete?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    update?: leadsUploadUpdateWithWhereUniqueWithoutPacingInput | leadsUploadUpdateWithWhereUniqueWithoutPacingInput[]
    updateMany?: leadsUploadUpdateManyWithWhereWithoutPacingInput | leadsUploadUpdateManyWithWhereWithoutPacingInput[]
    deleteMany?: leadsUploadScalarWhereInput | leadsUploadScalarWhereInput[]
  }

  export type leadUncheckedUpdateManyWithoutPacingNestedInput = {
    create?: XOR<leadCreateWithoutPacingInput, leadUncheckedCreateWithoutPacingInput> | leadCreateWithoutPacingInput[] | leadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadCreateOrConnectWithoutPacingInput | leadCreateOrConnectWithoutPacingInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutPacingInput | leadUpsertWithWhereUniqueWithoutPacingInput[]
    createMany?: leadCreateManyPacingInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutPacingInput | leadUpdateWithWhereUniqueWithoutPacingInput[]
    updateMany?: leadUpdateManyWithWhereWithoutPacingInput | leadUpdateManyWithWhereWithoutPacingInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type leadsUploadUncheckedUpdateManyWithoutPacingNestedInput = {
    create?: XOR<leadsUploadCreateWithoutPacingInput, leadsUploadUncheckedCreateWithoutPacingInput> | leadsUploadCreateWithoutPacingInput[] | leadsUploadUncheckedCreateWithoutPacingInput[]
    connectOrCreate?: leadsUploadCreateOrConnectWithoutPacingInput | leadsUploadCreateOrConnectWithoutPacingInput[]
    upsert?: leadsUploadUpsertWithWhereUniqueWithoutPacingInput | leadsUploadUpsertWithWhereUniqueWithoutPacingInput[]
    createMany?: leadsUploadCreateManyPacingInputEnvelope
    set?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    disconnect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    delete?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    connect?: leadsUploadWhereUniqueInput | leadsUploadWhereUniqueInput[]
    update?: leadsUploadUpdateWithWhereUniqueWithoutPacingInput | leadsUploadUpdateWithWhereUniqueWithoutPacingInput[]
    updateMany?: leadsUploadUpdateManyWithWhereWithoutPacingInput | leadsUploadUpdateManyWithWhereWithoutPacingInput[]
    deleteMany?: leadsUploadScalarWhereInput | leadsUploadScalarWhereInput[]
  }

  export type campaignCreateNestedOneWithoutLeadsInput = {
    create?: XOR<campaignCreateWithoutLeadsInput, campaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: campaignCreateOrConnectWithoutLeadsInput
    connect?: campaignWhereUniqueInput
  }

  export type pacingCreateNestedOneWithoutLeadsInput = {
    create?: XOR<pacingCreateWithoutLeadsInput, pacingUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: pacingCreateOrConnectWithoutLeadsInput
    connect?: pacingWhereUniqueInput
  }

  export type volumeCreateNestedOneWithoutLeadsInput = {
    create?: XOR<volumeCreateWithoutLeadsInput, volumeUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: volumeCreateOrConnectWithoutLeadsInput
    connect?: volumeWhereUniqueInput
  }

  export type leadsUploadCreateNestedOneWithoutLeadsInput = {
    create?: XOR<leadsUploadCreateWithoutLeadsInput, leadsUploadUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: leadsUploadCreateOrConnectWithoutLeadsInput
    connect?: leadsUploadWhereUniqueInput
  }

  export type campaignDeliveriesCreateNestedOneWithoutLeadsInput = {
    create?: XOR<campaignDeliveriesCreateWithoutLeadsInput, campaignDeliveriesUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutLeadsInput
    connect?: campaignDeliveriesWhereUniqueInput
  }

  export type campaignUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<campaignCreateWithoutLeadsInput, campaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: campaignCreateOrConnectWithoutLeadsInput
    upsert?: campaignUpsertWithoutLeadsInput
    connect?: campaignWhereUniqueInput
    update?: XOR<XOR<campaignUpdateToOneWithWhereWithoutLeadsInput, campaignUpdateWithoutLeadsInput>, campaignUncheckedUpdateWithoutLeadsInput>
  }

  export type pacingUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<pacingCreateWithoutLeadsInput, pacingUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: pacingCreateOrConnectWithoutLeadsInput
    upsert?: pacingUpsertWithoutLeadsInput
    connect?: pacingWhereUniqueInput
    update?: XOR<XOR<pacingUpdateToOneWithWhereWithoutLeadsInput, pacingUpdateWithoutLeadsInput>, pacingUncheckedUpdateWithoutLeadsInput>
  }

  export type volumeUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<volumeCreateWithoutLeadsInput, volumeUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: volumeCreateOrConnectWithoutLeadsInput
    upsert?: volumeUpsertWithoutLeadsInput
    connect?: volumeWhereUniqueInput
    update?: XOR<XOR<volumeUpdateToOneWithWhereWithoutLeadsInput, volumeUpdateWithoutLeadsInput>, volumeUncheckedUpdateWithoutLeadsInput>
  }

  export type leadsUploadUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<leadsUploadCreateWithoutLeadsInput, leadsUploadUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: leadsUploadCreateOrConnectWithoutLeadsInput
    upsert?: leadsUploadUpsertWithoutLeadsInput
    disconnect?: leadsUploadWhereInput | boolean
    delete?: leadsUploadWhereInput | boolean
    connect?: leadsUploadWhereUniqueInput
    update?: XOR<XOR<leadsUploadUpdateToOneWithWhereWithoutLeadsInput, leadsUploadUpdateWithoutLeadsInput>, leadsUploadUncheckedUpdateWithoutLeadsInput>
  }

  export type campaignDeliveriesUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<campaignDeliveriesCreateWithoutLeadsInput, campaignDeliveriesUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: campaignDeliveriesCreateOrConnectWithoutLeadsInput
    upsert?: campaignDeliveriesUpsertWithoutLeadsInput
    disconnect?: campaignDeliveriesWhereInput | boolean
    delete?: campaignDeliveriesWhereInput | boolean
    connect?: campaignDeliveriesWhereUniqueInput
    update?: XOR<XOR<campaignDeliveriesUpdateToOneWithWhereWithoutLeadsInput, campaignDeliveriesUpdateWithoutLeadsInput>, campaignDeliveriesUncheckedUpdateWithoutLeadsInput>
  }

  export type pacingCreateNestedOneWithoutUploadsInput = {
    create?: XOR<pacingCreateWithoutUploadsInput, pacingUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: pacingCreateOrConnectWithoutUploadsInput
    connect?: pacingWhereUniqueInput
  }

  export type leadCreateNestedManyWithoutUploadInput = {
    create?: XOR<leadCreateWithoutUploadInput, leadUncheckedCreateWithoutUploadInput> | leadCreateWithoutUploadInput[] | leadUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: leadCreateOrConnectWithoutUploadInput | leadCreateOrConnectWithoutUploadInput[]
    createMany?: leadCreateManyUploadInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutUploadsInput = {
    create?: XOR<userCreateWithoutUploadsInput, userUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: userCreateOrConnectWithoutUploadsInput
    connect?: userWhereUniqueInput
  }

  export type leadUncheckedCreateNestedManyWithoutUploadInput = {
    create?: XOR<leadCreateWithoutUploadInput, leadUncheckedCreateWithoutUploadInput> | leadCreateWithoutUploadInput[] | leadUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: leadCreateOrConnectWithoutUploadInput | leadCreateOrConnectWithoutUploadInput[]
    createMany?: leadCreateManyUploadInputEnvelope
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
  }

  export type pacingUpdateOneRequiredWithoutUploadsNestedInput = {
    create?: XOR<pacingCreateWithoutUploadsInput, pacingUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: pacingCreateOrConnectWithoutUploadsInput
    upsert?: pacingUpsertWithoutUploadsInput
    connect?: pacingWhereUniqueInput
    update?: XOR<XOR<pacingUpdateToOneWithWhereWithoutUploadsInput, pacingUpdateWithoutUploadsInput>, pacingUncheckedUpdateWithoutUploadsInput>
  }

  export type leadUpdateManyWithoutUploadNestedInput = {
    create?: XOR<leadCreateWithoutUploadInput, leadUncheckedCreateWithoutUploadInput> | leadCreateWithoutUploadInput[] | leadUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: leadCreateOrConnectWithoutUploadInput | leadCreateOrConnectWithoutUploadInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutUploadInput | leadUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: leadCreateManyUploadInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutUploadInput | leadUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: leadUpdateManyWithWhereWithoutUploadInput | leadUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type userUpdateOneWithoutUploadsNestedInput = {
    create?: XOR<userCreateWithoutUploadsInput, userUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: userCreateOrConnectWithoutUploadsInput
    upsert?: userUpsertWithoutUploadsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUploadsInput, userUpdateWithoutUploadsInput>, userUncheckedUpdateWithoutUploadsInput>
  }

  export type leadUncheckedUpdateManyWithoutUploadNestedInput = {
    create?: XOR<leadCreateWithoutUploadInput, leadUncheckedCreateWithoutUploadInput> | leadCreateWithoutUploadInput[] | leadUncheckedCreateWithoutUploadInput[]
    connectOrCreate?: leadCreateOrConnectWithoutUploadInput | leadCreateOrConnectWithoutUploadInput[]
    upsert?: leadUpsertWithWhereUniqueWithoutUploadInput | leadUpsertWithWhereUniqueWithoutUploadInput[]
    createMany?: leadCreateManyUploadInputEnvelope
    set?: leadWhereUniqueInput | leadWhereUniqueInput[]
    disconnect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    delete?: leadWhereUniqueInput | leadWhereUniqueInput[]
    connect?: leadWhereUniqueInput | leadWhereUniqueInput[]
    update?: leadUpdateWithWhereUniqueWithoutUploadInput | leadUpdateWithWhereUniqueWithoutUploadInput[]
    updateMany?: leadUpdateManyWithWhereWithoutUploadInput | leadUpdateManyWithWhereWithoutUploadInput[]
    deleteMany?: leadScalarWhereInput | leadScalarWhereInput[]
  }

  export type EnumreportTypeFieldUpdateOperationsInput = {
    set?: $Enums.reportType
  }

  export type EnumgeneratedTypeFieldUpdateOperationsInput = {
    set?: $Enums.generatedType
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveDurationFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveDuration | EnumLeaveDurationFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveDuration[]
    notIn?: $Enums.LeaveDuration[]
    not?: NestedEnumLeaveDurationFilter<$PrismaModel> | $Enums.LeaveDuration
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveDurationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveDuration | EnumLeaveDurationFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveDuration[]
    notIn?: $Enums.LeaveDuration[]
    not?: NestedEnumLeaveDurationWithAggregatesFilter<$PrismaModel> | $Enums.LeaveDuration
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveDurationFilter<$PrismaModel>
    _max?: NestedEnumLeaveDurationFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[]
    notIn?: $Enums.SessionType[]
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[]
    notIn?: $Enums.SessionType[]
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumTaskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLevel | EnumTaskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLevel[]
    notIn?: $Enums.TaskLevel[]
    not?: NestedEnumTaskLevelFilter<$PrismaModel> | $Enums.TaskLevel
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLevel | EnumTaskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLevel[]
    notIn?: $Enums.TaskLevel[]
    not?: NestedEnumTaskLevelWithAggregatesFilter<$PrismaModel> | $Enums.TaskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskLevelFilter<$PrismaModel>
    _max?: NestedEnumTaskLevelFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVolumeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VolumeStatus | EnumVolumeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolumeStatus[]
    notIn?: $Enums.VolumeStatus[]
    not?: NestedEnumVolumeStatusFilter<$PrismaModel> | $Enums.VolumeStatus
  }

  export type NestedEnumVolumeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VolumeStatus | EnumVolumeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VolumeStatus[]
    notIn?: $Enums.VolumeStatus[]
    not?: NestedEnumVolumeStatusWithAggregatesFilter<$PrismaModel> | $Enums.VolumeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVolumeStatusFilter<$PrismaModel>
    _max?: NestedEnumVolumeStatusFilter<$PrismaModel>
  }

  export type NestedEnumBriefStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefStatus | EnumBriefStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BriefStatus[]
    notIn?: $Enums.BriefStatus[]
    not?: NestedEnumBriefStatusFilter<$PrismaModel> | $Enums.BriefStatus
  }

  export type NestedEnumBriefTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefType | EnumBriefTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BriefType[]
    notIn?: $Enums.BriefType[]
    not?: NestedEnumBriefTypeFilter<$PrismaModel> | $Enums.BriefType
  }

  export type NestedEnumBriefStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefStatus | EnumBriefStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BriefStatus[]
    notIn?: $Enums.BriefStatus[]
    not?: NestedEnumBriefStatusWithAggregatesFilter<$PrismaModel> | $Enums.BriefStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBriefStatusFilter<$PrismaModel>
    _max?: NestedEnumBriefStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBriefTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BriefType | EnumBriefTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BriefType[]
    notIn?: $Enums.BriefType[]
    not?: NestedEnumBriefTypeWithAggregatesFilter<$PrismaModel> | $Enums.BriefType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBriefTypeFilter<$PrismaModel>
    _max?: NestedEnumBriefTypeFilter<$PrismaModel>
  }

  export type NestedEnumreportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.reportType | EnumreportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.reportType[]
    notIn?: $Enums.reportType[]
    not?: NestedEnumreportTypeFilter<$PrismaModel> | $Enums.reportType
  }

  export type NestedEnumgeneratedTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedType | EnumgeneratedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedType[]
    notIn?: $Enums.generatedType[]
    not?: NestedEnumgeneratedTypeFilter<$PrismaModel> | $Enums.generatedType
  }

  export type NestedEnumreportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reportType | EnumreportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.reportType[]
    notIn?: $Enums.reportType[]
    not?: NestedEnumreportTypeWithAggregatesFilter<$PrismaModel> | $Enums.reportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreportTypeFilter<$PrismaModel>
    _max?: NestedEnumreportTypeFilter<$PrismaModel>
  }

  export type NestedEnumgeneratedTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedType | EnumgeneratedTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedType[]
    notIn?: $Enums.generatedType[]
    not?: NestedEnumgeneratedTypeWithAggregatesFilter<$PrismaModel> | $Enums.generatedType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgeneratedTypeFilter<$PrismaModel>
    _max?: NestedEnumgeneratedTypeFilter<$PrismaModel>
  }

  export type leadsUploadCreateWithoutUploaderInput = {
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    pacing: pacingCreateNestedOneWithoutUploadsInput
    leads?: leadCreateNestedManyWithoutUploadInput
  }

  export type leadsUploadUncheckedCreateWithoutUploaderInput = {
    id?: number
    pacingId: number
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    leads?: leadUncheckedCreateNestedManyWithoutUploadInput
  }

  export type leadsUploadCreateOrConnectWithoutUploaderInput = {
    where: leadsUploadWhereUniqueInput
    create: XOR<leadsUploadCreateWithoutUploaderInput, leadsUploadUncheckedCreateWithoutUploaderInput>
  }

  export type leadsUploadCreateManyUploaderInputEnvelope = {
    data: leadsUploadCreateManyUploaderInput | leadsUploadCreateManyUploaderInput[]
  }

  export type userroleCreateWithoutUserInput = {
    role?: roleCreateNestedOneWithoutUsersInput
  }

  export type userroleUncheckedCreateWithoutUserInput = {
    id?: number
    roleId?: number
  }

  export type userroleCreateOrConnectWithoutUserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleCreateManyUserInputEnvelope = {
    data: userroleCreateManyUserInput | userroleCreateManyUserInput[]
  }

  export type UserLeaveCreateWithoutUserInput = {
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    created_at?: Date | string
    updated_at?: Date | string
    approvedBy?: userCreateNestedOneWithoutApprovedLeavesInput
  }

  export type UserLeaveUncheckedCreateWithoutUserInput = {
    id?: number
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserLeaveCreateOrConnectWithoutUserInput = {
    where: UserLeaveWhereUniqueInput
    create: XOR<UserLeaveCreateWithoutUserInput, UserLeaveUncheckedCreateWithoutUserInput>
  }

  export type UserLeaveCreateManyUserInputEnvelope = {
    data: UserLeaveCreateManyUserInput | UserLeaveCreateManyUserInput[]
  }

  export type UserLeaveCreateWithoutApprovedByInput = {
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutLeavesInput
  }

  export type UserLeaveUncheckedCreateWithoutApprovedByInput = {
    id?: number
    userId: number
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserLeaveCreateOrConnectWithoutApprovedByInput = {
    where: UserLeaveWhereUniqueInput
    create: XOR<UserLeaveCreateWithoutApprovedByInput, UserLeaveUncheckedCreateWithoutApprovedByInput>
  }

  export type UserLeaveCreateManyApprovedByInputEnvelope = {
    data: UserLeaveCreateManyApprovedByInput | UserLeaveCreateManyApprovedByInput[]
  }

  export type messageCreateWithoutSenderInput = {
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
    recipient: userCreateNestedOneWithoutReceivedMessagesInput
  }

  export type messageUncheckedCreateWithoutSenderInput = {
    id?: number
    body: string
    recipientId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type messageCreateOrConnectWithoutSenderInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutSenderInput, messageUncheckedCreateWithoutSenderInput>
  }

  export type messageCreateManySenderInputEnvelope = {
    data: messageCreateManySenderInput | messageCreateManySenderInput[]
  }

  export type messageCreateWithoutRecipientInput = {
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
    sender: userCreateNestedOneWithoutSentMessagesInput
  }

  export type messageUncheckedCreateWithoutRecipientInput = {
    id?: number
    body: string
    senderId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type messageCreateOrConnectWithoutRecipientInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutRecipientInput, messageUncheckedCreateWithoutRecipientInput>
  }

  export type messageCreateManyRecipientInputEnvelope = {
    data: messageCreateManyRecipientInput | messageCreateManyRecipientInput[]
  }

  export type userGroupsCreateWithoutUserInput = {
    assignedAt?: Date | string
    group: groupCreateNestedOneWithoutMembersInput
  }

  export type userGroupsUncheckedCreateWithoutUserInput = {
    groupId: number
    assignedAt?: Date | string
  }

  export type userGroupsCreateOrConnectWithoutUserInput = {
    where: userGroupsWhereUniqueInput
    create: XOR<userGroupsCreateWithoutUserInput, userGroupsUncheckedCreateWithoutUserInput>
  }

  export type userGroupsCreateManyUserInputEnvelope = {
    data: userGroupsCreateManyUserInput | userGroupsCreateManyUserInput[]
  }

  export type groupMessageCreateWithoutSenderInput = {
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
    group: groupCreateNestedOneWithoutGroupMessagesInput
  }

  export type groupMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    groupId: number
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type groupMessageCreateOrConnectWithoutSenderInput = {
    where: groupMessageWhereUniqueInput
    create: XOR<groupMessageCreateWithoutSenderInput, groupMessageUncheckedCreateWithoutSenderInput>
  }

  export type groupMessageCreateManySenderInputEnvelope = {
    data: groupMessageCreateManySenderInput | groupMessageCreateManySenderInput[]
  }

  export type UserTaskCreateWithoutUserInput = {
    totalTime: number
    task: TaskCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutTaskInput
    assignee: userCreateNestedOneWithoutAssignedTasksInput
  }

  export type UserTaskUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    totalTime: number
    assignedById: number
    sessions?: SessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type UserTaskCreateOrConnectWithoutUserInput = {
    where: UserTaskWhereUniqueInput
    create: XOR<UserTaskCreateWithoutUserInput, UserTaskUncheckedCreateWithoutUserInput>
  }

  export type UserTaskCreateManyUserInputEnvelope = {
    data: UserTaskCreateManyUserInput | UserTaskCreateManyUserInput[]
  }

  export type UserBreakCreateWithoutUserInput = {
    totalTime: number
    break: BreakCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutBreakInput
  }

  export type UserBreakUncheckedCreateWithoutUserInput = {
    id?: number
    breakId: number
    totalTime: number
    sessions?: SessionUncheckedCreateNestedManyWithoutBreakInput
  }

  export type UserBreakCreateOrConnectWithoutUserInput = {
    where: UserBreakWhereUniqueInput
    create: XOR<UserBreakCreateWithoutUserInput, UserBreakUncheckedCreateWithoutUserInput>
  }

  export type UserBreakCreateManyUserInputEnvelope = {
    data: UserBreakCreateManyUserInput | UserBreakCreateManyUserInput[]
  }

  export type UserTaskCreateWithoutAssigneeInput = {
    totalTime: number
    user: userCreateNestedOneWithoutTasksInput
    task: TaskCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutTaskInput
  }

  export type UserTaskUncheckedCreateWithoutAssigneeInput = {
    id?: number
    userId: number
    taskId: number
    totalTime: number
    sessions?: SessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type UserTaskCreateOrConnectWithoutAssigneeInput = {
    where: UserTaskWhereUniqueInput
    create: XOR<UserTaskCreateWithoutAssigneeInput, UserTaskUncheckedCreateWithoutAssigneeInput>
  }

  export type UserTaskCreateManyAssigneeInputEnvelope = {
    data: UserTaskCreateManyAssigneeInput | UserTaskCreateManyAssigneeInput[]
  }

  export type SessionCreateWithoutUserInput = {
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    task?: UserTaskCreateNestedOneWithoutSessionsInput
    break?: UserBreakCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    taskId?: number | null
    breakId?: number | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type campaignDeliveriesCreateWithoutUploaderInput = {
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    data?: string
    campaign?: campaignCreateNestedOneWithoutCampaignDeliveriesInput
    leads?: leadCreateNestedManyWithoutCampaignDeliveryInput
  }

  export type campaignDeliveriesUncheckedCreateWithoutUploaderInput = {
    id?: number
    campaignId?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    data?: string
    leads?: leadUncheckedCreateNestedManyWithoutCampaignDeliveryInput
  }

  export type campaignDeliveriesCreateOrConnectWithoutUploaderInput = {
    where: campaignDeliveriesWhereUniqueInput
    create: XOR<campaignDeliveriesCreateWithoutUploaderInput, campaignDeliveriesUncheckedCreateWithoutUploaderInput>
  }

  export type campaignDeliveriesCreateManyUploaderInputEnvelope = {
    data: campaignDeliveriesCreateManyUploaderInput | campaignDeliveriesCreateManyUploaderInput[]
  }

  export type AttendanceCreateWithoutUserInput = {
    date?: Date | string
    checkIn?: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: number
    date?: Date | string
    checkIn?: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
  }

  export type leadsUploadUpsertWithWhereUniqueWithoutUploaderInput = {
    where: leadsUploadWhereUniqueInput
    update: XOR<leadsUploadUpdateWithoutUploaderInput, leadsUploadUncheckedUpdateWithoutUploaderInput>
    create: XOR<leadsUploadCreateWithoutUploaderInput, leadsUploadUncheckedCreateWithoutUploaderInput>
  }

  export type leadsUploadUpdateWithWhereUniqueWithoutUploaderInput = {
    where: leadsUploadWhereUniqueInput
    data: XOR<leadsUploadUpdateWithoutUploaderInput, leadsUploadUncheckedUpdateWithoutUploaderInput>
  }

  export type leadsUploadUpdateManyWithWhereWithoutUploaderInput = {
    where: leadsUploadScalarWhereInput
    data: XOR<leadsUploadUpdateManyMutationInput, leadsUploadUncheckedUpdateManyWithoutUploaderInput>
  }

  export type leadsUploadScalarWhereInput = {
    AND?: leadsUploadScalarWhereInput | leadsUploadScalarWhereInput[]
    OR?: leadsUploadScalarWhereInput[]
    NOT?: leadsUploadScalarWhereInput | leadsUploadScalarWhereInput[]
    id?: IntFilter<"leadsUpload"> | number
    pacingId?: IntFilter<"leadsUpload"> | number
    uploadedBy?: IntNullableFilter<"leadsUpload"> | number | null
    filename?: StringNullableFilter<"leadsUpload"> | string | null
    created_at?: DateTimeFilter<"leadsUpload"> | Date | string
    updated_at?: DateTimeFilter<"leadsUpload"> | Date | string
    results?: JsonFilter<"leadsUpload">
  }

  export type userroleUpsertWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
  }

  export type userroleUpdateManyWithWhereWithoutUserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUserInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    id?: IntFilter<"userrole"> | number
    userId?: IntFilter<"userrole"> | number
    roleId?: IntFilter<"userrole"> | number
  }

  export type UserLeaveUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLeaveWhereUniqueInput
    update: XOR<UserLeaveUpdateWithoutUserInput, UserLeaveUncheckedUpdateWithoutUserInput>
    create: XOR<UserLeaveCreateWithoutUserInput, UserLeaveUncheckedCreateWithoutUserInput>
  }

  export type UserLeaveUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLeaveWhereUniqueInput
    data: XOR<UserLeaveUpdateWithoutUserInput, UserLeaveUncheckedUpdateWithoutUserInput>
  }

  export type UserLeaveUpdateManyWithWhereWithoutUserInput = {
    where: UserLeaveScalarWhereInput
    data: XOR<UserLeaveUpdateManyMutationInput, UserLeaveUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLeaveScalarWhereInput = {
    AND?: UserLeaveScalarWhereInput | UserLeaveScalarWhereInput[]
    OR?: UserLeaveScalarWhereInput[]
    NOT?: UserLeaveScalarWhereInput | UserLeaveScalarWhereInput[]
    id?: IntFilter<"UserLeave"> | number
    userId?: IntFilter<"UserLeave"> | number
    leaveType?: EnumLeaveTypeFilter<"UserLeave"> | $Enums.LeaveType
    fromDate?: DateTimeFilter<"UserLeave"> | Date | string
    toDate?: DateTimeFilter<"UserLeave"> | Date | string
    duration?: EnumLeaveDurationFilter<"UserLeave"> | $Enums.LeaveDuration
    reason?: StringFilter<"UserLeave"> | string
    status?: EnumLeaveStatusFilter<"UserLeave"> | $Enums.LeaveStatus
    approvedById?: IntNullableFilter<"UserLeave"> | number | null
    created_at?: DateTimeFilter<"UserLeave"> | Date | string
    updated_at?: DateTimeFilter<"UserLeave"> | Date | string
  }

  export type UserLeaveUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: UserLeaveWhereUniqueInput
    update: XOR<UserLeaveUpdateWithoutApprovedByInput, UserLeaveUncheckedUpdateWithoutApprovedByInput>
    create: XOR<UserLeaveCreateWithoutApprovedByInput, UserLeaveUncheckedCreateWithoutApprovedByInput>
  }

  export type UserLeaveUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: UserLeaveWhereUniqueInput
    data: XOR<UserLeaveUpdateWithoutApprovedByInput, UserLeaveUncheckedUpdateWithoutApprovedByInput>
  }

  export type UserLeaveUpdateManyWithWhereWithoutApprovedByInput = {
    where: UserLeaveScalarWhereInput
    data: XOR<UserLeaveUpdateManyMutationInput, UserLeaveUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type messageUpsertWithWhereUniqueWithoutSenderInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutSenderInput, messageUncheckedUpdateWithoutSenderInput>
    create: XOR<messageCreateWithoutSenderInput, messageUncheckedCreateWithoutSenderInput>
  }

  export type messageUpdateWithWhereUniqueWithoutSenderInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutSenderInput, messageUncheckedUpdateWithoutSenderInput>
  }

  export type messageUpdateManyWithWhereWithoutSenderInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutSenderInput>
  }

  export type messageScalarWhereInput = {
    AND?: messageScalarWhereInput | messageScalarWhereInput[]
    OR?: messageScalarWhereInput[]
    NOT?: messageScalarWhereInput | messageScalarWhereInput[]
    id?: IntFilter<"message"> | number
    body?: StringFilter<"message"> | string
    senderId?: IntFilter<"message"> | number
    recipientId?: IntFilter<"message"> | number
    created_at?: DateTimeFilter<"message"> | Date | string
    read_at?: DateTimeNullableFilter<"message"> | Date | string | null
  }

  export type messageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutRecipientInput, messageUncheckedUpdateWithoutRecipientInput>
    create: XOR<messageCreateWithoutRecipientInput, messageUncheckedCreateWithoutRecipientInput>
  }

  export type messageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutRecipientInput, messageUncheckedUpdateWithoutRecipientInput>
  }

  export type messageUpdateManyWithWhereWithoutRecipientInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type userGroupsUpsertWithWhereUniqueWithoutUserInput = {
    where: userGroupsWhereUniqueInput
    update: XOR<userGroupsUpdateWithoutUserInput, userGroupsUncheckedUpdateWithoutUserInput>
    create: XOR<userGroupsCreateWithoutUserInput, userGroupsUncheckedCreateWithoutUserInput>
  }

  export type userGroupsUpdateWithWhereUniqueWithoutUserInput = {
    where: userGroupsWhereUniqueInput
    data: XOR<userGroupsUpdateWithoutUserInput, userGroupsUncheckedUpdateWithoutUserInput>
  }

  export type userGroupsUpdateManyWithWhereWithoutUserInput = {
    where: userGroupsScalarWhereInput
    data: XOR<userGroupsUpdateManyMutationInput, userGroupsUncheckedUpdateManyWithoutUserInput>
  }

  export type userGroupsScalarWhereInput = {
    AND?: userGroupsScalarWhereInput | userGroupsScalarWhereInput[]
    OR?: userGroupsScalarWhereInput[]
    NOT?: userGroupsScalarWhereInput | userGroupsScalarWhereInput[]
    userId?: IntFilter<"userGroups"> | number
    groupId?: IntFilter<"userGroups"> | number
    assignedAt?: DateTimeFilter<"userGroups"> | Date | string
  }

  export type groupMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: groupMessageWhereUniqueInput
    update: XOR<groupMessageUpdateWithoutSenderInput, groupMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<groupMessageCreateWithoutSenderInput, groupMessageUncheckedCreateWithoutSenderInput>
  }

  export type groupMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: groupMessageWhereUniqueInput
    data: XOR<groupMessageUpdateWithoutSenderInput, groupMessageUncheckedUpdateWithoutSenderInput>
  }

  export type groupMessageUpdateManyWithWhereWithoutSenderInput = {
    where: groupMessageScalarWhereInput
    data: XOR<groupMessageUpdateManyMutationInput, groupMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type groupMessageScalarWhereInput = {
    AND?: groupMessageScalarWhereInput | groupMessageScalarWhereInput[]
    OR?: groupMessageScalarWhereInput[]
    NOT?: groupMessageScalarWhereInput | groupMessageScalarWhereInput[]
    id?: IntFilter<"groupMessage"> | number
    groupId?: IntFilter<"groupMessage"> | number
    body?: StringFilter<"groupMessage"> | string
    senderId?: IntFilter<"groupMessage"> | number
    created_at?: DateTimeFilter<"groupMessage"> | Date | string
    read_at?: DateTimeNullableFilter<"groupMessage"> | Date | string | null
  }

  export type UserTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTaskWhereUniqueInput
    update: XOR<UserTaskUpdateWithoutUserInput, UserTaskUncheckedUpdateWithoutUserInput>
    create: XOR<UserTaskCreateWithoutUserInput, UserTaskUncheckedCreateWithoutUserInput>
  }

  export type UserTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTaskWhereUniqueInput
    data: XOR<UserTaskUpdateWithoutUserInput, UserTaskUncheckedUpdateWithoutUserInput>
  }

  export type UserTaskUpdateManyWithWhereWithoutUserInput = {
    where: UserTaskScalarWhereInput
    data: XOR<UserTaskUpdateManyMutationInput, UserTaskUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTaskScalarWhereInput = {
    AND?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
    OR?: UserTaskScalarWhereInput[]
    NOT?: UserTaskScalarWhereInput | UserTaskScalarWhereInput[]
    id?: IntFilter<"UserTask"> | number
    userId?: IntFilter<"UserTask"> | number
    taskId?: IntFilter<"UserTask"> | number
    totalTime?: IntFilter<"UserTask"> | number
    assignedById?: IntFilter<"UserTask"> | number
  }

  export type UserBreakUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBreakWhereUniqueInput
    update: XOR<UserBreakUpdateWithoutUserInput, UserBreakUncheckedUpdateWithoutUserInput>
    create: XOR<UserBreakCreateWithoutUserInput, UserBreakUncheckedCreateWithoutUserInput>
  }

  export type UserBreakUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBreakWhereUniqueInput
    data: XOR<UserBreakUpdateWithoutUserInput, UserBreakUncheckedUpdateWithoutUserInput>
  }

  export type UserBreakUpdateManyWithWhereWithoutUserInput = {
    where: UserBreakScalarWhereInput
    data: XOR<UserBreakUpdateManyMutationInput, UserBreakUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBreakScalarWhereInput = {
    AND?: UserBreakScalarWhereInput | UserBreakScalarWhereInput[]
    OR?: UserBreakScalarWhereInput[]
    NOT?: UserBreakScalarWhereInput | UserBreakScalarWhereInput[]
    id?: IntFilter<"UserBreak"> | number
    userId?: IntFilter<"UserBreak"> | number
    breakId?: IntFilter<"UserBreak"> | number
    totalTime?: IntFilter<"UserBreak"> | number
  }

  export type UserTaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: UserTaskWhereUniqueInput
    update: XOR<UserTaskUpdateWithoutAssigneeInput, UserTaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<UserTaskCreateWithoutAssigneeInput, UserTaskUncheckedCreateWithoutAssigneeInput>
  }

  export type UserTaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: UserTaskWhereUniqueInput
    data: XOR<UserTaskUpdateWithoutAssigneeInput, UserTaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type UserTaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: UserTaskScalarWhereInput
    data: XOR<UserTaskUpdateManyMutationInput, UserTaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    type?: EnumSessionTypeFilter<"Session"> | $Enums.SessionType
    startTime?: DateTimeFilter<"Session"> | Date | string
    latestLogged?: DateTimeFilter<"Session"> | Date | string
    endTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    userId?: IntFilter<"Session"> | number
    taskId?: IntNullableFilter<"Session"> | number | null
    breakId?: IntNullableFilter<"Session"> | number | null
  }

  export type campaignDeliveriesUpsertWithWhereUniqueWithoutUploaderInput = {
    where: campaignDeliveriesWhereUniqueInput
    update: XOR<campaignDeliveriesUpdateWithoutUploaderInput, campaignDeliveriesUncheckedUpdateWithoutUploaderInput>
    create: XOR<campaignDeliveriesCreateWithoutUploaderInput, campaignDeliveriesUncheckedCreateWithoutUploaderInput>
  }

  export type campaignDeliveriesUpdateWithWhereUniqueWithoutUploaderInput = {
    where: campaignDeliveriesWhereUniqueInput
    data: XOR<campaignDeliveriesUpdateWithoutUploaderInput, campaignDeliveriesUncheckedUpdateWithoutUploaderInput>
  }

  export type campaignDeliveriesUpdateManyWithWhereWithoutUploaderInput = {
    where: campaignDeliveriesScalarWhereInput
    data: XOR<campaignDeliveriesUpdateManyMutationInput, campaignDeliveriesUncheckedUpdateManyWithoutUploaderInput>
  }

  export type campaignDeliveriesScalarWhereInput = {
    AND?: campaignDeliveriesScalarWhereInput | campaignDeliveriesScalarWhereInput[]
    OR?: campaignDeliveriesScalarWhereInput[]
    NOT?: campaignDeliveriesScalarWhereInput | campaignDeliveriesScalarWhereInput[]
    id?: IntFilter<"campaignDeliveries"> | number
    campaignId?: IntFilter<"campaignDeliveries"> | number
    date?: DateTimeFilter<"campaignDeliveries"> | Date | string
    fileName?: StringFilter<"campaignDeliveries"> | string
    submitted?: IntFilter<"campaignDeliveries"> | number
    accepted?: IntFilter<"campaignDeliveries"> | number
    errors?: IntFilter<"campaignDeliveries"> | number
    rejections?: IntFilter<"campaignDeliveries"> | number
    uploaderId?: IntNullableFilter<"campaignDeliveries"> | number | null
    data?: StringFilter<"campaignDeliveries"> | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: IntFilter<"Attendance"> | number
    userId?: IntFilter<"Attendance"> | number
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeFilter<"Attendance"> | Date | string
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type userCreateWithoutAttendanceInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
  }

  export type userUncheckedCreateWithoutAttendanceInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type userCreateOrConnectWithoutAttendanceInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
  }

  export type userUpsertWithoutAttendanceInput = {
    update: XOR<userUpdateWithoutAttendanceInput, userUncheckedUpdateWithoutAttendanceInput>
    create: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAttendanceInput, userUncheckedUpdateWithoutAttendanceInput>
  }

  export type userUpdateWithoutAttendanceInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
  }

  export type userUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type userCreateWithoutLeavesInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutLeavesInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutLeavesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutLeavesInput, userUncheckedCreateWithoutLeavesInput>
  }

  export type userCreateWithoutApprovedLeavesInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutApprovedLeavesInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutApprovedLeavesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutApprovedLeavesInput, userUncheckedCreateWithoutApprovedLeavesInput>
  }

  export type userUpsertWithoutLeavesInput = {
    update: XOR<userUpdateWithoutLeavesInput, userUncheckedUpdateWithoutLeavesInput>
    create: XOR<userCreateWithoutLeavesInput, userUncheckedCreateWithoutLeavesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutLeavesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutLeavesInput, userUncheckedUpdateWithoutLeavesInput>
  }

  export type userUpdateWithoutLeavesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutApprovedLeavesInput = {
    update: XOR<userUpdateWithoutApprovedLeavesInput, userUncheckedUpdateWithoutApprovedLeavesInput>
    create: XOR<userCreateWithoutApprovedLeavesInput, userUncheckedCreateWithoutApprovedLeavesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutApprovedLeavesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutApprovedLeavesInput, userUncheckedUpdateWithoutApprovedLeavesInput>
  }

  export type userUpdateWithoutApprovedLeavesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutApprovedLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutSessionsInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSessionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
  }

  export type UserTaskCreateWithoutSessionsInput = {
    totalTime: number
    user: userCreateNestedOneWithoutTasksInput
    task: TaskCreateNestedOneWithoutUsersInput
    assignee: userCreateNestedOneWithoutAssignedTasksInput
  }

  export type UserTaskUncheckedCreateWithoutSessionsInput = {
    id?: number
    userId: number
    taskId: number
    totalTime: number
    assignedById: number
  }

  export type UserTaskCreateOrConnectWithoutSessionsInput = {
    where: UserTaskWhereUniqueInput
    create: XOR<UserTaskCreateWithoutSessionsInput, UserTaskUncheckedCreateWithoutSessionsInput>
  }

  export type UserBreakCreateWithoutSessionsInput = {
    totalTime: number
    user: userCreateNestedOneWithoutBreaksInput
    break: BreakCreateNestedOneWithoutUsersInput
  }

  export type UserBreakUncheckedCreateWithoutSessionsInput = {
    id?: number
    userId: number
    breakId: number
    totalTime: number
  }

  export type UserBreakCreateOrConnectWithoutSessionsInput = {
    where: UserBreakWhereUniqueInput
    create: XOR<UserBreakCreateWithoutSessionsInput, UserBreakUncheckedCreateWithoutSessionsInput>
  }

  export type userUpsertWithoutSessionsInput = {
    update: XOR<userUpdateWithoutSessionsInput, userUncheckedUpdateWithoutSessionsInput>
    create: XOR<userCreateWithoutSessionsInput, userUncheckedCreateWithoutSessionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSessionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSessionsInput, userUncheckedUpdateWithoutSessionsInput>
  }

  export type userUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserTaskUpsertWithoutSessionsInput = {
    update: XOR<UserTaskUpdateWithoutSessionsInput, UserTaskUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserTaskCreateWithoutSessionsInput, UserTaskUncheckedCreateWithoutSessionsInput>
    where?: UserTaskWhereInput
  }

  export type UserTaskUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserTaskWhereInput
    data: XOR<UserTaskUpdateWithoutSessionsInput, UserTaskUncheckedUpdateWithoutSessionsInput>
  }

  export type UserTaskUpdateWithoutSessionsInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutTasksNestedInput
    task?: TaskUpdateOneRequiredWithoutUsersNestedInput
    assignee?: userUpdateOneRequiredWithoutAssignedTasksNestedInput
  }

  export type UserTaskUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakUpsertWithoutSessionsInput = {
    update: XOR<UserBreakUpdateWithoutSessionsInput, UserBreakUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserBreakCreateWithoutSessionsInput, UserBreakUncheckedCreateWithoutSessionsInput>
    where?: UserBreakWhereInput
  }

  export type UserBreakUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserBreakWhereInput
    data: XOR<UserBreakUpdateWithoutSessionsInput, UserBreakUncheckedUpdateWithoutSessionsInput>
  }

  export type UserBreakUpdateWithoutSessionsInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutBreaksNestedInput
    break?: BreakUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBreakUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    breakId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateWithoutTasksInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTasksInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTasksInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTasksInput, userUncheckedCreateWithoutTasksInput>
  }

  export type TaskCreateWithoutUsersInput = {
    name: string
    type: $Enums.TaskType
    typeId?: number | null
    status: string
    level: $Enums.TaskLevel
    remark: string
    reassigned?: boolean
  }

  export type TaskUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    type: $Enums.TaskType
    typeId?: number | null
    status: string
    level: $Enums.TaskLevel
    remark: string
    reassigned?: boolean
  }

  export type TaskCreateOrConnectWithoutUsersInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUsersInput, TaskUncheckedCreateWithoutUsersInput>
  }

  export type SessionCreateWithoutTaskInput = {
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    user: userCreateNestedOneWithoutSessionsInput
    break?: UserBreakCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutTaskInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    userId: number
    breakId?: number | null
  }

  export type SessionCreateOrConnectWithoutTaskInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutTaskInput, SessionUncheckedCreateWithoutTaskInput>
  }

  export type SessionCreateManyTaskInputEnvelope = {
    data: SessionCreateManyTaskInput | SessionCreateManyTaskInput[]
  }

  export type userCreateWithoutAssignedTasksInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAssignedTasksInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAssignedTasksInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAssignedTasksInput, userUncheckedCreateWithoutAssignedTasksInput>
  }

  export type userUpsertWithoutTasksInput = {
    update: XOR<userUpdateWithoutTasksInput, userUncheckedUpdateWithoutTasksInput>
    create: XOR<userCreateWithoutTasksInput, userUncheckedCreateWithoutTasksInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTasksInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTasksInput, userUncheckedUpdateWithoutTasksInput>
  }

  export type userUpdateWithoutTasksInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithoutUsersInput = {
    update: XOR<TaskUpdateWithoutUsersInput, TaskUncheckedUpdateWithoutUsersInput>
    create: XOR<TaskCreateWithoutUsersInput, TaskUncheckedCreateWithoutUsersInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutUsersInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutUsersInput, TaskUncheckedUpdateWithoutUsersInput>
  }

  export type TaskUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    level?: EnumTaskLevelFieldUpdateOperationsInput | $Enums.TaskLevel
    remark?: StringFieldUpdateOperationsInput | string
    reassigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    level?: EnumTaskLevelFieldUpdateOperationsInput | $Enums.TaskLevel
    remark?: StringFieldUpdateOperationsInput | string
    reassigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutTaskInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutTaskInput, SessionUncheckedUpdateWithoutTaskInput>
    create: XOR<SessionCreateWithoutTaskInput, SessionUncheckedCreateWithoutTaskInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutTaskInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutTaskInput, SessionUncheckedUpdateWithoutTaskInput>
  }

  export type SessionUpdateManyWithWhereWithoutTaskInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutTaskInput>
  }

  export type userUpsertWithoutAssignedTasksInput = {
    update: XOR<userUpdateWithoutAssignedTasksInput, userUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<userCreateWithoutAssignedTasksInput, userUncheckedCreateWithoutAssignedTasksInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAssignedTasksInput, userUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type userUpdateWithoutAssignedTasksInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAssignedTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutBreaksInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBreaksInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBreaksInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBreaksInput, userUncheckedCreateWithoutBreaksInput>
  }

  export type BreakCreateWithoutUsersInput = {
    name: string
  }

  export type BreakUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type BreakCreateOrConnectWithoutUsersInput = {
    where: BreakWhereUniqueInput
    create: XOR<BreakCreateWithoutUsersInput, BreakUncheckedCreateWithoutUsersInput>
  }

  export type SessionCreateWithoutBreakInput = {
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    user: userCreateNestedOneWithoutSessionsInput
    task?: UserTaskCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutBreakInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    userId: number
    taskId?: number | null
  }

  export type SessionCreateOrConnectWithoutBreakInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutBreakInput, SessionUncheckedCreateWithoutBreakInput>
  }

  export type SessionCreateManyBreakInputEnvelope = {
    data: SessionCreateManyBreakInput | SessionCreateManyBreakInput[]
  }

  export type userUpsertWithoutBreaksInput = {
    update: XOR<userUpdateWithoutBreaksInput, userUncheckedUpdateWithoutBreaksInput>
    create: XOR<userCreateWithoutBreaksInput, userUncheckedCreateWithoutBreaksInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBreaksInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBreaksInput, userUncheckedUpdateWithoutBreaksInput>
  }

  export type userUpdateWithoutBreaksInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBreaksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BreakUpsertWithoutUsersInput = {
    update: XOR<BreakUpdateWithoutUsersInput, BreakUncheckedUpdateWithoutUsersInput>
    create: XOR<BreakCreateWithoutUsersInput, BreakUncheckedCreateWithoutUsersInput>
    where?: BreakWhereInput
  }

  export type BreakUpdateToOneWithWhereWithoutUsersInput = {
    where?: BreakWhereInput
    data: XOR<BreakUpdateWithoutUsersInput, BreakUncheckedUpdateWithoutUsersInput>
  }

  export type BreakUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BreakUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUpsertWithWhereUniqueWithoutBreakInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutBreakInput, SessionUncheckedUpdateWithoutBreakInput>
    create: XOR<SessionCreateWithoutBreakInput, SessionUncheckedCreateWithoutBreakInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutBreakInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutBreakInput, SessionUncheckedUpdateWithoutBreakInput>
  }

  export type SessionUpdateManyWithWhereWithoutBreakInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutBreakInput>
  }

  export type UserTaskCreateWithoutTaskInput = {
    totalTime: number
    user: userCreateNestedOneWithoutTasksInput
    sessions?: SessionCreateNestedManyWithoutTaskInput
    assignee: userCreateNestedOneWithoutAssignedTasksInput
  }

  export type UserTaskUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: number
    totalTime: number
    assignedById: number
    sessions?: SessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type UserTaskCreateOrConnectWithoutTaskInput = {
    where: UserTaskWhereUniqueInput
    create: XOR<UserTaskCreateWithoutTaskInput, UserTaskUncheckedCreateWithoutTaskInput>
  }

  export type UserTaskCreateManyTaskInputEnvelope = {
    data: UserTaskCreateManyTaskInput | UserTaskCreateManyTaskInput[]
  }

  export type UserTaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: UserTaskWhereUniqueInput
    update: XOR<UserTaskUpdateWithoutTaskInput, UserTaskUncheckedUpdateWithoutTaskInput>
    create: XOR<UserTaskCreateWithoutTaskInput, UserTaskUncheckedCreateWithoutTaskInput>
  }

  export type UserTaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: UserTaskWhereUniqueInput
    data: XOR<UserTaskUpdateWithoutTaskInput, UserTaskUncheckedUpdateWithoutTaskInput>
  }

  export type UserTaskUpdateManyWithWhereWithoutTaskInput = {
    where: UserTaskScalarWhereInput
    data: XOR<UserTaskUpdateManyMutationInput, UserTaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserBreakCreateWithoutBreakInput = {
    totalTime: number
    user: userCreateNestedOneWithoutBreaksInput
    sessions?: SessionCreateNestedManyWithoutBreakInput
  }

  export type UserBreakUncheckedCreateWithoutBreakInput = {
    id?: number
    userId: number
    totalTime: number
    sessions?: SessionUncheckedCreateNestedManyWithoutBreakInput
  }

  export type UserBreakCreateOrConnectWithoutBreakInput = {
    where: UserBreakWhereUniqueInput
    create: XOR<UserBreakCreateWithoutBreakInput, UserBreakUncheckedCreateWithoutBreakInput>
  }

  export type UserBreakCreateManyBreakInputEnvelope = {
    data: UserBreakCreateManyBreakInput | UserBreakCreateManyBreakInput[]
  }

  export type UserBreakUpsertWithWhereUniqueWithoutBreakInput = {
    where: UserBreakWhereUniqueInput
    update: XOR<UserBreakUpdateWithoutBreakInput, UserBreakUncheckedUpdateWithoutBreakInput>
    create: XOR<UserBreakCreateWithoutBreakInput, UserBreakUncheckedCreateWithoutBreakInput>
  }

  export type UserBreakUpdateWithWhereUniqueWithoutBreakInput = {
    where: UserBreakWhereUniqueInput
    data: XOR<UserBreakUpdateWithoutBreakInput, UserBreakUncheckedUpdateWithoutBreakInput>
  }

  export type UserBreakUpdateManyWithWhereWithoutBreakInput = {
    where: UserBreakScalarWhereInput
    data: XOR<UserBreakUpdateManyMutationInput, UserBreakUncheckedUpdateManyWithoutBreakInput>
  }

  export type userCreateWithoutSentMessagesInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSentMessagesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSentMessagesInput, userUncheckedCreateWithoutSentMessagesInput>
  }

  export type userCreateWithoutReceivedMessagesInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReceivedMessagesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReceivedMessagesInput, userUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type userUpsertWithoutSentMessagesInput = {
    update: XOR<userUpdateWithoutSentMessagesInput, userUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<userCreateWithoutSentMessagesInput, userUncheckedCreateWithoutSentMessagesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSentMessagesInput, userUncheckedUpdateWithoutSentMessagesInput>
  }

  export type userUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutReceivedMessagesInput = {
    update: XOR<userUpdateWithoutReceivedMessagesInput, userUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<userCreateWithoutReceivedMessagesInput, userUncheckedCreateWithoutReceivedMessagesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReceivedMessagesInput, userUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type userUpdateWithoutReceivedMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type groupCreateWithoutGroupMessagesInput = {
    name: string
    members?: userGroupsCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateWithoutGroupMessagesInput = {
    id?: number
    name: string
    members?: userGroupsUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupCreateOrConnectWithoutGroupMessagesInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutGroupMessagesInput, groupUncheckedCreateWithoutGroupMessagesInput>
  }

  export type userCreateWithoutSentMessageInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSentMessageInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSentMessageInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSentMessageInput, userUncheckedCreateWithoutSentMessageInput>
  }

  export type groupUpsertWithoutGroupMessagesInput = {
    update: XOR<groupUpdateWithoutGroupMessagesInput, groupUncheckedUpdateWithoutGroupMessagesInput>
    create: XOR<groupCreateWithoutGroupMessagesInput, groupUncheckedCreateWithoutGroupMessagesInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutGroupMessagesInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutGroupMessagesInput, groupUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type groupUpdateWithoutGroupMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    members?: userGroupsUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateWithoutGroupMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    members?: userGroupsUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type userUpsertWithoutSentMessageInput = {
    update: XOR<userUpdateWithoutSentMessageInput, userUncheckedUpdateWithoutSentMessageInput>
    create: XOR<userCreateWithoutSentMessageInput, userUncheckedCreateWithoutSentMessageInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSentMessageInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSentMessageInput, userUncheckedUpdateWithoutSentMessageInput>
  }

  export type userUpdateWithoutSentMessageInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSentMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userGroupsCreateWithoutGroupInput = {
    assignedAt?: Date | string
    user: userCreateNestedOneWithoutGroupsInput
  }

  export type userGroupsUncheckedCreateWithoutGroupInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type userGroupsCreateOrConnectWithoutGroupInput = {
    where: userGroupsWhereUniqueInput
    create: XOR<userGroupsCreateWithoutGroupInput, userGroupsUncheckedCreateWithoutGroupInput>
  }

  export type userGroupsCreateManyGroupInputEnvelope = {
    data: userGroupsCreateManyGroupInput | userGroupsCreateManyGroupInput[]
  }

  export type groupMessageCreateWithoutGroupInput = {
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
    sender: userCreateNestedOneWithoutSentMessageInput
  }

  export type groupMessageUncheckedCreateWithoutGroupInput = {
    id?: number
    body: string
    senderId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type groupMessageCreateOrConnectWithoutGroupInput = {
    where: groupMessageWhereUniqueInput
    create: XOR<groupMessageCreateWithoutGroupInput, groupMessageUncheckedCreateWithoutGroupInput>
  }

  export type groupMessageCreateManyGroupInputEnvelope = {
    data: groupMessageCreateManyGroupInput | groupMessageCreateManyGroupInput[]
  }

  export type userGroupsUpsertWithWhereUniqueWithoutGroupInput = {
    where: userGroupsWhereUniqueInput
    update: XOR<userGroupsUpdateWithoutGroupInput, userGroupsUncheckedUpdateWithoutGroupInput>
    create: XOR<userGroupsCreateWithoutGroupInput, userGroupsUncheckedCreateWithoutGroupInput>
  }

  export type userGroupsUpdateWithWhereUniqueWithoutGroupInput = {
    where: userGroupsWhereUniqueInput
    data: XOR<userGroupsUpdateWithoutGroupInput, userGroupsUncheckedUpdateWithoutGroupInput>
  }

  export type userGroupsUpdateManyWithWhereWithoutGroupInput = {
    where: userGroupsScalarWhereInput
    data: XOR<userGroupsUpdateManyMutationInput, userGroupsUncheckedUpdateManyWithoutGroupInput>
  }

  export type groupMessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: groupMessageWhereUniqueInput
    update: XOR<groupMessageUpdateWithoutGroupInput, groupMessageUncheckedUpdateWithoutGroupInput>
    create: XOR<groupMessageCreateWithoutGroupInput, groupMessageUncheckedCreateWithoutGroupInput>
  }

  export type groupMessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: groupMessageWhereUniqueInput
    data: XOR<groupMessageUpdateWithoutGroupInput, groupMessageUncheckedUpdateWithoutGroupInput>
  }

  export type groupMessageUpdateManyWithWhereWithoutGroupInput = {
    where: groupMessageScalarWhereInput
    data: XOR<groupMessageUpdateManyMutationInput, groupMessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type userCreateWithoutGroupsInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutGroupsInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutGroupsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGroupsInput, userUncheckedCreateWithoutGroupsInput>
  }

  export type groupCreateWithoutMembersInput = {
    name: string
    groupMessages?: groupMessageCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    groupMessages?: groupMessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupCreateOrConnectWithoutMembersInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutMembersInput, groupUncheckedCreateWithoutMembersInput>
  }

  export type userUpsertWithoutGroupsInput = {
    update: XOR<userUpdateWithoutGroupsInput, userUncheckedUpdateWithoutGroupsInput>
    create: XOR<userCreateWithoutGroupsInput, userUncheckedCreateWithoutGroupsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGroupsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGroupsInput, userUncheckedUpdateWithoutGroupsInput>
  }

  export type userUpdateWithoutGroupsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type groupUpsertWithoutMembersInput = {
    update: XOR<groupUpdateWithoutMembersInput, groupUncheckedUpdateWithoutMembersInput>
    create: XOR<groupCreateWithoutMembersInput, groupUncheckedCreateWithoutMembersInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutMembersInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutMembersInput, groupUncheckedUpdateWithoutMembersInput>
  }

  export type groupUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    groupMessages?: groupMessageUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    groupMessages?: groupMessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type notificationPriorityCreateWithoutNotificationsInput = {
    level: number
  }

  export type notificationPriorityUncheckedCreateWithoutNotificationsInput = {
    id?: number
    level: number
  }

  export type notificationPriorityCreateOrConnectWithoutNotificationsInput = {
    where: notificationPriorityWhereUniqueInput
    create: XOR<notificationPriorityCreateWithoutNotificationsInput, notificationPriorityUncheckedCreateWithoutNotificationsInput>
  }

  export type roleNotificationCreateWithoutNotificationInput = {
    role: roleCreateNestedOneWithoutRoleNotificationsInput
  }

  export type roleNotificationUncheckedCreateWithoutNotificationInput = {
    roleId: number
  }

  export type roleNotificationCreateOrConnectWithoutNotificationInput = {
    where: roleNotificationWhereUniqueInput
    create: XOR<roleNotificationCreateWithoutNotificationInput, roleNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type roleNotificationCreateManyNotificationInputEnvelope = {
    data: roleNotificationCreateManyNotificationInput | roleNotificationCreateManyNotificationInput[]
  }

  export type notificationPriorityUpsertWithoutNotificationsInput = {
    update: XOR<notificationPriorityUpdateWithoutNotificationsInput, notificationPriorityUncheckedUpdateWithoutNotificationsInput>
    create: XOR<notificationPriorityCreateWithoutNotificationsInput, notificationPriorityUncheckedCreateWithoutNotificationsInput>
    where?: notificationPriorityWhereInput
  }

  export type notificationPriorityUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: notificationPriorityWhereInput
    data: XOR<notificationPriorityUpdateWithoutNotificationsInput, notificationPriorityUncheckedUpdateWithoutNotificationsInput>
  }

  export type notificationPriorityUpdateWithoutNotificationsInput = {
    level?: IntFieldUpdateOperationsInput | number
  }

  export type notificationPriorityUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type roleNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: roleNotificationWhereUniqueInput
    update: XOR<roleNotificationUpdateWithoutNotificationInput, roleNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<roleNotificationCreateWithoutNotificationInput, roleNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type roleNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: roleNotificationWhereUniqueInput
    data: XOR<roleNotificationUpdateWithoutNotificationInput, roleNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type roleNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: roleNotificationScalarWhereInput
    data: XOR<roleNotificationUpdateManyMutationInput, roleNotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type roleNotificationScalarWhereInput = {
    AND?: roleNotificationScalarWhereInput | roleNotificationScalarWhereInput[]
    OR?: roleNotificationScalarWhereInput[]
    NOT?: roleNotificationScalarWhereInput | roleNotificationScalarWhereInput[]
    roleId?: IntFilter<"roleNotification"> | number
    notificationId?: IntFilter<"roleNotification"> | number
  }

  export type notificationCreateWithoutNotificationPriorityInput = {
    message: string
    createdAt?: Date | string
    url: string
    type: string
    roleNotifications?: roleNotificationCreateNestedManyWithoutNotificationInput
  }

  export type notificationUncheckedCreateWithoutNotificationPriorityInput = {
    id?: number
    message: string
    createdAt?: Date | string
    url: string
    type: string
    roleNotifications?: roleNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type notificationCreateOrConnectWithoutNotificationPriorityInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutNotificationPriorityInput, notificationUncheckedCreateWithoutNotificationPriorityInput>
  }

  export type notificationCreateManyNotificationPriorityInputEnvelope = {
    data: notificationCreateManyNotificationPriorityInput | notificationCreateManyNotificationPriorityInput[]
  }

  export type notificationUpsertWithWhereUniqueWithoutNotificationPriorityInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutNotificationPriorityInput, notificationUncheckedUpdateWithoutNotificationPriorityInput>
    create: XOR<notificationCreateWithoutNotificationPriorityInput, notificationUncheckedCreateWithoutNotificationPriorityInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutNotificationPriorityInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutNotificationPriorityInput, notificationUncheckedUpdateWithoutNotificationPriorityInput>
  }

  export type notificationUpdateManyWithWhereWithoutNotificationPriorityInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutNotificationPriorityInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: IntFilter<"notification"> | number
    message?: StringFilter<"notification"> | string
    notificationPriorityId?: IntFilter<"notification"> | number
    createdAt?: DateTimeFilter<"notification"> | Date | string
    url?: StringFilter<"notification"> | string
    type?: StringFilter<"notification"> | string
  }

  export type userroleCreateWithoutRoleInput = {
    user: userCreateNestedOneWithoutRolesInput
  }

  export type userroleUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
  }

  export type userroleCreateOrConnectWithoutRoleInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleCreateManyRoleInputEnvelope = {
    data: userroleCreateManyRoleInput | userroleCreateManyRoleInput[]
  }

  export type roleNotificationCreateWithoutRoleInput = {
    notification: notificationCreateNestedOneWithoutRoleNotificationsInput
  }

  export type roleNotificationUncheckedCreateWithoutRoleInput = {
    notificationId: number
  }

  export type roleNotificationCreateOrConnectWithoutRoleInput = {
    where: roleNotificationWhereUniqueInput
    create: XOR<roleNotificationCreateWithoutRoleInput, roleNotificationUncheckedCreateWithoutRoleInput>
  }

  export type roleNotificationCreateManyRoleInputEnvelope = {
    data: roleNotificationCreateManyRoleInput | roleNotificationCreateManyRoleInput[]
  }

  export type userroleUpsertWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
  }

  export type userroleUpdateManyWithWhereWithoutRoleInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutRoleInput>
  }

  export type roleNotificationUpsertWithWhereUniqueWithoutRoleInput = {
    where: roleNotificationWhereUniqueInput
    update: XOR<roleNotificationUpdateWithoutRoleInput, roleNotificationUncheckedUpdateWithoutRoleInput>
    create: XOR<roleNotificationCreateWithoutRoleInput, roleNotificationUncheckedCreateWithoutRoleInput>
  }

  export type roleNotificationUpdateWithWhereUniqueWithoutRoleInput = {
    where: roleNotificationWhereUniqueInput
    data: XOR<roleNotificationUpdateWithoutRoleInput, roleNotificationUncheckedUpdateWithoutRoleInput>
  }

  export type roleNotificationUpdateManyWithWhereWithoutRoleInput = {
    where: roleNotificationScalarWhereInput
    data: XOR<roleNotificationUpdateManyMutationInput, roleNotificationUncheckedUpdateManyWithoutRoleInput>
  }

  export type roleCreateWithoutRoleNotificationsInput = {
    name?: string
    users?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutRoleNotificationsInput = {
    id?: number
    name?: string
    users?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutRoleNotificationsInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutRoleNotificationsInput, roleUncheckedCreateWithoutRoleNotificationsInput>
  }

  export type notificationCreateWithoutRoleNotificationsInput = {
    message: string
    createdAt?: Date | string
    url: string
    type: string
    notificationPriority: notificationPriorityCreateNestedOneWithoutNotificationsInput
  }

  export type notificationUncheckedCreateWithoutRoleNotificationsInput = {
    id?: number
    message: string
    notificationPriorityId: number
    createdAt?: Date | string
    url: string
    type: string
  }

  export type notificationCreateOrConnectWithoutRoleNotificationsInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutRoleNotificationsInput, notificationUncheckedCreateWithoutRoleNotificationsInput>
  }

  export type roleUpsertWithoutRoleNotificationsInput = {
    update: XOR<roleUpdateWithoutRoleNotificationsInput, roleUncheckedUpdateWithoutRoleNotificationsInput>
    create: XOR<roleCreateWithoutRoleNotificationsInput, roleUncheckedCreateWithoutRoleNotificationsInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutRoleNotificationsInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutRoleNotificationsInput, roleUncheckedUpdateWithoutRoleNotificationsInput>
  }

  export type roleUpdateWithoutRoleNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutRoleNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type notificationUpsertWithoutRoleNotificationsInput = {
    update: XOR<notificationUpdateWithoutRoleNotificationsInput, notificationUncheckedUpdateWithoutRoleNotificationsInput>
    create: XOR<notificationCreateWithoutRoleNotificationsInput, notificationUncheckedCreateWithoutRoleNotificationsInput>
    where?: notificationWhereInput
  }

  export type notificationUpdateToOneWithWhereWithoutRoleNotificationsInput = {
    where?: notificationWhereInput
    data: XOR<notificationUpdateWithoutRoleNotificationsInput, notificationUncheckedUpdateWithoutRoleNotificationsInput>
  }

  export type notificationUpdateWithoutRoleNotificationsInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    notificationPriority?: notificationPriorityUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationUncheckedUpdateWithoutRoleNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    notificationPriorityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type roleCreateWithoutUsersInput = {
    name?: string
    roleNotifications?: roleNotificationCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutUsersInput = {
    id?: number
    name?: string
    roleNotifications?: roleNotificationUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutUsersInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
  }

  export type userCreateWithoutRolesInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRolesInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRolesInput, userUncheckedCreateWithoutRolesInput>
  }

  export type roleUpsertWithoutUsersInput = {
    update: XOR<roleUpdateWithoutUsersInput, roleUncheckedUpdateWithoutUsersInput>
    create: XOR<roleCreateWithoutUsersInput, roleUncheckedCreateWithoutUsersInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUsersInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUsersInput, roleUncheckedUpdateWithoutUsersInput>
  }

  export type roleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleNotifications?: roleNotificationUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleNotifications?: roleNotificationUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type userUpsertWithoutRolesInput = {
    update: XOR<userUpdateWithoutRolesInput, userUncheckedUpdateWithoutRolesInput>
    create: XOR<userCreateWithoutRolesInput, userUncheckedCreateWithoutRolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRolesInput, userUncheckedUpdateWithoutRolesInput>
  }

  export type userUpdateWithoutRolesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type campaignCreateWithoutClientInput = {
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    volumes?: volumeCreateNestedManyWithoutCampaignInput
    leads?: leadCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesCreateNestedManyWithoutCampaignInput
  }

  export type campaignUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    volumes?: volumeUncheckedCreateNestedManyWithoutCampaignInput
    leads?: leadUncheckedCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type campaignCreateOrConnectWithoutClientInput = {
    where: campaignWhereUniqueInput
    create: XOR<campaignCreateWithoutClientInput, campaignUncheckedCreateWithoutClientInput>
  }

  export type campaignCreateManyClientInputEnvelope = {
    data: campaignCreateManyClientInput | campaignCreateManyClientInput[]
  }

  export type campaignUpsertWithWhereUniqueWithoutClientInput = {
    where: campaignWhereUniqueInput
    update: XOR<campaignUpdateWithoutClientInput, campaignUncheckedUpdateWithoutClientInput>
    create: XOR<campaignCreateWithoutClientInput, campaignUncheckedCreateWithoutClientInput>
  }

  export type campaignUpdateWithWhereUniqueWithoutClientInput = {
    where: campaignWhereUniqueInput
    data: XOR<campaignUpdateWithoutClientInput, campaignUncheckedUpdateWithoutClientInput>
  }

  export type campaignUpdateManyWithWhereWithoutClientInput = {
    where: campaignScalarWhereInput
    data: XOR<campaignUpdateManyMutationInput, campaignUncheckedUpdateManyWithoutClientInput>
  }

  export type campaignScalarWhereInput = {
    AND?: campaignScalarWhereInput | campaignScalarWhereInput[]
    OR?: campaignScalarWhereInput[]
    NOT?: campaignScalarWhereInput | campaignScalarWhereInput[]
    id?: IntFilter<"campaign"> | number
    name?: StringFilter<"campaign"> | string
    code?: StringFilter<"campaign"> | string
    clientId?: IntFilter<"campaign"> | number
    leadgoal?: IntFilter<"campaign"> | number
    completed?: IntFilter<"campaign"> | number
    pending?: IntFilter<"campaign"> | number
    duedate?: DateTimeFilter<"campaign"> | Date | string
    info?: JsonFilter<"campaign">
    content?: JsonFilter<"campaign">
    filesInfo?: JsonFilter<"campaign">
    updates?: JsonFilter<"campaign">
    created_at?: DateTimeFilter<"campaign"> | Date | string
    updated_at?: DateTimeFilter<"campaign"> | Date | string
    status?: StringFilter<"campaign"> | string
  }

  export type clientCreateWithoutCampaignsInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type clientUncheckedCreateWithoutCampaignsInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type clientCreateOrConnectWithoutCampaignsInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutCampaignsInput, clientUncheckedCreateWithoutCampaignsInput>
  }

  export type volumeCreateWithoutCampaignInput = {
    name: string
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    pacings?: pacingCreateNestedManyWithoutVolumeInput
    leads?: leadCreateNestedManyWithoutVolumeInput
  }

  export type volumeUncheckedCreateWithoutCampaignInput = {
    id?: number
    name: string
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    pacings?: pacingUncheckedCreateNestedManyWithoutVolumeInput
    leads?: leadUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type volumeCreateOrConnectWithoutCampaignInput = {
    where: volumeWhereUniqueInput
    create: XOR<volumeCreateWithoutCampaignInput, volumeUncheckedCreateWithoutCampaignInput>
  }

  export type volumeCreateManyCampaignInputEnvelope = {
    data: volumeCreateManyCampaignInput | volumeCreateManyCampaignInput[]
  }

  export type leadCreateWithoutCampaignInput = {
    data: JsonNullValueInput | InputJsonValue
    email: string
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
    pacing: pacingCreateNestedOneWithoutLeadsInput
    volume: volumeCreateNestedOneWithoutLeadsInput
    upload?: leadsUploadCreateNestedOneWithoutLeadsInput
    campaignDelivery?: campaignDeliveriesCreateNestedOneWithoutLeadsInput
  }

  export type leadUncheckedCreateWithoutCampaignInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    pacingId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadCreateOrConnectWithoutCampaignInput = {
    where: leadWhereUniqueInput
    create: XOR<leadCreateWithoutCampaignInput, leadUncheckedCreateWithoutCampaignInput>
  }

  export type leadCreateManyCampaignInputEnvelope = {
    data: leadCreateManyCampaignInput | leadCreateManyCampaignInput[]
  }

  export type campaignDeliveriesCreateWithoutCampaignInput = {
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    data?: string
    uploader?: userCreateNestedOneWithoutDeliveriesInput
    leads?: leadCreateNestedManyWithoutCampaignDeliveryInput
  }

  export type campaignDeliveriesUncheckedCreateWithoutCampaignInput = {
    id?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    uploaderId?: number | null
    data?: string
    leads?: leadUncheckedCreateNestedManyWithoutCampaignDeliveryInput
  }

  export type campaignDeliveriesCreateOrConnectWithoutCampaignInput = {
    where: campaignDeliveriesWhereUniqueInput
    create: XOR<campaignDeliveriesCreateWithoutCampaignInput, campaignDeliveriesUncheckedCreateWithoutCampaignInput>
  }

  export type campaignDeliveriesCreateManyCampaignInputEnvelope = {
    data: campaignDeliveriesCreateManyCampaignInput | campaignDeliveriesCreateManyCampaignInput[]
  }

  export type clientUpsertWithoutCampaignsInput = {
    update: XOR<clientUpdateWithoutCampaignsInput, clientUncheckedUpdateWithoutCampaignsInput>
    create: XOR<clientCreateWithoutCampaignsInput, clientUncheckedCreateWithoutCampaignsInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutCampaignsInput, clientUncheckedUpdateWithoutCampaignsInput>
  }

  export type clientUpdateWithoutCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientUncheckedUpdateWithoutCampaignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type volumeUpsertWithWhereUniqueWithoutCampaignInput = {
    where: volumeWhereUniqueInput
    update: XOR<volumeUpdateWithoutCampaignInput, volumeUncheckedUpdateWithoutCampaignInput>
    create: XOR<volumeCreateWithoutCampaignInput, volumeUncheckedCreateWithoutCampaignInput>
  }

  export type volumeUpdateWithWhereUniqueWithoutCampaignInput = {
    where: volumeWhereUniqueInput
    data: XOR<volumeUpdateWithoutCampaignInput, volumeUncheckedUpdateWithoutCampaignInput>
  }

  export type volumeUpdateManyWithWhereWithoutCampaignInput = {
    where: volumeScalarWhereInput
    data: XOR<volumeUpdateManyMutationInput, volumeUncheckedUpdateManyWithoutCampaignInput>
  }

  export type volumeScalarWhereInput = {
    AND?: volumeScalarWhereInput | volumeScalarWhereInput[]
    OR?: volumeScalarWhereInput[]
    NOT?: volumeScalarWhereInput | volumeScalarWhereInput[]
    id?: IntFilter<"volume"> | number
    name?: StringFilter<"volume"> | string
    campaignId?: IntFilter<"volume"> | number
    leadGoal?: IntFilter<"volume"> | number
    completed?: IntFilter<"volume"> | number
    pending?: IntFilter<"volume"> | number
    status?: EnumVolumeStatusFilter<"volume"> | $Enums.VolumeStatus
    validationProfile?: JsonFilter<"volume">
    headers?: JsonFilter<"volume">
    leadTemplate?: StringFilter<"volume"> | string
    externalRules?: StringFilter<"volume"> | string
  }

  export type leadUpsertWithWhereUniqueWithoutCampaignInput = {
    where: leadWhereUniqueInput
    update: XOR<leadUpdateWithoutCampaignInput, leadUncheckedUpdateWithoutCampaignInput>
    create: XOR<leadCreateWithoutCampaignInput, leadUncheckedCreateWithoutCampaignInput>
  }

  export type leadUpdateWithWhereUniqueWithoutCampaignInput = {
    where: leadWhereUniqueInput
    data: XOR<leadUpdateWithoutCampaignInput, leadUncheckedUpdateWithoutCampaignInput>
  }

  export type leadUpdateManyWithWhereWithoutCampaignInput = {
    where: leadScalarWhereInput
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyWithoutCampaignInput>
  }

  export type leadScalarWhereInput = {
    AND?: leadScalarWhereInput | leadScalarWhereInput[]
    OR?: leadScalarWhereInput[]
    NOT?: leadScalarWhereInput | leadScalarWhereInput[]
    id?: IntFilter<"lead"> | number
    data?: JsonFilter<"lead">
    email?: StringFilter<"lead"> | string
    campaignId?: IntFilter<"lead"> | number
    pacingId?: IntFilter<"lead"> | number
    volumeId?: IntFilter<"lead"> | number
    uploadId?: IntNullableFilter<"lead"> | number | null
    uploadType?: StringFilter<"lead"> | string
    created_at?: DateTimeFilter<"lead"> | Date | string
    updated_at?: DateTimeFilter<"lead"> | Date | string
    phase1Validation?: BoolFilter<"lead"> | boolean
    leadTemplateValidation?: BoolFilter<"lead"> | boolean
    campaignDeliveryId?: IntNullableFilter<"lead"> | number | null
    accepted?: BoolFilter<"lead"> | boolean
    pending?: BoolFilter<"lead"> | boolean
    rejected?: BoolFilter<"lead"> | boolean
    rejectedReason?: StringFilter<"lead"> | string
  }

  export type campaignDeliveriesUpsertWithWhereUniqueWithoutCampaignInput = {
    where: campaignDeliveriesWhereUniqueInput
    update: XOR<campaignDeliveriesUpdateWithoutCampaignInput, campaignDeliveriesUncheckedUpdateWithoutCampaignInput>
    create: XOR<campaignDeliveriesCreateWithoutCampaignInput, campaignDeliveriesUncheckedCreateWithoutCampaignInput>
  }

  export type campaignDeliveriesUpdateWithWhereUniqueWithoutCampaignInput = {
    where: campaignDeliveriesWhereUniqueInput
    data: XOR<campaignDeliveriesUpdateWithoutCampaignInput, campaignDeliveriesUncheckedUpdateWithoutCampaignInput>
  }

  export type campaignDeliveriesUpdateManyWithWhereWithoutCampaignInput = {
    where: campaignDeliveriesScalarWhereInput
    data: XOR<campaignDeliveriesUpdateManyMutationInput, campaignDeliveriesUncheckedUpdateManyWithoutCampaignInput>
  }

  export type campaignCreateWithoutCampaignDeliveriesInput = {
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    client: clientCreateNestedOneWithoutCampaignsInput
    volumes?: volumeCreateNestedManyWithoutCampaignInput
    leads?: leadCreateNestedManyWithoutCampaignInput
  }

  export type campaignUncheckedCreateWithoutCampaignDeliveriesInput = {
    id?: number
    name: string
    code: string
    clientId: number
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    volumes?: volumeUncheckedCreateNestedManyWithoutCampaignInput
    leads?: leadUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type campaignCreateOrConnectWithoutCampaignDeliveriesInput = {
    where: campaignWhereUniqueInput
    create: XOR<campaignCreateWithoutCampaignDeliveriesInput, campaignUncheckedCreateWithoutCampaignDeliveriesInput>
  }

  export type userCreateWithoutDeliveriesInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadCreateNestedManyWithoutUploaderInput
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutUploaderInput
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDeliveriesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDeliveriesInput, userUncheckedCreateWithoutDeliveriesInput>
  }

  export type leadCreateWithoutCampaignDeliveryInput = {
    data: JsonNullValueInput | InputJsonValue
    email: string
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
    campaign: campaignCreateNestedOneWithoutLeadsInput
    pacing: pacingCreateNestedOneWithoutLeadsInput
    volume: volumeCreateNestedOneWithoutLeadsInput
    upload?: leadsUploadCreateNestedOneWithoutLeadsInput
  }

  export type leadUncheckedCreateWithoutCampaignDeliveryInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadCreateOrConnectWithoutCampaignDeliveryInput = {
    where: leadWhereUniqueInput
    create: XOR<leadCreateWithoutCampaignDeliveryInput, leadUncheckedCreateWithoutCampaignDeliveryInput>
  }

  export type leadCreateManyCampaignDeliveryInputEnvelope = {
    data: leadCreateManyCampaignDeliveryInput | leadCreateManyCampaignDeliveryInput[]
  }

  export type campaignUpsertWithoutCampaignDeliveriesInput = {
    update: XOR<campaignUpdateWithoutCampaignDeliveriesInput, campaignUncheckedUpdateWithoutCampaignDeliveriesInput>
    create: XOR<campaignCreateWithoutCampaignDeliveriesInput, campaignUncheckedCreateWithoutCampaignDeliveriesInput>
    where?: campaignWhereInput
  }

  export type campaignUpdateToOneWithWhereWithoutCampaignDeliveriesInput = {
    where?: campaignWhereInput
    data: XOR<campaignUpdateWithoutCampaignDeliveriesInput, campaignUncheckedUpdateWithoutCampaignDeliveriesInput>
  }

  export type campaignUpdateWithoutCampaignDeliveriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateOneRequiredWithoutCampaignsNestedInput
    volumes?: volumeUpdateManyWithoutCampaignNestedInput
    leads?: leadUpdateManyWithoutCampaignNestedInput
  }

  export type campaignUncheckedUpdateWithoutCampaignDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    volumes?: volumeUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: leadUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type userUpsertWithoutDeliveriesInput = {
    update: XOR<userUpdateWithoutDeliveriesInput, userUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<userCreateWithoutDeliveriesInput, userUncheckedCreateWithoutDeliveriesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutDeliveriesInput, userUncheckedUpdateWithoutDeliveriesInput>
  }

  export type userUpdateWithoutDeliveriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUpdateManyWithoutUploaderNestedInput
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutUploaderNestedInput
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type leadUpsertWithWhereUniqueWithoutCampaignDeliveryInput = {
    where: leadWhereUniqueInput
    update: XOR<leadUpdateWithoutCampaignDeliveryInput, leadUncheckedUpdateWithoutCampaignDeliveryInput>
    create: XOR<leadCreateWithoutCampaignDeliveryInput, leadUncheckedCreateWithoutCampaignDeliveryInput>
  }

  export type leadUpdateWithWhereUniqueWithoutCampaignDeliveryInput = {
    where: leadWhereUniqueInput
    data: XOR<leadUpdateWithoutCampaignDeliveryInput, leadUncheckedUpdateWithoutCampaignDeliveryInput>
  }

  export type leadUpdateManyWithWhereWithoutCampaignDeliveryInput = {
    where: leadScalarWhereInput
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyWithoutCampaignDeliveryInput>
  }

  export type campaignCreateWithoutVolumesInput = {
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    client: clientCreateNestedOneWithoutCampaignsInput
    leads?: leadCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesCreateNestedManyWithoutCampaignInput
  }

  export type campaignUncheckedCreateWithoutVolumesInput = {
    id?: number
    name: string
    code: string
    clientId: number
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    leads?: leadUncheckedCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type campaignCreateOrConnectWithoutVolumesInput = {
    where: campaignWhereUniqueInput
    create: XOR<campaignCreateWithoutVolumesInput, campaignUncheckedCreateWithoutVolumesInput>
  }

  export type pacingCreateWithoutVolumeInput = {
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    leads?: leadCreateNestedManyWithoutPacingInput
    uploads?: leadsUploadCreateNestedManyWithoutPacingInput
  }

  export type pacingUncheckedCreateWithoutVolumeInput = {
    id?: number
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    leads?: leadUncheckedCreateNestedManyWithoutPacingInput
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutPacingInput
  }

  export type pacingCreateOrConnectWithoutVolumeInput = {
    where: pacingWhereUniqueInput
    create: XOR<pacingCreateWithoutVolumeInput, pacingUncheckedCreateWithoutVolumeInput>
  }

  export type pacingCreateManyVolumeInputEnvelope = {
    data: pacingCreateManyVolumeInput | pacingCreateManyVolumeInput[]
  }

  export type leadCreateWithoutVolumeInput = {
    data: JsonNullValueInput | InputJsonValue
    email: string
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
    campaign: campaignCreateNestedOneWithoutLeadsInput
    pacing: pacingCreateNestedOneWithoutLeadsInput
    upload?: leadsUploadCreateNestedOneWithoutLeadsInput
    campaignDelivery?: campaignDeliveriesCreateNestedOneWithoutLeadsInput
  }

  export type leadUncheckedCreateWithoutVolumeInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadCreateOrConnectWithoutVolumeInput = {
    where: leadWhereUniqueInput
    create: XOR<leadCreateWithoutVolumeInput, leadUncheckedCreateWithoutVolumeInput>
  }

  export type leadCreateManyVolumeInputEnvelope = {
    data: leadCreateManyVolumeInput | leadCreateManyVolumeInput[]
  }

  export type campaignUpsertWithoutVolumesInput = {
    update: XOR<campaignUpdateWithoutVolumesInput, campaignUncheckedUpdateWithoutVolumesInput>
    create: XOR<campaignCreateWithoutVolumesInput, campaignUncheckedCreateWithoutVolumesInput>
    where?: campaignWhereInput
  }

  export type campaignUpdateToOneWithWhereWithoutVolumesInput = {
    where?: campaignWhereInput
    data: XOR<campaignUpdateWithoutVolumesInput, campaignUncheckedUpdateWithoutVolumesInput>
  }

  export type campaignUpdateWithoutVolumesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateOneRequiredWithoutCampaignsNestedInput
    leads?: leadUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUpdateManyWithoutCampaignNestedInput
  }

  export type campaignUncheckedUpdateWithoutVolumesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    leads?: leadUncheckedUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type pacingUpsertWithWhereUniqueWithoutVolumeInput = {
    where: pacingWhereUniqueInput
    update: XOR<pacingUpdateWithoutVolumeInput, pacingUncheckedUpdateWithoutVolumeInput>
    create: XOR<pacingCreateWithoutVolumeInput, pacingUncheckedCreateWithoutVolumeInput>
  }

  export type pacingUpdateWithWhereUniqueWithoutVolumeInput = {
    where: pacingWhereUniqueInput
    data: XOR<pacingUpdateWithoutVolumeInput, pacingUncheckedUpdateWithoutVolumeInput>
  }

  export type pacingUpdateManyWithWhereWithoutVolumeInput = {
    where: pacingScalarWhereInput
    data: XOR<pacingUpdateManyMutationInput, pacingUncheckedUpdateManyWithoutVolumeInput>
  }

  export type pacingScalarWhereInput = {
    AND?: pacingScalarWhereInput | pacingScalarWhereInput[]
    OR?: pacingScalarWhereInput[]
    NOT?: pacingScalarWhereInput | pacingScalarWhereInput[]
    id?: IntFilter<"pacing"> | number
    volumeId?: IntFilter<"pacing"> | number
    scheduledFor?: DateTimeFilter<"pacing"> | Date | string
    leadGoal?: IntFilter<"pacing"> | number
    status?: StringFilter<"pacing"> | string
    actualLeads?: IntFilter<"pacing"> | number
    created_at?: DateTimeFilter<"pacing"> | Date | string
    updated_at?: DateTimeFilter<"pacing"> | Date | string
  }

  export type leadUpsertWithWhereUniqueWithoutVolumeInput = {
    where: leadWhereUniqueInput
    update: XOR<leadUpdateWithoutVolumeInput, leadUncheckedUpdateWithoutVolumeInput>
    create: XOR<leadCreateWithoutVolumeInput, leadUncheckedCreateWithoutVolumeInput>
  }

  export type leadUpdateWithWhereUniqueWithoutVolumeInput = {
    where: leadWhereUniqueInput
    data: XOR<leadUpdateWithoutVolumeInput, leadUncheckedUpdateWithoutVolumeInput>
  }

  export type leadUpdateManyWithWhereWithoutVolumeInput = {
    where: leadScalarWhereInput
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyWithoutVolumeInput>
  }

  export type BriefUpdatesCreateWithoutBreifInput = {
    arrivedOn: Date | string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUpdatesUncheckedCreateWithoutBreifInput = {
    id?: number
    arrivedOn: Date | string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUpdatesCreateOrConnectWithoutBreifInput = {
    where: BriefUpdatesWhereUniqueInput
    create: XOR<BriefUpdatesCreateWithoutBreifInput, BriefUpdatesUncheckedCreateWithoutBreifInput>
  }

  export type BriefUpdatesCreateManyBreifInputEnvelope = {
    data: BriefUpdatesCreateManyBreifInput | BriefUpdatesCreateManyBreifInput[]
  }

  export type BriefUpdatesUpsertWithWhereUniqueWithoutBreifInput = {
    where: BriefUpdatesWhereUniqueInput
    update: XOR<BriefUpdatesUpdateWithoutBreifInput, BriefUpdatesUncheckedUpdateWithoutBreifInput>
    create: XOR<BriefUpdatesCreateWithoutBreifInput, BriefUpdatesUncheckedCreateWithoutBreifInput>
  }

  export type BriefUpdatesUpdateWithWhereUniqueWithoutBreifInput = {
    where: BriefUpdatesWhereUniqueInput
    data: XOR<BriefUpdatesUpdateWithoutBreifInput, BriefUpdatesUncheckedUpdateWithoutBreifInput>
  }

  export type BriefUpdatesUpdateManyWithWhereWithoutBreifInput = {
    where: BriefUpdatesScalarWhereInput
    data: XOR<BriefUpdatesUpdateManyMutationInput, BriefUpdatesUncheckedUpdateManyWithoutBreifInput>
  }

  export type BriefUpdatesScalarWhereInput = {
    AND?: BriefUpdatesScalarWhereInput | BriefUpdatesScalarWhereInput[]
    OR?: BriefUpdatesScalarWhereInput[]
    NOT?: BriefUpdatesScalarWhereInput | BriefUpdatesScalarWhereInput[]
    id?: IntFilter<"BriefUpdates"> | number
    briefId?: IntFilter<"BriefUpdates"> | number
    arrivedOn?: DateTimeFilter<"BriefUpdates"> | Date | string
    due?: DateTimeFilter<"BriefUpdates"> | Date | string
    status?: EnumBriefStatusFilter<"BriefUpdates"> | $Enums.BriefStatus
    leadDetails?: JsonNullableFilter<"BriefUpdates">
    type?: EnumBriefTypeFilter<"BriefUpdates"> | $Enums.BriefType
    quotes?: JsonNullableFilter<"BriefUpdates">
    campaignId?: IntNullableFilter<"BriefUpdates"> | number | null
    remark?: StringNullableFilter<"BriefUpdates"> | string | null
    briefHyperlink?: StringNullableFilter<"BriefUpdates"> | string | null
  }

  export type BriefCreateWithoutBriefUpdatesInput = {
    name: string
    arrivedOn: Date | string
    arrivedOnTime?: string
    dueTime?: string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: string
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUncheckedCreateWithoutBriefUpdatesInput = {
    id?: number
    name: string
    arrivedOn: Date | string
    arrivedOnTime?: string
    dueTime?: string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: string
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefCreateOrConnectWithoutBriefUpdatesInput = {
    where: BriefWhereUniqueInput
    create: XOR<BriefCreateWithoutBriefUpdatesInput, BriefUncheckedCreateWithoutBriefUpdatesInput>
  }

  export type BriefUpsertWithoutBriefUpdatesInput = {
    update: XOR<BriefUpdateWithoutBriefUpdatesInput, BriefUncheckedUpdateWithoutBriefUpdatesInput>
    create: XOR<BriefCreateWithoutBriefUpdatesInput, BriefUncheckedCreateWithoutBriefUpdatesInput>
    where?: BriefWhereInput
  }

  export type BriefUpdateToOneWithWhereWithoutBriefUpdatesInput = {
    where?: BriefWhereInput
    data: XOR<BriefUpdateWithoutBriefUpdatesInput, BriefUncheckedUpdateWithoutBriefUpdatesInput>
  }

  export type BriefUpdateWithoutBriefUpdatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivedOnTime?: StringFieldUpdateOperationsInput | string
    dueTime?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: StringFieldUpdateOperationsInput | string
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUncheckedUpdateWithoutBriefUpdatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivedOnTime?: StringFieldUpdateOperationsInput | string
    dueTime?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    leadDetailsSection?: StringFieldUpdateOperationsInput | string
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type volumeCreateWithoutPacingsInput = {
    name: string
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    campaign: campaignCreateNestedOneWithoutVolumesInput
    leads?: leadCreateNestedManyWithoutVolumeInput
  }

  export type volumeUncheckedCreateWithoutPacingsInput = {
    id?: number
    name: string
    campaignId: number
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    leads?: leadUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type volumeCreateOrConnectWithoutPacingsInput = {
    where: volumeWhereUniqueInput
    create: XOR<volumeCreateWithoutPacingsInput, volumeUncheckedCreateWithoutPacingsInput>
  }

  export type leadCreateWithoutPacingInput = {
    data: JsonNullValueInput | InputJsonValue
    email: string
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
    campaign: campaignCreateNestedOneWithoutLeadsInput
    volume: volumeCreateNestedOneWithoutLeadsInput
    upload?: leadsUploadCreateNestedOneWithoutLeadsInput
    campaignDelivery?: campaignDeliveriesCreateNestedOneWithoutLeadsInput
  }

  export type leadUncheckedCreateWithoutPacingInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadCreateOrConnectWithoutPacingInput = {
    where: leadWhereUniqueInput
    create: XOR<leadCreateWithoutPacingInput, leadUncheckedCreateWithoutPacingInput>
  }

  export type leadCreateManyPacingInputEnvelope = {
    data: leadCreateManyPacingInput | leadCreateManyPacingInput[]
  }

  export type leadsUploadCreateWithoutPacingInput = {
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    leads?: leadCreateNestedManyWithoutUploadInput
    uploader?: userCreateNestedOneWithoutUploadsInput
  }

  export type leadsUploadUncheckedCreateWithoutPacingInput = {
    id?: number
    uploadedBy?: number | null
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    leads?: leadUncheckedCreateNestedManyWithoutUploadInput
  }

  export type leadsUploadCreateOrConnectWithoutPacingInput = {
    where: leadsUploadWhereUniqueInput
    create: XOR<leadsUploadCreateWithoutPacingInput, leadsUploadUncheckedCreateWithoutPacingInput>
  }

  export type leadsUploadCreateManyPacingInputEnvelope = {
    data: leadsUploadCreateManyPacingInput | leadsUploadCreateManyPacingInput[]
  }

  export type volumeUpsertWithoutPacingsInput = {
    update: XOR<volumeUpdateWithoutPacingsInput, volumeUncheckedUpdateWithoutPacingsInput>
    create: XOR<volumeCreateWithoutPacingsInput, volumeUncheckedCreateWithoutPacingsInput>
    where?: volumeWhereInput
  }

  export type volumeUpdateToOneWithWhereWithoutPacingsInput = {
    where?: volumeWhereInput
    data: XOR<volumeUpdateWithoutPacingsInput, volumeUncheckedUpdateWithoutPacingsInput>
  }

  export type volumeUpdateWithoutPacingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutVolumesNestedInput
    leads?: leadUpdateManyWithoutVolumeNestedInput
  }

  export type volumeUncheckedUpdateWithoutPacingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    leads?: leadUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type leadUpsertWithWhereUniqueWithoutPacingInput = {
    where: leadWhereUniqueInput
    update: XOR<leadUpdateWithoutPacingInput, leadUncheckedUpdateWithoutPacingInput>
    create: XOR<leadCreateWithoutPacingInput, leadUncheckedCreateWithoutPacingInput>
  }

  export type leadUpdateWithWhereUniqueWithoutPacingInput = {
    where: leadWhereUniqueInput
    data: XOR<leadUpdateWithoutPacingInput, leadUncheckedUpdateWithoutPacingInput>
  }

  export type leadUpdateManyWithWhereWithoutPacingInput = {
    where: leadScalarWhereInput
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyWithoutPacingInput>
  }

  export type leadsUploadUpsertWithWhereUniqueWithoutPacingInput = {
    where: leadsUploadWhereUniqueInput
    update: XOR<leadsUploadUpdateWithoutPacingInput, leadsUploadUncheckedUpdateWithoutPacingInput>
    create: XOR<leadsUploadCreateWithoutPacingInput, leadsUploadUncheckedCreateWithoutPacingInput>
  }

  export type leadsUploadUpdateWithWhereUniqueWithoutPacingInput = {
    where: leadsUploadWhereUniqueInput
    data: XOR<leadsUploadUpdateWithoutPacingInput, leadsUploadUncheckedUpdateWithoutPacingInput>
  }

  export type leadsUploadUpdateManyWithWhereWithoutPacingInput = {
    where: leadsUploadScalarWhereInput
    data: XOR<leadsUploadUpdateManyMutationInput, leadsUploadUncheckedUpdateManyWithoutPacingInput>
  }

  export type campaignCreateWithoutLeadsInput = {
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    client: clientCreateNestedOneWithoutCampaignsInput
    volumes?: volumeCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesCreateNestedManyWithoutCampaignInput
  }

  export type campaignUncheckedCreateWithoutLeadsInput = {
    id?: number
    name: string
    code: string
    clientId: number
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    volumes?: volumeUncheckedCreateNestedManyWithoutCampaignInput
    campaignDeliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type campaignCreateOrConnectWithoutLeadsInput = {
    where: campaignWhereUniqueInput
    create: XOR<campaignCreateWithoutLeadsInput, campaignUncheckedCreateWithoutLeadsInput>
  }

  export type pacingCreateWithoutLeadsInput = {
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    volume: volumeCreateNestedOneWithoutPacingsInput
    uploads?: leadsUploadCreateNestedManyWithoutPacingInput
  }

  export type pacingUncheckedCreateWithoutLeadsInput = {
    id?: number
    volumeId: number
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    uploads?: leadsUploadUncheckedCreateNestedManyWithoutPacingInput
  }

  export type pacingCreateOrConnectWithoutLeadsInput = {
    where: pacingWhereUniqueInput
    create: XOR<pacingCreateWithoutLeadsInput, pacingUncheckedCreateWithoutLeadsInput>
  }

  export type volumeCreateWithoutLeadsInput = {
    name: string
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    campaign: campaignCreateNestedOneWithoutVolumesInput
    pacings?: pacingCreateNestedManyWithoutVolumeInput
  }

  export type volumeUncheckedCreateWithoutLeadsInput = {
    id?: number
    name: string
    campaignId: number
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
    pacings?: pacingUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type volumeCreateOrConnectWithoutLeadsInput = {
    where: volumeWhereUniqueInput
    create: XOR<volumeCreateWithoutLeadsInput, volumeUncheckedCreateWithoutLeadsInput>
  }

  export type leadsUploadCreateWithoutLeadsInput = {
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
    pacing: pacingCreateNestedOneWithoutUploadsInput
    uploader?: userCreateNestedOneWithoutUploadsInput
  }

  export type leadsUploadUncheckedCreateWithoutLeadsInput = {
    id?: number
    pacingId: number
    uploadedBy?: number | null
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
  }

  export type leadsUploadCreateOrConnectWithoutLeadsInput = {
    where: leadsUploadWhereUniqueInput
    create: XOR<leadsUploadCreateWithoutLeadsInput, leadsUploadUncheckedCreateWithoutLeadsInput>
  }

  export type campaignDeliveriesCreateWithoutLeadsInput = {
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    data?: string
    campaign?: campaignCreateNestedOneWithoutCampaignDeliveriesInput
    uploader?: userCreateNestedOneWithoutDeliveriesInput
  }

  export type campaignDeliveriesUncheckedCreateWithoutLeadsInput = {
    id?: number
    campaignId?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    uploaderId?: number | null
    data?: string
  }

  export type campaignDeliveriesCreateOrConnectWithoutLeadsInput = {
    where: campaignDeliveriesWhereUniqueInput
    create: XOR<campaignDeliveriesCreateWithoutLeadsInput, campaignDeliveriesUncheckedCreateWithoutLeadsInput>
  }

  export type campaignUpsertWithoutLeadsInput = {
    update: XOR<campaignUpdateWithoutLeadsInput, campaignUncheckedUpdateWithoutLeadsInput>
    create: XOR<campaignCreateWithoutLeadsInput, campaignUncheckedCreateWithoutLeadsInput>
    where?: campaignWhereInput
  }

  export type campaignUpdateToOneWithWhereWithoutLeadsInput = {
    where?: campaignWhereInput
    data: XOR<campaignUpdateWithoutLeadsInput, campaignUncheckedUpdateWithoutLeadsInput>
  }

  export type campaignUpdateWithoutLeadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client?: clientUpdateOneRequiredWithoutCampaignsNestedInput
    volumes?: volumeUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUpdateManyWithoutCampaignNestedInput
  }

  export type campaignUncheckedUpdateWithoutLeadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    volumes?: volumeUncheckedUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type pacingUpsertWithoutLeadsInput = {
    update: XOR<pacingUpdateWithoutLeadsInput, pacingUncheckedUpdateWithoutLeadsInput>
    create: XOR<pacingCreateWithoutLeadsInput, pacingUncheckedCreateWithoutLeadsInput>
    where?: pacingWhereInput
  }

  export type pacingUpdateToOneWithWhereWithoutLeadsInput = {
    where?: pacingWhereInput
    data: XOR<pacingUpdateWithoutLeadsInput, pacingUncheckedUpdateWithoutLeadsInput>
  }

  export type pacingUpdateWithoutLeadsInput = {
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: volumeUpdateOneRequiredWithoutPacingsNestedInput
    uploads?: leadsUploadUpdateManyWithoutPacingNestedInput
  }

  export type pacingUncheckedUpdateWithoutLeadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploads?: leadsUploadUncheckedUpdateManyWithoutPacingNestedInput
  }

  export type volumeUpsertWithoutLeadsInput = {
    update: XOR<volumeUpdateWithoutLeadsInput, volumeUncheckedUpdateWithoutLeadsInput>
    create: XOR<volumeCreateWithoutLeadsInput, volumeUncheckedCreateWithoutLeadsInput>
    where?: volumeWhereInput
  }

  export type volumeUpdateToOneWithWhereWithoutLeadsInput = {
    where?: volumeWhereInput
    data: XOR<volumeUpdateWithoutLeadsInput, volumeUncheckedUpdateWithoutLeadsInput>
  }

  export type volumeUpdateWithoutLeadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutVolumesNestedInput
    pacings?: pacingUpdateManyWithoutVolumeNestedInput
  }

  export type volumeUncheckedUpdateWithoutLeadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    pacings?: pacingUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type leadsUploadUpsertWithoutLeadsInput = {
    update: XOR<leadsUploadUpdateWithoutLeadsInput, leadsUploadUncheckedUpdateWithoutLeadsInput>
    create: XOR<leadsUploadCreateWithoutLeadsInput, leadsUploadUncheckedCreateWithoutLeadsInput>
    where?: leadsUploadWhereInput
  }

  export type leadsUploadUpdateToOneWithWhereWithoutLeadsInput = {
    where?: leadsUploadWhereInput
    data: XOR<leadsUploadUpdateWithoutLeadsInput, leadsUploadUncheckedUpdateWithoutLeadsInput>
  }

  export type leadsUploadUpdateWithoutLeadsInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    pacing?: pacingUpdateOneRequiredWithoutUploadsNestedInput
    uploader?: userUpdateOneWithoutUploadsNestedInput
  }

  export type leadsUploadUncheckedUpdateWithoutLeadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
  }

  export type campaignDeliveriesUpsertWithoutLeadsInput = {
    update: XOR<campaignDeliveriesUpdateWithoutLeadsInput, campaignDeliveriesUncheckedUpdateWithoutLeadsInput>
    create: XOR<campaignDeliveriesCreateWithoutLeadsInput, campaignDeliveriesUncheckedCreateWithoutLeadsInput>
    where?: campaignDeliveriesWhereInput
  }

  export type campaignDeliveriesUpdateToOneWithWhereWithoutLeadsInput = {
    where?: campaignDeliveriesWhereInput
    data: XOR<campaignDeliveriesUpdateWithoutLeadsInput, campaignDeliveriesUncheckedUpdateWithoutLeadsInput>
  }

  export type campaignDeliveriesUpdateWithoutLeadsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutCampaignDeliveriesNestedInput
    uploader?: userUpdateOneWithoutDeliveriesNestedInput
  }

  export type campaignDeliveriesUncheckedUpdateWithoutLeadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    uploaderId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: StringFieldUpdateOperationsInput | string
  }

  export type pacingCreateWithoutUploadsInput = {
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    volume: volumeCreateNestedOneWithoutPacingsInput
    leads?: leadCreateNestedManyWithoutPacingInput
  }

  export type pacingUncheckedCreateWithoutUploadsInput = {
    id?: number
    volumeId: number
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
    leads?: leadUncheckedCreateNestedManyWithoutPacingInput
  }

  export type pacingCreateOrConnectWithoutUploadsInput = {
    where: pacingWhereUniqueInput
    create: XOR<pacingCreateWithoutUploadsInput, pacingUncheckedCreateWithoutUploadsInput>
  }

  export type leadCreateWithoutUploadInput = {
    data: JsonNullValueInput | InputJsonValue
    email: string
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
    campaign: campaignCreateNestedOneWithoutLeadsInput
    pacing: pacingCreateNestedOneWithoutLeadsInput
    volume: volumeCreateNestedOneWithoutLeadsInput
    campaignDelivery?: campaignDeliveriesCreateNestedOneWithoutLeadsInput
  }

  export type leadUncheckedCreateWithoutUploadInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadCreateOrConnectWithoutUploadInput = {
    where: leadWhereUniqueInput
    create: XOR<leadCreateWithoutUploadInput, leadUncheckedCreateWithoutUploadInput>
  }

  export type leadCreateManyUploadInputEnvelope = {
    data: leadCreateManyUploadInput | leadCreateManyUploadInput[]
  }

  export type userCreateWithoutUploadsInput = {
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    roles?: userroleCreateNestedManyWithoutUserInput
    leaves?: UserLeaveCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageCreateNestedManyWithoutSenderInput
    receivedMessages?: messageCreateNestedManyWithoutRecipientInput
    groups?: userGroupsCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageCreateNestedManyWithoutSenderInput
    tasks?: UserTaskCreateNestedManyWithoutUserInput
    breaks?: UserBreakCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskCreateNestedManyWithoutAssigneeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUploadsInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    roles?: userroleUncheckedCreateNestedManyWithoutUserInput
    leaves?: UserLeaveUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: UserLeaveUncheckedCreateNestedManyWithoutApprovedByInput
    sentMessages?: messageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: messageUncheckedCreateNestedManyWithoutRecipientInput
    groups?: userGroupsUncheckedCreateNestedManyWithoutUserInput
    sentMessage?: groupMessageUncheckedCreateNestedManyWithoutSenderInput
    tasks?: UserTaskUncheckedCreateNestedManyWithoutUserInput
    breaks?: UserBreakUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: UserTaskUncheckedCreateNestedManyWithoutAssigneeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    deliveries?: campaignDeliveriesUncheckedCreateNestedManyWithoutUploaderInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUploadsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUploadsInput, userUncheckedCreateWithoutUploadsInput>
  }

  export type pacingUpsertWithoutUploadsInput = {
    update: XOR<pacingUpdateWithoutUploadsInput, pacingUncheckedUpdateWithoutUploadsInput>
    create: XOR<pacingCreateWithoutUploadsInput, pacingUncheckedCreateWithoutUploadsInput>
    where?: pacingWhereInput
  }

  export type pacingUpdateToOneWithWhereWithoutUploadsInput = {
    where?: pacingWhereInput
    data: XOR<pacingUpdateWithoutUploadsInput, pacingUncheckedUpdateWithoutUploadsInput>
  }

  export type pacingUpdateWithoutUploadsInput = {
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    volume?: volumeUpdateOneRequiredWithoutPacingsNestedInput
    leads?: leadUpdateManyWithoutPacingNestedInput
  }

  export type pacingUncheckedUpdateWithoutUploadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: leadUncheckedUpdateManyWithoutPacingNestedInput
  }

  export type leadUpsertWithWhereUniqueWithoutUploadInput = {
    where: leadWhereUniqueInput
    update: XOR<leadUpdateWithoutUploadInput, leadUncheckedUpdateWithoutUploadInput>
    create: XOR<leadCreateWithoutUploadInput, leadUncheckedCreateWithoutUploadInput>
  }

  export type leadUpdateWithWhereUniqueWithoutUploadInput = {
    where: leadWhereUniqueInput
    data: XOR<leadUpdateWithoutUploadInput, leadUncheckedUpdateWithoutUploadInput>
  }

  export type leadUpdateManyWithWhereWithoutUploadInput = {
    where: leadScalarWhereInput
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyWithoutUploadInput>
  }

  export type userUpsertWithoutUploadsInput = {
    update: XOR<userUpdateWithoutUploadsInput, userUncheckedUpdateWithoutUploadsInput>
    create: XOR<userCreateWithoutUploadsInput, userUncheckedCreateWithoutUploadsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUploadsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUploadsInput, userUncheckedUpdateWithoutUploadsInput>
  }

  export type userUpdateWithoutUploadsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: userroleUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUploadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: userroleUncheckedUpdateManyWithoutUserNestedInput
    leaves?: UserLeaveUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: UserLeaveUncheckedUpdateManyWithoutApprovedByNestedInput
    sentMessages?: messageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: messageUncheckedUpdateManyWithoutRecipientNestedInput
    groups?: userGroupsUncheckedUpdateManyWithoutUserNestedInput
    sentMessage?: groupMessageUncheckedUpdateManyWithoutSenderNestedInput
    tasks?: UserTaskUncheckedUpdateManyWithoutUserNestedInput
    breaks?: UserBreakUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: UserTaskUncheckedUpdateManyWithoutAssigneeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    deliveries?: campaignDeliveriesUncheckedUpdateManyWithoutUploaderNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type leadsUploadCreateManyUploaderInput = {
    id?: number
    pacingId: number
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
  }

  export type userroleCreateManyUserInput = {
    id?: number
    roleId?: number
  }

  export type UserLeaveCreateManyUserInput = {
    id?: number
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    approvedById?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserLeaveCreateManyApprovedByInput = {
    id?: number
    userId: number
    leaveType: $Enums.LeaveType
    fromDate: Date | string
    toDate: Date | string
    duration: $Enums.LeaveDuration
    reason: string
    status?: $Enums.LeaveStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type messageCreateManySenderInput = {
    id?: number
    body: string
    recipientId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type messageCreateManyRecipientInput = {
    id?: number
    body: string
    senderId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type userGroupsCreateManyUserInput = {
    groupId: number
    assignedAt?: Date | string
  }

  export type groupMessageCreateManySenderInput = {
    id?: number
    groupId: number
    body: string
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type UserTaskCreateManyUserInput = {
    id?: number
    taskId: number
    totalTime: number
    assignedById: number
  }

  export type UserBreakCreateManyUserInput = {
    id?: number
    breakId: number
    totalTime: number
  }

  export type UserTaskCreateManyAssigneeInput = {
    id?: number
    userId: number
    taskId: number
    totalTime: number
  }

  export type SessionCreateManyUserInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    taskId?: number | null
    breakId?: number | null
  }

  export type campaignDeliveriesCreateManyUploaderInput = {
    id?: number
    campaignId?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    data?: string
  }

  export type AttendanceCreateManyUserInput = {
    id?: number
    date?: Date | string
    checkIn?: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
  }

  export type leadsUploadUpdateWithoutUploaderInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    pacing?: pacingUpdateOneRequiredWithoutUploadsNestedInput
    leads?: leadUpdateManyWithoutUploadNestedInput
  }

  export type leadsUploadUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    leads?: leadUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type leadsUploadUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
  }

  export type userroleUpdateWithoutUserInput = {
    role?: roleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type userroleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserLeaveUpdateWithoutUserInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: userUpdateOneWithoutApprovedLeavesNestedInput
  }

  export type UserLeaveUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLeaveUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLeaveUpdateWithoutApprovedByInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type UserLeaveUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLeaveUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: EnumLeaveDurationFieldUpdateOperationsInput | $Enums.LeaveDuration
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messageUpdateWithoutSenderInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient?: userUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type messageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    recipientId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    recipientId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUpdateWithoutRecipientInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: userUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type messageUncheckedUpdateWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messageUncheckedUpdateManyWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userGroupsUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: groupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type userGroupsUncheckedUpdateWithoutUserInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userGroupsUncheckedUpdateManyWithoutUserInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupMessageUpdateWithoutSenderInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: groupUpdateOneRequiredWithoutGroupMessagesNestedInput
  }

  export type groupMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserTaskUpdateWithoutUserInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    task?: TaskUpdateOneRequiredWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutTaskNestedInput
    assignee?: userUpdateOneRequiredWithoutAssignedTasksNestedInput
  }

  export type UserTaskUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserTaskUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakUpdateWithoutUserInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    break?: BreakUpdateOneRequiredWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutBreakNestedInput
  }

  export type UserBreakUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    breakId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutBreakNestedInput
  }

  export type UserBreakUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    breakId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type UserTaskUpdateWithoutAssigneeInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutTasksNestedInput
    task?: TaskUpdateOneRequiredWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutTaskNestedInput
  }

  export type UserTaskUncheckedUpdateWithoutAssigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserTaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type SessionUpdateWithoutUserInput = {
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task?: UserTaskUpdateOneWithoutSessionsNestedInput
    break?: UserBreakUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    breakId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    breakId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type campaignDeliveriesUpdateWithoutUploaderInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutCampaignDeliveriesNestedInput
    leads?: leadUpdateManyWithoutCampaignDeliveryNestedInput
  }

  export type campaignDeliveriesUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    leads?: leadUncheckedUpdateManyWithoutCampaignDeliveryNestedInput
  }

  export type campaignDeliveriesUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyTaskInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    userId: number
    breakId?: number | null
  }

  export type SessionUpdateWithoutTaskInput = {
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSessionsNestedInput
    break?: UserBreakUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    breakId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    breakId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateManyBreakInput = {
    id?: number
    type: $Enums.SessionType
    startTime: Date | string
    latestLogged?: Date | string
    endTime?: Date | string | null
    userId: number
    taskId?: number | null
  }

  export type SessionUpdateWithoutBreakInput = {
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSessionsNestedInput
    task?: UserTaskUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutBreakInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionUncheckedUpdateManyWithoutBreakInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latestLogged?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserTaskCreateManyTaskInput = {
    id?: number
    userId: number
    totalTime: number
    assignedById: number
  }

  export type UserTaskUpdateWithoutTaskInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutTasksNestedInput
    sessions?: SessionUpdateManyWithoutTaskNestedInput
    assignee?: userUpdateOneRequiredWithoutAssignedTasksNestedInput
  }

  export type UserTaskUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserTaskUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    assignedById?: IntFieldUpdateOperationsInput | number
  }

  export type UserBreakCreateManyBreakInput = {
    id?: number
    userId: number
    totalTime: number
  }

  export type UserBreakUpdateWithoutBreakInput = {
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutBreaksNestedInput
    sessions?: SessionUpdateManyWithoutBreakNestedInput
  }

  export type UserBreakUncheckedUpdateWithoutBreakInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutBreakNestedInput
  }

  export type UserBreakUncheckedUpdateManyWithoutBreakInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type userGroupsCreateManyGroupInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type groupMessageCreateManyGroupInput = {
    id?: number
    body: string
    senderId: number
    created_at?: Date | string
    read_at?: Date | string | null
  }

  export type userGroupsUpdateWithoutGroupInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type userGroupsUncheckedUpdateWithoutGroupInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userGroupsUncheckedUpdateManyWithoutGroupInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupMessageUpdateWithoutGroupInput = {
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: userUpdateOneRequiredWithoutSentMessageNestedInput
  }

  export type groupMessageUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupMessageUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleNotificationCreateManyNotificationInput = {
    roleId: number
  }

  export type roleNotificationUpdateWithoutNotificationInput = {
    role?: roleUpdateOneRequiredWithoutRoleNotificationsNestedInput
  }

  export type roleNotificationUncheckedUpdateWithoutNotificationInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type roleNotificationUncheckedUpdateManyWithoutNotificationInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type notificationCreateManyNotificationPriorityInput = {
    id?: number
    message: string
    createdAt?: Date | string
    url: string
    type: string
  }

  export type notificationUpdateWithoutNotificationPriorityInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    roleNotifications?: roleNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateWithoutNotificationPriorityInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    roleNotifications?: roleNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateManyWithoutNotificationPriorityInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type userroleCreateManyRoleInput = {
    id?: number
    userId: number
  }

  export type roleNotificationCreateManyRoleInput = {
    notificationId: number
  }

  export type userroleUpdateWithoutRoleInput = {
    user?: userUpdateOneRequiredWithoutRolesNestedInput
  }

  export type userroleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type roleNotificationUpdateWithoutRoleInput = {
    notification?: notificationUpdateOneRequiredWithoutRoleNotificationsNestedInput
  }

  export type roleNotificationUncheckedUpdateWithoutRoleInput = {
    notificationId?: IntFieldUpdateOperationsInput | number
  }

  export type roleNotificationUncheckedUpdateManyWithoutRoleInput = {
    notificationId?: IntFieldUpdateOperationsInput | number
  }

  export type campaignCreateManyClientInput = {
    id?: number
    name: string
    code: string
    leadgoal?: number
    completed: number
    pending: number
    duedate?: Date | string
    info: JsonNullValueInput | InputJsonValue
    content: JsonNullValueInput | InputJsonValue
    filesInfo: JsonNullValueInput | InputJsonValue
    updates: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type campaignUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    volumes?: volumeUpdateManyWithoutCampaignNestedInput
    leads?: leadUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUpdateManyWithoutCampaignNestedInput
  }

  export type campaignUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    volumes?: volumeUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: leadUncheckedUpdateManyWithoutCampaignNestedInput
    campaignDeliveries?: campaignDeliveriesUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type campaignUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    leadgoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    duedate?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    content?: JsonNullValueInput | InputJsonValue
    filesInfo?: JsonNullValueInput | InputJsonValue
    updates?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type volumeCreateManyCampaignInput = {
    id?: number
    name: string
    leadGoal: number
    completed: number
    pending: number
    status?: $Enums.VolumeStatus
    validationProfile: JsonNullValueInput | InputJsonValue
    headers: JsonNullValueInput | InputJsonValue
    leadTemplate?: string
    externalRules?: string
  }

  export type leadCreateManyCampaignInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    pacingId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type campaignDeliveriesCreateManyCampaignInput = {
    id?: number
    date?: Date | string
    fileName?: string
    submitted?: number
    accepted?: number
    errors?: number
    rejections?: number
    uploaderId?: number | null
    data?: string
  }

  export type volumeUpdateWithoutCampaignInput = {
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    pacings?: pacingUpdateManyWithoutVolumeNestedInput
    leads?: leadUpdateManyWithoutVolumeNestedInput
  }

  export type volumeUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
    pacings?: pacingUncheckedUpdateManyWithoutVolumeNestedInput
    leads?: leadUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type volumeUncheckedUpdateManyWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    status?: EnumVolumeStatusFieldUpdateOperationsInput | $Enums.VolumeStatus
    validationProfile?: JsonNullValueInput | InputJsonValue
    headers?: JsonNullValueInput | InputJsonValue
    leadTemplate?: StringFieldUpdateOperationsInput | string
    externalRules?: StringFieldUpdateOperationsInput | string
  }

  export type leadUpdateWithoutCampaignInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
    pacing?: pacingUpdateOneRequiredWithoutLeadsNestedInput
    volume?: volumeUpdateOneRequiredWithoutLeadsNestedInput
    upload?: leadsUploadUpdateOneWithoutLeadsNestedInput
    campaignDelivery?: campaignDeliveriesUpdateOneWithoutLeadsNestedInput
  }

  export type leadUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadUncheckedUpdateManyWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type campaignDeliveriesUpdateWithoutCampaignInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    uploader?: userUpdateOneWithoutDeliveriesNestedInput
    leads?: leadUpdateManyWithoutCampaignDeliveryNestedInput
  }

  export type campaignDeliveriesUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    uploaderId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: StringFieldUpdateOperationsInput | string
    leads?: leadUncheckedUpdateManyWithoutCampaignDeliveryNestedInput
  }

  export type campaignDeliveriesUncheckedUpdateManyWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    submitted?: IntFieldUpdateOperationsInput | number
    accepted?: IntFieldUpdateOperationsInput | number
    errors?: IntFieldUpdateOperationsInput | number
    rejections?: IntFieldUpdateOperationsInput | number
    uploaderId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: StringFieldUpdateOperationsInput | string
  }

  export type leadCreateManyCampaignDeliveryInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadUpdateWithoutCampaignDeliveryInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutLeadsNestedInput
    pacing?: pacingUpdateOneRequiredWithoutLeadsNestedInput
    volume?: volumeUpdateOneRequiredWithoutLeadsNestedInput
    upload?: leadsUploadUpdateOneWithoutLeadsNestedInput
  }

  export type leadUncheckedUpdateWithoutCampaignDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadUncheckedUpdateManyWithoutCampaignDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type pacingCreateManyVolumeInput = {
    id?: number
    scheduledFor: Date | string
    leadGoal: number
    status?: string
    actualLeads?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type leadCreateManyVolumeInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type pacingUpdateWithoutVolumeInput = {
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: leadUpdateManyWithoutPacingNestedInput
    uploads?: leadsUploadUpdateManyWithoutPacingNestedInput
  }

  export type pacingUncheckedUpdateWithoutVolumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: leadUncheckedUpdateManyWithoutPacingNestedInput
    uploads?: leadsUploadUncheckedUpdateManyWithoutPacingNestedInput
  }

  export type pacingUncheckedUpdateManyWithoutVolumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    leadGoal?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    actualLeads?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leadUpdateWithoutVolumeInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutLeadsNestedInput
    pacing?: pacingUpdateOneRequiredWithoutLeadsNestedInput
    upload?: leadsUploadUpdateOneWithoutLeadsNestedInput
    campaignDelivery?: campaignDeliveriesUpdateOneWithoutLeadsNestedInput
  }

  export type leadUncheckedUpdateWithoutVolumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadUncheckedUpdateManyWithoutVolumeInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type BriefUpdatesCreateManyBreifInput = {
    id?: number
    arrivedOn: Date | string
    due: Date | string
    status?: $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: number | null
    remark?: string | null
    briefHyperlink?: string | null
  }

  export type BriefUpdatesUpdateWithoutBreifInput = {
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUpdatesUncheckedUpdateWithoutBreifInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BriefUpdatesUncheckedUpdateManyWithoutBreifInput = {
    id?: IntFieldUpdateOperationsInput | number
    arrivedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBriefStatusFieldUpdateOperationsInput | $Enums.BriefStatus
    leadDetails?: NullableJsonNullValueInput | InputJsonValue
    type?: EnumBriefTypeFieldUpdateOperationsInput | $Enums.BriefType
    quotes?: NullableJsonNullValueInput | InputJsonValue
    campaignId?: NullableIntFieldUpdateOperationsInput | number | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    briefHyperlink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type leadCreateManyPacingInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    volumeId: number
    uploadId?: number | null
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadsUploadCreateManyPacingInput = {
    id?: number
    uploadedBy?: number | null
    filename?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    results: JsonNullValueInput | InputJsonValue
  }

  export type leadUpdateWithoutPacingInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutLeadsNestedInput
    volume?: volumeUpdateOneRequiredWithoutLeadsNestedInput
    upload?: leadsUploadUpdateOneWithoutLeadsNestedInput
    campaignDelivery?: campaignDeliveriesUpdateOneWithoutLeadsNestedInput
  }

  export type leadUncheckedUpdateWithoutPacingInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadUncheckedUpdateManyWithoutPacingInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadsUploadUpdateWithoutPacingInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    leads?: leadUpdateManyWithoutUploadNestedInput
    uploader?: userUpdateOneWithoutUploadsNestedInput
  }

  export type leadsUploadUncheckedUpdateWithoutPacingInput = {
    id?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
    leads?: leadUncheckedUpdateManyWithoutUploadNestedInput
  }

  export type leadsUploadUncheckedUpdateManyWithoutPacingInput = {
    id?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: JsonNullValueInput | InputJsonValue
  }

  export type leadCreateManyUploadInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    email: string
    campaignId: number
    pacingId: number
    volumeId: number
    uploadType?: string
    created_at?: Date | string
    updated_at?: Date | string
    phase1Validation?: boolean
    leadTemplateValidation?: boolean
    campaignDeliveryId?: number | null
    accepted?: boolean
    pending?: boolean
    rejected?: boolean
    rejectedReason?: string
  }

  export type leadUpdateWithoutUploadInput = {
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
    campaign?: campaignUpdateOneRequiredWithoutLeadsNestedInput
    pacing?: pacingUpdateOneRequiredWithoutLeadsNestedInput
    volume?: volumeUpdateOneRequiredWithoutLeadsNestedInput
    campaignDelivery?: campaignDeliveriesUpdateOneWithoutLeadsNestedInput
  }

  export type leadUncheckedUpdateWithoutUploadInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }

  export type leadUncheckedUpdateManyWithoutUploadInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    campaignId?: IntFieldUpdateOperationsInput | number
    pacingId?: IntFieldUpdateOperationsInput | number
    volumeId?: IntFieldUpdateOperationsInput | number
    uploadType?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phase1Validation?: BoolFieldUpdateOperationsInput | boolean
    leadTemplateValidation?: BoolFieldUpdateOperationsInput | boolean
    campaignDeliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    rejected?: BoolFieldUpdateOperationsInput | boolean
    rejectedReason?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}